#+Title: setting.org

* Emacs startup
  :PROPERTIES:
  :ID:       8193566d-2dd5-4368-8238-fac2fc9aa7e9
  :END:
** save custom configs in a seperate file
to save the custom configs in a seperate file from init.el

#+BEGIN_SRC emacs-lisp :results none
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

$Note The first function just reloads the Emacs configuration. The second function opens the configuration up for editing.$

** Check which OS your on
#+begin_src emacs-lisp results none
  ; Check if system is windows
  (defun system-type-is-win ()
  (interactive)
  "Return true if system is windows"
  (string-equal system-type "windows-nt")
  )

  ;; Check if system is GNU/Linux
  (defun system-type-is-gnu ()
  (interactive)
  "Return true if system is GNU/Linux-based"
  (string-equal system-type "gnu/linux")
  )
#+end_src
** set main theme

To edit the theme file:~/.emacs.d/themes/zprime-theme.el

#+BEGIN_SRC emacs-lisp :results none
  ;;;add custom themes to list
  (add-to-list 'custom-theme-load-path "/home/zeltak/.emacs.d/themes")
  ;to load a specifc theme 
  ;(load-file "~/.emacs.d/themes/zprime-theme.el")
  ;load the choosen theme at startup 
  (load-theme 'zprime t)

;;;; below works but changes GUI apps theme when launching term..not good..maybe look into this in future  

;; ;; last t is for NO-ENABLE
  ;;   (load-theme 'zprime t t)
  ;;   (load-theme 'tango-dark t t)
  
  ;;   (defun mb/pick-color-theme (frame)
  ;;     (select-frame frame)
  ;;     (if (window-system frame)
  ;;         (progn  
  ;;           (disable-theme 'tango-dark) ; in case it was active
  ;;           (enable-theme 'zprime))
  ;;       (progn  
  ;;         (disable-theme 'zprime) ; in case it was active
  ;;         (enable-theme 'tango-dark))))
  ;;   (add-hook 'after-make-frame-functions 'mb/pick-color-theme)
  
  ;;   ;; For when started with emacs or emacs -nw rather than emacs --daemon
  ;;   (if window-system
  ;;       (enable-theme 'zprime)
  ;;     (enable-theme 'tango-dark))

#+END_SRC

** custom org export options (must be on top of settings to work for reason still discovered)
 #+BEGIN_SRC emacs-lisp :results none
(setq org-export-backends (quote (ascii html icalendar latex org)))
 #+END_SRC
** add org contrib 
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/org-mode/contrib/lisp/")
#+END_SRC
** Fonts
#+begin_src emacs-lisp results none
; fonts in linux
(if (system-type-is-gnu)
;(add-to-list 'default-frame-alist '(font . "Inconsolata-16"))
;(add-to-list 'default-frame-alist '(font . "Source Code Pro-14"))
(add-to-list 'default-frame-alist '(font . "Pragmata Pro-17"))
;(add-to-list 'default-frame-alist '(font . "Fantasque Sans Mono 14"))
;(add-to-list 'default-frame-alist '(font . "fira mono 14"))
)

;; fontso in Win
(if (system-type-is-win)
(add-to-list 'default-frame-alist '(font . "Consolas-14"))
)

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
;; UTF-8 as default encoding
(set-language-environment "UTF-8")

;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))
 
;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

#+RESULTS:
| UTF8_STRING | COMPOUND_TEXT | TEXT | STRING |


* Packages
@DON'T CHANGE ORDER SINCE SOME PACKAGES NEED TO ONLY LOAD AFTER OTHERS@

** hippie expand

$note its built into emacs no intsall needed$

#+BEGIN_SRC emacs-lisp :results none
  ;;  (setq dcsh-command-list '("all_registers"
  ;;                                "check_design" "check_test" "compile" "current_design"
  ;;                                "link" "uniquify"
  ;;                                "report_timing" "report_clocks" "report_constraint"
  ;;                                "get_unix_variable" "set_unix_variable"
  ;;                                "set_max_fanout"
  ;;                                "report_area" "all_clocks" "all_inputs" "all_outputs"))
  
  ;;      (defun he-dcsh-command-beg ()
  ;;        (let ((p))
  ;;          (save-excursion
  ;;            (backward-word 1)
  ;;            (setq p (point)))
  ;;          p))
  
  ;;      (defun try-expand-dcsh-command (old)
  ;;        (unless old
  ;;          (he-init-string (he-dcsh-command-beg) (point))
  ;;          (setq he-expand-list (sort
  ;;                                (all-completions he-search-string (mapcar 'list dcsh-command-list))
  ;;                                'string-lessp)))
  ;;        (while (and he-expand-list
  ;;                (he-string-member (car he-expand-list) he-tried-table))
  ;;          (setq he-expand-list (cdr he-expand-list)))
  ;;        (if (null he-expand-list)
  ;;            (progn
  ;;              (when old (he-reset-string))
  ;;              ())
  ;;          (he-substitute-string (car he-expand-list))
  ;;          (setq he-tried-table (cons (car he-expand-list) (cdr he-tried-table)))
  ;;          (setq he-expand-list (cdr he-expand-list))
  ;;          t))

  ;;  (setq hippie-expand-try-functions-list (cons 'yas/hippie-try-expand hippie-expand-try-functions-list))

  ;;  (defun my-hippie-expand-completions (&optional hippie-expand-function)
  ;;        "Return the full list of possible completions generated by `hippie-expand'.
  ;;      The optional argument can be generated with `make-hippie-expand-function'."
  ;;        (let ((this-command 'my-hippie-expand-completions)
  ;;              (last-command last-command)
  ;;              (buffer-modified (buffer-modified-p))
  ;;              (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
  ;;          (flet ((ding)) ; avoid the (ding) when hippie-expand exhausts its options.
  ;;            (while (progn
  ;;                     (funcall hippie-expand-function nil)
  ;;                     (setq last-command 'my-hippie-expand-completions)
  ;;                     (not (equal he-num -1)))))
  ;;          ;; Evaluating the completions modifies the buffer, however we will finish
  ;;          ;; up in the same state that we began, and (save-current-buffer) seems a
  ;;          ;; bit heavyweight in the circumstances.
  ;;          (set-buffer-modified-p buffer-modified)
  ;;          ;; Provide the options in the order in which they are normally generated.
  ;;          (delete he-search-string (reverse he-tried-table))))
   
  ;;      (defmacro my-ido-hippie-expand-with (hippie-expand-function)
  ;;        "Generate an interactively-callable function that offers ido-based completion
  ;;      using the specified hippie-expand function."
  ;;        `(call-interactively
  ;;          (lambda (&optional selection)
  ;;            (interactive
  ;;             (let ((options (my-hippie-expand-completions ,hippie-expand-function)))
  ;;               (if options
  ;;                   (list (ido-completing-read "Completions: " options)))))
  ;;            (if selection
  ;;                (he-substitute-string selection t)
  ;;              (message "No expansion found")))))
   
  ;;      (defun my-ido-hippie-expand ()
  ;;        "Offer ido-based completion for the word at point."
  ;;        (interactive)
  ;;        (my-ido-hippie-expand-with 'hippie-expand))
   
  ;; ;; (global-set-key (kbd "<f12>") 'my-ido-hippie-expand)
  ;; ;; (global-set-key [(meta f5)] (make-hippie-expand-function
  ;; ;;                                '(try-expand-dcsh-command
  ;; ;;                                  try-expand-dabbrev-visible
  ;; ;;                                  try-expand-dabbrev
  ;; ;;                                  try-expand-dabbrev-all-buffers) t))
  ;; (global-set-key (kbd "M-/") 'hippie-expand)
  ;; ;; (global-set-key (kbd "TAB") 'hippie-expand)

#+END_SRC
  
** ido

$note its built into emacs no intsall needed$

'flx-ido'- install it before ido through MELPA

#+BEGIN_SRC emacs-lisp :results none
  ;; (ido-mode 1)
  ;; (require 'flx-ido)
  ;; (ido-everywhere 1)
  ;; (flx-ido-mode 1)
  ;; ;; disable ido faces to see flx highlights.
  ;; (setq ido-use-faces nil)
  
  
  ;; (setq ido-max-directory-size 100000)
  ;; (ido-mode (quote both))
  ;; ; Use the current window when visiting files and buffers with ido
  ;; (setq ido-default-file-method 'selected-window)
  ;; (setq ido-default-buffer-method 'selected-window)
  
  
  
  ;; ;ignore case
  ;; (setq ido-case-fold t)
  ;; (setq ido-enable-flex-matching t) ; fuzzy matching is a must have
  
  ;; ;ido-ubiquitous
  
  ;; ;recents ido
  ;; (defun recentf-ido-find-file ()
  ;;   "Find a recent file using ido."
  ;;   (interactive)
  ;;   (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
  ;;     (when file
  ;;      (find-file file))))
  
  
  ;; ;this keybinding lets you even more quickly reach your home folder when in ido-find-file.
  
  ;; (add-hook 'ido-setup-hook
  ;;  (lambda ()
  ;;    ;; Go straight home
  ;;    (define-key ido-file-completion-map
  ;;      (kbd "~")
  ;;      (lambda ()
  ;;        (interactive)
  ;;        (if (looking-back "/")
  ;;            (insert "~/")
  ;;          (call-interactively 'self-insert-command))))))
#+END_SRC

** Ace window
   :PROPERTIES:
   :ID:       1429ffca-3d2e-4abc-8c26-851b62c3bd37
   :END:
https://github.com/abo-abo/ace-window
sets to only use homekeys 
#+BEGIN_SRC emacs-lisp :results none
(use-package ace-window
    :config
;set keys to only these 
;;    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
;;    (setq aw-keys '(?1 ?2 ?3 ?4 ?5 ))
;; set to work in frames not global! so that if only 2 windows in frames frame it would switch between them 
(setq aw-scope 'frame)
;; set to true if you want to darken the background during switch
(setq aw-background nil)
;; When non-nil, ace-window will issue a read-char even for one window- you want it nil!
(setq aw-dispatch-always nil)


)
#+END_SRC
arch
https://github.com/tam17aki/ace-isearch
*** start ace-isearch
#+BEGIN_SRC emacs-lisp :results none
;  (use-package ace-isearch
;  :ensure t
;  :config
;  (ace-isearch-mode +1)
;  (global-ace-isearch-mode +1)
; (setq ace-isearch-function 'avy-goto-word-1)
;  )
#+END_SRC
*** customize 
#+BEGIN_SRC emacs-lisp :results none
  ;;   (custom-set-variables
  ;;   '(ace-isearch-input-length 9)
  ;;   '(ace-isearch-input-idle-delay 0.4)
  ;;   '(ace-isearch-submode 'ace-jump-char-mode)
  ;;   '(ace-isearch-use-ace-jump 'printing-char)
  ;; )
#+END_SRC

** ace link
https://github.com/abo-abo/ace-link

#+BEGIN_SRC emacs-lisp :results none
(use-package ace-link
 :ensure t
 :config
(ace-link-setup-default)
 )
#+END_SRC 

** anzu
https://github.com/syohex/emacs-anzu

#+BEGIN_SRC emacs-lisp :results none
(use-package anzu
 :ensure t
 :config
(require 'anzu)
(global-anzu-mode +1)

(set-face-attribute 'anzu-mode-line nil
                    :foreground "yellow" :weight 'bold)

(custom-set-variables
 '(anzu-mode-lighter "")
 '(anzu-deactivate-region t)
 '(anzu-search-threshold 1000)
 '(anzu-replace-to-string-separator " => "))
 
(global-set-key (kbd "M-%") 'anzu-query-replace)
(global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp)

 )
#+END_SRC 

** async
 $Note this is needed for org-download$
 #+BEGIN_SRC emacs-lisp :results none
(use-package async
:ensure t)
 #+END_SRC 

** auctex
#+BEGIN_SRC emacs-lisp :results none
;(require 'tex)
;(setq preview-scale-function 1.1)
#+END_SRC
** auto-complete

#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package auto-complete
  ;;  :ensure t
  ;;  :config
  ;; (ac-config-default)

  ;; ;start after 4 characters
  ;; (setq ac-auto-start 4)
  ;; ;fix linium issues
  ;; (ac-linum-workaround)

  ;; ;; Examples
  ;; (set-face-background 'ac-candidate-face "lightgray")
  ;; (set-face-underline 'ac-candidate-face "darkgray")
  ;; (set-face-background 'ac-selection-face "steelblue")

  ;; )
#+END_SRC

** Avy Jump
https://github.com/abo-abo/avy

#+BEGIN_SRC emacs-lisp :results none
(use-package avy
 :ensure t
 :config
 (defcustom avy-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?q ?w ?e ?r ?t ?y ?u ?i ?o ?p ?z ?x ?c ?v ?b ?n ?m )
 "Keys for jumping.") 
(setq avy-timeout-seconds 0.6)
 )
#+END_SRC 


** avy zap
   :PROPERTIES:
   :LAST-EDITED: [03-08-2015(19:57)]
   :END:
https://github.com/cute-jumper/avy-zap
#+BEGIN_SRC emacs-lisp :results none
(use-package avy-zap
 :ensure t
 :config
  )
#+END_SRC 

** BBDB
#+BEGIN_SRC emacs-lisp :results none
(use-package bbdb
 :ensure t
 :config
(setq bbdb-file "~/.emacs.d/bbdb")           ;; keep ~/ clean; set before loading
(require 'bbdb) 
(bbdb-initialize)

 )
#+END_SRC 
** bbdb-csv-import
https://gitlab.com/iankelling/bbdb-csv-import/
#+BEGIN_SRC emacs-lisp :results none
(use-package bbdb-csv-import
 :ensure t
 :config
  )
#+END_SRC
** TODO bind map
https://github.com/justbur/emacs-bind-map/tree/e3fa3cc383bd7d331caa89bc914a2a296abb98f1
#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package bind-map
  ;;  :ensure t
  ;;  :config

  ;; (bind-map z/base-leader-map
  ;;   :keys ("\\")
  ;; )

  ;; (bind-map-set-keys z/base-leader-map
  ;;   "c" 'z/org-export-revel-browse
  ;;   ;; ...
  ;;   )

  ;;  )
#+END_SRC

allows for an arbitrary number of “leader keys”. This is probably best explained with an example.

(bind-map my-base-leader-map
  :keys ("M-m")
  :evil-keys ("SPC")
  :evil-states (normal motion visual))
(bind-map my-elisp-map
  :keys ("M-m m" "M-RET")
  :evil-keys ("SPC m" ",")
  :major-modes (emacs-lisp-mode
                lisp-interaction-mode))

** beacon mode 

https://github.com/Malabarba/beacon

#+BEGIN_SRC emacs-lisp :results none
(use-package beacon
 :ensure t
 :config
(beacon-mode 1)
(setq beacon-push-mark 35)
(setq beacon-color "#21D6F4")
 )
#+END_SRC 


** Bookmark+
#+BEGIN_SRC emacs-lisp :results none
(use-package bookmark+
:ensure t
:config
(setq bookmark-version-control t
      bookmark-save-flag t)
;ask for tags when saving a bookmark move nil to t to ask each time
(setq bmkp-prompt-for-tags-flag nil)
)

#+END_SRC

** Browse kill ring
#+BEGIN_SRC emacs-lisp :results none
(use-package browse-kill-ring
:ensure t
:config
)
#+END_SRC 

** bug hunter
https://github.com/Malabarba/elisp-bug-hunter

#+BEGIN_SRC emacs-lisp :results none
(use-package bug-hunter
 :ensure t
 :config
  )
#+END_SRC

** Counsel
#+BEGIN_SRC emacs-lisp :results none
(use-package counsel
 :ensure t
 :config
  )
#+END_SRC 
 
** color-theme-approximate
 If it doesn't work try to put the line lower in the .emacs file (it happened to me). If everything still look like shit check that you have the correct XTERM environment variable set 
$Note- is different inside screen or tmux$

#+BEGIN_SRC emacs-lisp :results none
(use-package color-theme-approximate
 :ensure t
 :config
(color-theme-approximate-on)
 )
#+END_SRC 

** company
#+BEGIN_SRC emacs-lisp :results none
  (use-package company
   :ensure t
   :config
  ;;(add-hook 'after-init-hook 'global-company-mode)

  ;; companymode
  (require 'company)

; Company-mode backends
(eval-after-load "company"
  '(progn
     (add-to-list 'company-backends 'company-dabbrev)
     (add-to-list 'company-backends 'company-ispell)
     (add-to-list 'company-backends 'company-abbrev)
     (add-to-list 'company-backends 'company-files)
;; yasnippet backend shadows other completions, see https://github.com/company-mode/company-mode/blob/master/company-yasnippet.el for solutions
;;better to leave disabled and use the ido mode for yasnippets
;;     (add-to-list 'company-backends 'company-yasnippet)
;; using the delete command disables specific modes 
    (setq company-backends (delete 'company-capf company-backends))
    (setq company-backends (delete 'company-ropemacs company-backends))
    (setq company-backends (delete 'company-clang company-backends))
    (setq company-backends (delete 'company-cmake company-backends))
    (setq company-backends (delete 'company-css company-backends))
    (setq company-backends (delete 'company-eclim company-backends))
    (setq company-backends (delete 'company-elisp company-backends))
    (setq company-backends (delete 'company-etags company-backends))
    (setq company-backends (delete 'company-gtags company-backends))
    (setq company-backends (delete 'company-keywords company-backends))
    (setq company-backends (delete 'company-nxml company-backends))
    (setq company-backends (delete 'company-oddmuse company-backends))
    (setq company-backends (delete 'company-semantic company-backends))
    (setq company-backends (delete 'company-template company-backends))
    (setq company-backends (delete 'company-tempo company-backends))
    (setq company-backends (delete 'company-tests company-backends))
    (setq company-backends (delete 'company-xcode company-backends))
    (setq company-backends (delete 'company-tempo company-backends))
    (setq company-backends (delete 'company-yasnippet company-backends))
;; capf is for all modes and all languges so its better to turn it off to not pollute completions.
;;     (add-to-list 'company-backends 'company-capf)
     ))

;;make it global

(add-hook 'after-init-hook 'global-company-mode)


;; company delay until suggestions are shown
(setq company-idle-delay 0.1)


;; whats the minimum to start completion 
(setq company-minimum-prefix-length 2)

(setq company-dabbrev-minimum-length 2)

;; weight by frequency
(setq company-transformers '(company-sort-by-occurrence))

;;dabbrev options 
(setq company-dabbrev-downcase nil)
(setq  company-dabbrev-ignore-case nil)
(setq company-dabbrev-other-buffers t)
  
;; show numbers in popup?
(setq company-show-numbers t)

(setq company-require-match nil)
;; company dabbrev config
;; search all buffers 
(setq company-dabbrev-other-buffers t)

;; org-mode completions
(defun my-pcomplete-capf ()
  (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
(add-hook 'org-mode-hook #'my-pcomplete-capf)

;;;keybinds
(global-set-key (kbd "M-.") 'company-complete)
(global-set-key (kbd "M-/") 'company-dabbrev)

   )
#+END_SRC 


** company-org-headings
#+BEGIN_SRC emacs-lisp :results none
  ;; (add-to-list 'load-path "/home/zeltak/.emacs.g/company-org-headings")
  ;; (setq
  ;;  ;; align all annotations to the right tooltip border
  ;;  company-tooltip-align-annotations t
  ;;  company-org-headings/search-directory "~/notes"
  ;;  company-org-headings/case-sensitive nil)

  ;; ;; (add-hook 'org-mode-hook
  ;; ;;           (lambda ()
  ;; ;;             (set (make-local-variable 'company-backends)
  ;; ;;                  '((company-org-headings
  ;; ;;                     company-abbrev
  ;; ;;                     company-files
  ;; ;;                     )))))
#+END_SRC


** dired plugins
*** dired-x
http://www.gnu.org/software/emacs/manual/html_node/dired-x/Shell-Command-Guessing.html

$Note-no need to install its a internal dired package$ 
#+BEGIN_SRC emacs-lisp :results none
(require 'dired-x)
(setq dired-guess-shell-alist-user
      '(("\\.e?ps$" "gv" "xloadimage" "lpr")
        ("\\.chm$" "xchm")
        ("\\.rar$" "unrar x")
        ("\\.ods\\'\\|\\.xlsx?\\'\\|\\.docx?\\'\\|\\.csv\\'" "libreoffice")
        ("\\.e?ps\\.g?z$" "gunzip -qc * | gv -")
        ("\\.pdf$" "okular" "zathura")
        ("\\.flv$" "mplayer")
        ("\\.mov$" "mplayer")
        ("\\.3gp$" "mplayer")
        ("\\.png$" "feh")
        ("\\.jpg$" "feh")
        ("\\.JPG$" "feh")
        ("\\.avi$" "mplayer")))
#+END_SRC 

*** dired sort
#+BEGIN_SRC emacs-lisp :results none
(use-package dired-sort
 :ensure t
 :config
  )
#+END_SRC 
*** dired+
#+BEGIN_SRC emacs-lisp :results none
(use-package dired+
 :ensure t
 :config
(toggle-diredp-find-file-reuse-dir 1)
  )
#+END_SRC 
*** dired-details
#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package dired-details
  ;;  :ensure t
  ;;  :config
  ;; (setq dired-details-hide-link-targets nil)
  ;;  )
#+END_SRC 
*** dired-details+

#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package dired-details+
  ;;  :ensure t
  ;;  :config
  ;;  )
#+END_SRC 

*** peep dired

#+BEGIN_SRC emacs-lisp :results none
(use-package peep-dired
 :ensure t
 :config
 (setq peep-dired-ignored-extensions '("mkv" "iso" "mp4"))
 )
#+END_SRC 


*** dired-avfs
#+BEGIN_SRC emacs-lisp :results none
(use-package dired-avfs
 :ensure t
 :config
 )
#+END_SRC 

*** dired-filter
https://github.com/Fuco1/dired-hacks
#+BEGIN_SRC emacs-lisp :results none
(use-package dired-filter
 :ensure t
 :config
 )
#+END_SRC 
*** dired-narrow
https://github.com/Fuco1/dired-hacks
#+BEGIN_SRC emacs-lisp :results none
(use-package dired-narrow
 :ensure t
 :config
 )
#+END_SRC 

*** dired-efap (rename file at point)

#+BEGIN_SRC emacs-lisp :results none
(use-package dired-efap
 :ensure t
 :config
 
 )
#+END_SRC 

*** dired-rainbow

#+BEGIN_SRC emacs-lisp :results none
(use-package dired-rainbow
 :ensure t
 :config
 (require 'dired-rainbow)

(defconst dired-audio-files-extensions
  '("mp3" "MP3" "ogg" "OGG" "flac" "FLAC" "wav" "WAV")
  "Dired Audio files extensions")
(dired-rainbow-define audio "#329EE8" dired-audio-files-extensions)

(defconst dired-video-files-extensions
    '("vob" "VOB" "mkv" "MKV" "mpe" "mpg" "MPG" "mp4" "MP4" "ts" "TS" "m2ts"
      "M2TS" "avi" "AVI" "mov" "MOV" "wmv" "asf" "m2v" "m4v" "mpeg" "MPEG" "tp")
    "Dired Video files extensions")
(dired-rainbow-define video "#006EFF" dired-video-files-extensions)

(defconst dired-pdf-files-extensions
  '("pdf" "PDF")
  "Dired pdf files extensions")
(dired-rainbow-define pdf "#FF0000" dired-pdf-files-extensions)


(defconst dired-org-files-extensions
  '("org" "ORG")
  "Dired org files extensions")
(dired-rainbow-define org "#FF00A2" dired-org-files-extensions)


(defconst dired-compressed-files-extensions
  '("zip" "ZIP"  "tar.bz" "tar.gz" "7zip" "7ZIP" "tar" "TAR" "rar" "RAR")
  "Dired compressed files extensions")
(dired-rainbow-define compressed "#B56A00" dired-compressed-files-extensions)




 )
#+END_SRC 
*** diredful
https://github.com/thamer/diredful
#+BEGIN_SRC emacs-lisp :results none
(use-package diredful
 :ensure t
 :config
 (diredful-mode 1)
 )
#+END_SRC 


*** dired tmtxt-async-tasks and 
#+BEGIN_SRC emacs-lisp :results none
 (add-to-list 'load-path "/home/zeltak/.emacs.g/tmtxt-async-tasks")
 (add-to-list 'load-path "/home/zeltak/.emacs.g/tmtxt-dired-async")
(require 'tmtxt-async-tasks)
(require 'tmtxt-dired-async)

(setq-default tat/window-close-delay "2")
(setq-default tat/window-height 15)
#+END_SRC
** drag stuff
https://github.com/rejeep/drag-stuff.el

allows to drag text around via keyboard 

#+BEGIN_SRC emacs-lisp :results none
(use-package drag-stuff
 :ensure t
 :config
  )
#+END_SRC
** duplicate
https://github.com/ongaeshi/duplicate-thing
#+BEGIN_SRC emacs-lisp :results none
(use-package  duplicate-thing 
 :ensure t
 :config
 )
#+END_SRC 

** ebib

#+BEGIN_SRC emacs-lisp :results none
(use-package ebib
 :ensure t
 :config
(setq ebib-preload-bib-files '("/home/zeltak/org/files/Uni/papers/kloog.2015.bib")) 

(setq ebib-common-optional-fields
      '(translator keywords origlanguage url file location
        partinfo subtitle edition abstract note annotator
        crossref urldate address subtitle language))

(setq ebib-file-associations '(("pdf" . "okular") ("djvu" . "okular")))
(setq ebib-uniquify-keys t)
(setq ebib-autogenerate-keys t)
(setq ebib-index-window-size 20)
(setq ebib-print-multiline t)

;index view
(setq ebib-index-display-fields (quote (year author)))
(setq ebib-sort-order (quote ((year) (author) )))

 )
#+END_SRC
** easy-kill
https://github.com/leoliu/easy-kill

#+BEGIN_SRC emacs-lisp :results none
(use-package easy-kill
   :ensure t
   :config
;; to replace Emacs native M-w
(global-set-key [remap kill-ring-save] 'easy-kill)
(global-set-key (kbd "M-3") 'easy-mark)
   )
#+END_SRC 
** edit-server (for chrome interaction)
 #+BEGIN_SRC emacs-lisp :results none
   ;; (require 'edit-server)
   ;;  (edit-server-start)
   ;; (autoload 'edit-server-maybe-dehtmlize-buffer "edit-server-htmlize" "edit-server-htmlize" t)
   ;; (autoload 'edit-server-maybe-htmlize-buffer   "edit-server-htmlize" "edit-server-htmlize" t)
   ;; (add-hook 'edit-server-start-hook 'edit-server-maybe-dehtmlize-buffer)
   ;; (add-hook 'edit-server-done-hook  'edit-server-maybe-htmlize-buffer)
 #+END_SRC
** engine-mode
   
#+BEGIN_SRC emacs-lisp :results none
(use-package engine-mode
 :ensure t
 :config 
 )
#+END_SRC

** EVIL

#+BEGIN_SRC emacs-lisp :results none
(use-package evil
:ensure t
:config
)
#+END_SRC

 #+begin_src emacs-lisp results none
   ;; (require 'evil)
   ;; (evil-mode 1)

   ;; ;for normal undo
   ;; (setq evil-want-fine-undo t)

   ;; ;;; esc quits
   ;; (define-key evil-normal-state-map [escape] 'keyboard-quit)
   ;; (define-key evil-visual-state-map [escape] 'keyboard-quit)
   ;; (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
   ;; (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
   ;; (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
   ;; (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
   ;; (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)

   ;; ;searches
   ;; (global-set-key (kbd "C-*") 'evil-search-symbol-forward)
   ;; (global-set-key (kbd "C-#") 'evil-search-symbol-backward)



 #+end_src

** EVIL NERD Commenter
https://github.com/redguardtoo/evil-nerd-commenter

 #+BEGIN_SRC emacs-lisp :results none
(use-package evil-nerd-commenter
:ensure t
:config
)
;(evilnc-default-hotkeys)
;(setq evilnc-hotkey-comment-operator ",,")
 #+END_SRC


** expand region
https://github.com/magnars/expand-region.el

#+BEGIN_SRC emacs-lisp :results none
(use-package expand-region
 :ensure t
 :config
 :bind (
       ("M-2" . er/expand-region )
 )
)

#+END_SRC
** find-file-in-project
https://github.com/technomancy/find-file-in-project

#+BEGIN_SRC emacs-lisp :results none
(use-package find-file-in-project
 :ensure t
 :config

 )
#+END_SRC 

** Fill colum mode
#+BEGIN_SRC emacs-lisp :results none
(use-package fill-column-indicator
:ensure t
:config
)
#+END_SRC

** Gnus related
*** gnus-desktop-notify
http://www.thregr.org/~wavexx/software/gnus-desktop-notify.el/

#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package gnus-desktop-notify
  ;;  :ensure t
  ;;  :config
  ;;  (require 'gnus-desktop-notify)
  ;; (gnus-desktop-notify-mode)
  ;; (gnus-demon-add-scanmail)

  ;;  )
#+END_SRC 



** google contacts

#+BEGIN_SRC emacs-lisp :results none
(use-package google-contacts
:ensure t
:config
)
#+END_SRC
** goto-chg

#+BEGIN_SRC emacs-lisp :results none
(use-package goto-chg
 :ensure t
 :config
 (require 'goto-chg)
 )
#+END_SRC 


** gmail 2 bbdb
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "~/.emacs.g/gmail2bbdb/")
(autoload 'gmail2bbdb-import-file "gmail2bbdb")
#+END_SRC
** gnorb

ht/tps://github.com/girzel/gnorb

examples:

- Whang attachments from Gnus messages onto Org headings, using org-attach.
- Automate the above as part of the org capture process
- Email contents of org subtree under point (prompt for export routine)
- Single-keystroke Org links or email citations of BBDB contacts
- Initiate search of emails from contacts in open BBDB buffer
- Initiate Org agenda tag search from BBDB buffer
- Inverse of the above: pop up a BBDB buffer alongside an Org tags search
- Treat headings as email-related TODOs, and handle them DWIM-style

  #+BEGIN_SRC emacs-lisp :results none
  (use-package gnorb
   :ensure t
   :config
      )
  #+END_SRC 
  
  
** grizzl
for projectile fuzzy match
#+BEGIN_SRC emacs-lisp :results none
(use-package grizzl
 :ensure t
 :config
  )
#+END_SRC 

** Helm
*** load Helm
#+BEGIN_SRC emacs-lisp :results none
(use-package helm
:ensure t
:config
(require 'helm-config)
(helm-mode 1)
;(global-set-key (kbd "M-x") 'helm-M-x)
(setq helm-M-x-fuzzy-match t) ;; optional fuzzy matching for helm-M-x
)
#+END_SRC
*** Helm configuration 
**** Helm viewing options config 

 #+BEGIN_SRC emacs-lisp :results none
(setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
       helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
      helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
       helm-ff-file-name-history-use-recentf t
)
 #+END_SRC
**** helm mini
 enable fuzzy matching:
 #+BEGIN_SRC emacs-lisp :results none
 (setq helm-buffers-fuzzy-matching t
       helm-recentf-fuzzy-match    t)
 #+END_SRC
**** search org folders
 #+BEGIN_SRC emacs-lisp :results none
 (use-package helm-cmd-t
 :ensure t
 :config
 (defvar my-org-folders (list  "~/org/files/")
   "my permanent folders for helm-mini")

 (defun helm-my-org (&optional arg)
   "Use C-u arg to work with repos."
   (interactive "P")
   (if (consp arg)
       (call-interactively 'helm-cmd-t-repos)
     (let ((helm-ff-transformer-show-only-basename nil))
       (helm :sources (mapcar (lambda (dir)
				(helm-cmd-t-get-create-source-dir dir))
                              my-org-folders)
             :candidate-number-limit 20
             :buffer "*helm-my-org:*"
             :input "org$ "))))
 )
 #+END_SRC

**** google suggest 
 #+BEGIN_SRC emacs-lisp :results none
 (when (executable-find "curl")
   (setq helm-google-suggest-use-curl-p t))
 #+END_SRC

**** helm man-woman (man doc reader)
 enable at point
 #+BEGIN_SRC emacs-lisp :results none
 (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
 #+END_SRC
**** helm locate
 enable fuzzy 
 #+BEGIN_SRC emacs-lisp :results none
 (setq helm-locate-fuzzy-match t)	    
 #+END_SRC
**** helm occur
no config needed 
** helm bibtex
https://github.com/tmalsburg/helm-bibtex

*** settings

#+BEGIN_SRC emacs-lisp :results none
(use-package helm-bibtex
 :ensure t
 :config

(autoload 'helm-bibtex "helm-bibtex" "" t)

(setq helm-bibtex-bibliography "/home/zeltak/org/files/Uni/papers/kloog.2015.bib")
;(setq helm-bibtex-notes-path "/home/zeltak/org/files/Uni/papers/notes/")
(setq helm-bibtex-library-path (list "/home/zeltak/Sync/Uni/pdf_lib/" "/home/zeltak/Sync/Uni/pdf_lib_gen/") ) 
(setq helm-bibtex-notes-extension ".org")

(setq helm-bibtex-format-citation-functions
  '((org-mode      . helm-bibtex-format-citation-org-link-to-PDF)
    (latex-mode    . helm-bibtex-format-citation-cite)
    (markdown-mode . helm-bibtex-format-citation-pandoc-citeproc)
    (default       . helm-bibtex-format-citation-default)))

;(setq helm-bibtex-additional-search-fields '(tags))
(setq helm-bibtex-additional-search-fields '(tags))



(setq helm-bibtex-browser-function
  (lambda (url _) (start-process "chromium" "*chromium*" "chromium" url)))

;(setq helm-bibtex-pdf-open-function
; (lambda (fpath)
 ;  (start-process "evince" "*helm-bibtex-evince*" "/usr/bin/evince" fpath)))
 )
#+END_SRC 

*** my papers 

#+BEGIN_SRC emacs-lisp :results none

 ;; Define helm-search with predefined search expression:
 (defun helm-bibtex-ikloog-publications ()
   "Search BibTeX entries authored by me"
   (interactive)
   (helm :sources '(helm-source-bibtex)
         :full-frame t
         :input "kloog !unpublished !prep "
         :candidate-number-limit 500))

 ;; Bind this search function to Ctrl-x p:
 ;(global-set-key (kbd "C-x p") 'helm-bibtex-my-publications)
#+END_SRC

*** my papers (all)
#+BEGIN_SRC emacs-lisp :results none

 ;; Define helm-search with predefined search expression:
 (defun helm-bibtex-ikloog-publications-all ()
   "Search BibTeX entries authored by me (ALL including prep)"
   (interactive)
   (helm :sources '(helm-source-bibtex)
         :full-frame t
         :input "kloog !unpublished"
         :candidate-number-limit 500))

 ;; Bind this search function to Ctrl-x p:
 ;(global-set-key (kbd "C-x p") 'helm-bibtex-my-publications)
#+END_SRC

*** my prepared maunscripts
#+BEGIN_SRC emacs-lisp :results none

 ;; Define helm-search with predefined search expression:
 (defun helm-bibtex-ikloog-prep         ()
   "Search BibTeX entries in preperation with me"
   (interactive)
   (helm :sources '(helm-source-bibtex)
         :full-frame t
         :input "kloog prep !unpublished"
         :candidate-number-limit 500))

 #+END_SRC
** mu4e-alert							
https://github.com/iqbalansari/mu4e-alert
#+BEGIN_SRC emacs-lisp :results none
(use-package mu4e-alert
 :ensure t
 :config
;; Choose the style you prefer for desktop notifications
(mu4e-alert-set-default-style 'libnotify)
(add-hook 'after-init-hook #'mu4e-alert-enable-notifications) 
(add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
;;below will color the fringe (left side of an Emacs window)..worked but couldn't see how to disable it
;;;(alert-add-rule :category "mu4e-alert" :style 'fringe :predicate (lambda (_) (string-match-p "^mu4e-" (symbol-name major-mode))) :continue t)
(mu4e-alert-enable-notifications)

 )
#+END_SRC 

*** to restore the fringe to to a bug
#+BEGIN_SRC emacs-lisp :results none
(defun alert-fringe-restore (info)
  (copy-face 'alert-saved-fringe-face 'fringe))
#+END_SRC

** helm mu
https://github.com/emacs-helm/helm-mu

When you would like to read an email without finishing the helm session, you can select the email and press ~Ctrl-z~
To search for contacts use `helm-mu-contacts`

#+BEGIN_SRC emacs-lisp :results none
(use-package helm-mu
 :ensure t
 :config
  )
#+END_SRC
** helm-fuzzier
https://github.com/EphramPerdition/helm-fuzzier

better fuzzy matching for helm

#+BEGIN_SRC emacs-lisp :results none
(use-package helm-fuzzier
 :ensure t
 :config
 (require 'helm-fuzzier)
  (helm-fuzzier-mode 1)
 )
#+END_SRC 

helm-fuzzier will only enhance matching for sources that have fuzzy-matching enabled, so be sure to enable fuzzy-matching for the sources you're interested in by setting the appropriate variable (helm-M-x-fuzzy-match, helm-mode-fuzzy-match, helm-apropos-fuzzy-match, etc').

** helm-grepint
https://github.com/kopoli/helm-grepint

#+BEGIN_SRC emacs-lisp :results none
(use-package helm-grepint
 :ensure t
 :config
     (require 'helm-grepint)
    (helm-grepint-set-default-config)
    (global-set-key (kbd "C-c g") #'helm-grepint-grep)
    (global-set-key (kbd "C-c G") #'helm-grepint-grep-root)
 )
#+END_SRC 
Key bindings within helm:

RET selects an item and closes the helm session.
Right arrow selects the item, but does not close the helm session. This is similar as helm-occur.
** helm-swoop
https://github.com/ShingoFukuyama/helm-swoop

#+BEGIN_SRC emacs-lisp :results none
(use-package helm-swoop
 :ensure t
 :config
;; Move up and down like isearch
(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
(define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
(define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

;; From helm-swoop to helm-multi-swoop-all
(define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

;; Save buffer when helm-multi-swoop-edit complete
(setq helm-multi-swoop-edit-save t)

;; If nil, you can slightly boost invoke speed in exchange for text color
(setq helm-swoop-speed-or-color nil)


 )
#+END_SRC 
helm-multi-swoop

Select any buffers by [C-SPC] or [M-SPC]
Press [RET] to start helm-multi-swoop

Edit mode

While doing helm-swoop type C-c C-e to enter the edit mode. Before enter the edit mode, you can choose some lines marked by C-SPC or M-SPC to edit. Apply changes to original buffer type C-x C-s.

** helm-projectile

#+BEGIN_SRC emacs-lisp :results none
(use-package helm-projectile
 :ensure t
 :config
 
 )
#+END_SRC 


** Highlight symbol
https://github.com/nschum/highlight-symbol.el
highlight word at point and move forward next to other words
#+BEGIN_SRC emacs-lisp :results none
(use-package highlight-symbol
 :ensure t
 :config
 )
#+END_SRC 
** ivy (completion package by abo-abo)
http://oremacs.com/2015/04/16/ivy-mode/
*** enable fuzzy matching by default
#+BEGIN_SRC emacs-lisp :results none
(setq ivy-re-builders-alist
      '((t . ivy--regex-fuzzy)))
#+END_SRC
*** Enable fancy mode
#+BEGIN_SRC emacs-lisp :results none
(setq ivy-display-style 'fancy)

(custom-set-faces
 '(swiper-minibuffer-match-face-1
   ((t :background "#dddddd")))
 '(swiper-minibuffer-match-face-2
   ((t :background "#bbbbbb" :weight bold)))
 '(swiper-minibuffer-match-face-3
   ((t :background "#bbbbff" :weight bold)))
 '(swiper-minibuffer-match-face-4
   ((t :background "#ffbbff" :weight bold))))
#+END_SRC
*** show more verbose matching 
#+BEGIN_SRC emacs-lisp :results none
(setq ivy-count-format "(%d/%d) ")
#+END_SRC
The key bindings are:

RET will select the current candidate and finish.
C-j will try to continue the completion, i.e. if the current candidate is a directory, move to that directory. But if the current candidate is a file or ./, then finish.
/ will switch to completing the sub-directories of /, but if the candidate is a perfect match, it will act like C-j.
~ will switch to completing the sub-directories of ~/.
C-n and C-p naturally select the next and the previous candidate.
** org-caldav-sync

#+BEGIN_SRC emacs-lisp :results none
(use-package  org-caldav
 :ensure t
 :config
 (require 'org-caldav)

(setq org-caldav-url "https://www.google.com/calendar/dav")
(setq org-caldav-calendar-id "ikloog@gmail.com")
(setq org-caldav-inbox (expand-file-name "/home/zeltak/org/files/PIM/org-caldev.org"))
(setq org-caldav-files '("/home/zeltak/org/files/agenda/gcal.org"))
 )
#+END_SRC
** org highlight
#+BEGIN_SRC emacs-lisp :results none
;(require 'highlights)
;; make sure you have dash, helm, helm-bibtex, ebib, s, f, hydra and key-chord
;; in your load-path
;require 'highlights)
#+END_SRC

** hydra
 #+BEGIN_SRC emacs-lisp :results none
(use-package hydra
:ensure t 
:config
(require 'hydra-examples) ;;for window splits etc
)
 #+END_SRC
** indent guide
#+BEGIN_SRC emacs-lisp :results none
(use-package indent-guide
:ensure t
:config
)
#+END_SRC
** ispell
#+BEGIN_SRC emacs-lisp :results none
(setq ispell-personal-dictionary "~/.emacs.d/ispell-dico-personal")
;;below command skipps checking inside org mode code blocks 
(add-to-list 'ispell-skip-region-alist '("#\\+begin_src". "#\\+end_src"))
#+END_SRC
** key-chord
 #+BEGIN_SRC emacs-lisp :results none
(use-package key-chord 
  :ensure t
  :config
(key-chord-mode 1)
(setq key-chord-two-keys-delay 0.16)
(setq key-chord-one-key-delay 0.20)
)
#+END_SRC
** lentic mode
https://github.com/phillord/lentic

#+BEGIN_SRC emacs-lisp :results none
(use-package lentic
 :ensure t
 :config
 )
#+END_SRC
** magit
https://github.com/magit/magit
#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package magit
  ;;  :ensure t
  ;;  :config
  ;;   )
#+END_SRC 

** manage-minor-mode  

https://github.com/ShingoFukuyama/manage-minor-mode

Set minor-modes status for each major-mode in advance

#+BEGIN_SRC emacs-lisp :results none
(setq manage-minor-mode-default
      '((global
         (on   rainbow-mode)
         (off  line-number-mode))
         (emacs-lisp-mode
         (on   rainbow-delimiters-mode eldoc-mode show-paren-mode))
         (js2-mode
         (on   color-identifiers-mode)
         (off  flycheck-mode))))
#+END_SRC

** mic-parens
better parens match than bulit in Emacs one 
#+BEGIN_SRC emacs-lisp :results none
(use-package mic-paren
 :ensure t
 :config
  )
#+END_SRC
** mu4e-maildirs-extension
https://github.com/agpchil/mu4e-maildirs-extension
#+BEGIN_SRC emacs-lisp :results none
;(use-package mu4e-maildirs-extension
; :ensure t
; :config
;(setq mu4e-maildirs-extension-title "Mail")
;(setq mu4e-maildirs-extension-custom-list (quote ("INBOX" "Starred"  )))
; )
#+END_SRC

** multiple-cursors
https://github.com/magnars/multiple-cursors.el

#+BEGIN_SRC emacs-lisp :results none
(use-package multiple-cursors
 :ensure t
 :config
 (require 'multiple-cursors)
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)

 )
#+END_SRC 
When you want to add multiple cursors not based on continuous lines, but based on keywords in the buffer, use:

(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)

First mark the word, then add more cursors.

** open with

this kills sending email from mu4e so for now its off..need to seek alternatives?

#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package openwith 
  ;; :ensure t
  ;; :config
  ;; (require 'openwith)
  ;; (setq openwith-associations '(("\\.pdf\\'" "okular" (file))))
  ;; (setq openwith-associations '(("\\.mkv\\'" "mplayer" (file))))
  ;; (setq openwith-associations '(("\\.html\\'" "chromium" (file))))
  ;; (setq openwith-associations '(("\\.html\\'" "eww" (file))))
  ;; (setq openwith-associations '(("\\.mp4\\'" "vlc" (file))))
  ;; (setq openwith-associations '(("\\.ogm\\'" "vlc" (file))))
  ;; (setq openwith-associations '(("\\.avi\\'" "vlc" (file))))
  ;; (setq openwith-associations '(("\\.mpeg\\'" "vlc" (file))))
  ;; (setq openwith-associations '(("\\.mkv\\'" "vlc" (file))))
  ;; (openwith-mode t)
  ;; )
#+END_SRC
** org ref
*** load 
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/org-ref/")
;; make sure you have dash, helm, helm-bibtex, ebib, s, f, hydra and key-chord
;; in your load-path
(require 'org-ref)
;; optional but very useful libraries in org-ref
(require 'doi-utils)
(require 'jmax-bibtex)
(require 'pubmed)
(require 'arxiv)
(require 'sci-id)
#+END_SRC

*** config 
#+BEGIN_SRC emacs-lisp :results none
;(org-babel-load-file "/home/zeltak/.emacs.g/extra/org-ref/org-ref.org")
(setq reftex-default-bibliography '("/home/zeltak/org/files/Uni/papers/kloog.2015.bib"))

;; see org-ref for use of these variables
(setq org-ref-bibliography-notes "/home/zeltak/org/files/Uni/papers/notes/"
      org-ref-default-bibliography '("/home/zeltak/org/files/Uni/papers/kloog.2015.bib")
      org-ref-pdf-directory "/home/zeltak/Sync/Uni/pdf_lib/")

(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC
** org link edit
https://github.com/kyleam/org-link-edit
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/org-link-edit/")
(require 'org-link-edit)
#+END_SRC

** org-bullets
https://github.com/sabof/org-bullets

#+BEGIN_SRC emacs-lisp :results none
  (use-package org-bullets 
   :ensure t
   :config
(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
(setq  org-bullets-bullet-list '(
    "①"
    "②"
    "③ "
    "④"
    "⑤"
    "⑥"
    "⑦"
    "⑧"
    "⑨"
    "⑩"
    "⑪"
    "⑫"
    "⑬"
    "⑭"
    "⑮"
    ))
 )
#+END_SRC 


** org-Download 						     :ATTACH:
   :PROPERTIES:
   :ID:       54e01618-35eb-45c5-b0b7-6f830faef316
   :Attachments: screenshot_2015-04-05_08:15:22.png
   :END:
provides function to drag images from browser and link address
$Note$ this requires package async to be installed, @async must be loaded before this package@

#+BEGIN_SRC emacs-lisp :results none
  (use-package org-download 
   :ensure t
   :config
   (setq-default org-download-heading-lvl nil)
   (setq-default org-download-image-dir "/home/zeltak/Sync/attach/images_2015")
   ;;; to get rid of the #+DOWNLOADED part
;;(setq org-download-annotate-function (lambda (_) ""))
  )
 #+END_SRC

*** old configs 
#+BEGIN_SRC emacs-lisp :results none
  ;; (setq org-download-method 'attach
  ;;        org-download-screenshot-method "scrot -s %s"
  ;;        org-download-backend (if (executable-find "curl") "curl \"%s\" -o \"%s\"" t)))
#+END_SRC

 #+BEGIN_SRC emacs-lisp :results none
;(if (string= system-name "voices") (setq-default org-download-image-dir "/home/zeltak/org/attach/images_2014/") (setq-default org-download-image-dir "/media/NAS/Uni/org/attach/images_2013/"))                                                           
 #+END_SRC
** org-dp (wrap code blocks functions) 
https://github.com/tj64/org-dp
*** load 
#+BEGIN_SRC emacs-lisp :results none
 (add-to-list 'load-path "/home/zeltak/.emacs.g/extra/org-dp/")
 (require 'org-dp-lib)
 #+END_SRC
*** TODO my wrap functions

#+BEGIN_SRC emacs-lisp :results none
(when (require 'org-dp-lib nil t)

;;;;;;;;;; wrap in elisp
  (defun z/wrap-elisp ()
        (org-dp-wrap-in-block
         nil '(src-block nil nil nil (:language "emacs-lisp" :preserve-indent 1  :parameters ":results none" ))))

;for hydra create interactive new functions
(defun z/hydra-wrap-elisp () (interactive) (beginning-of-line) (z/wrap-elisp))

;;;;;;;;;; wrap in bash
  (defun z/wrap-bash ()
        (org-dp-wrap-in-block
         nil '(src-block nil nil nil (:language "sh" :preserve-indent 1  :parameters ":results none" ))))

;for hydra create interactive new functions
(defun z/hydra-wrap-bash () (interactive) (beginning-of-line) (z/wrap-bash))


;;;;;;;;;; wrap in bash
  (defun z/wrap-example ()
        (org-dp-wrap-in-block
         nil '(src-block nil nil nil (:language "example" :preserve-indent 1  :parameters ":results none" ))))

;for hydra create interactive new functions
(defun z/hydra-wrap-example () (interactive) (beginning-of-line) (z/wrap-example))



;;;;;;;;;; wrap in R
  (defun z/wrap-R ()
        (org-dp-wrap-in-block
         nil '(src-block nil nil nil (:language "R" :preserve-indent 1  :parameters ":results none" ))))

;for hydra create interactive new functions
(defun z/hydra-wrap-R () (interactive) (beginning-of-line) (z/wrap-R))

;;;;;;;;;; wrap in latex
  (defun z/wrap-latex ()
        (org-dp-wrap-in-block
         nil '(src-block nil nil nil (:language "latex" :preserve-indent 1  :parameters ":results none" ))))

;for hydra create interactive new functions
(defun z/hydra-wrap-latex () (interactive) (beginning-of-line) (z/wrap-latex))


;end paren
     )
#+END_SRC
** org-contacts
#+BEGIN_SRC emacs-lisp :results none
(require 'org-contacts)
#+END_SRC
** org-gcal
   :PROPERTIES:
   :ID:       c93bd6d4-28e3-44ca-a492-6a36a1c74ad9
   :END:

see [[id:c93bd6d4-28e3-44ca-a492-6a36a1c74ad9][org-gcal]] for how to set this up again in case you get errors 

#+BEGIN_SRC emacs-lisp :results none
(use-package org-gcal 
 :ensure t
 :config
(require 'org-gcal)
(setq org-gcal-client-id "882257512275-kgh7942bb0pach0aq88n7kru5d351lcv.apps.googleusercontent.com"
      org-gcal-client-secret "J2sBmUIreacPE_LaAO_3CNnR"
      org-gcal-file-alist '(
("ikloog@gmail.com" .  "~/org/files/agenda/gcal.org")

))
;for closing use package
)
#+END_SRC 

** org-vcard
https://github.com/flexibeast/org-vcard

also explore how this relates to org-contacs
#+BEGIN_SRC emacs-lisp :results none
(use-package org-vcard
 :ensure t
 :config
 
 )
#+END_SRC 
** org-pandoc
https://github.com/kawabata/ox-pandoc

#+BEGIN_SRC emacs-lisp :results none
(use-package org-pandoc
 :ensure t
 :config
 )
#+END_SRC
** org-pdfview

#+BEGIN_SRC emacs-lisp :results none
(use-package org-pdfview
 :ensure t
 :config
 
 )
#+END_SRC 


** password-store
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/password-store/")
(require 'password-store)
#+END_SRC
** pandoc-mode
http://joostkremers.github.io/pandoc-mode/
#+BEGIN_SRC emacs-lisp :results none
(use-package pandoc-mode
 :ensure t
 :config
  )
#+END_SRC 

** pdf-tools
https://github.com/politza/pdf-tools

#+BEGIN_SRC emacs-lisp :results none
(use-package pdf-tools
 :ensure t
 :config
(pdf-tools-install)
(eval-after-load 'org '(require 'org-pdfview))
(add-to-list 'org-file-apps '("\\.pdf\\'" . org-pdfview-open))
(add-to-list 'org-file-apps '("\\.pdf::\\([[:digit:]]+\\)\\'" . org-pdfview-open))


  )
#+END_SRC 

** projectile
#+BEGIN_SRC emacs-lisp :results none
  (use-package projectile
   :ensure t
   :config
  (projectile-global-mode)
  (setq projectile-completion-system 'grizzl)
   )
#+END_SRC
** polymode
https://github.com/vspinu/polymode

#+BEGIN_SRC emacs-lisp :results none
(use-package polymode
 :ensure t
 :config
(require 'poly-R) 
(require 'poly-org)
(add-to-list 'auto-mode-alist '("\\.org" . poly-org-mode))
 )
#+END_SRC 
When point is inside a src-block the local mode prevails.
So:
C-c C-n inside an R src block sends the line point is on to the R process.
C-c C-c sends the region (or function or paragraph) to the process when point is in the body. 
To execute `org-ctrl-c-ctrl-c' on the src block with the C-c C-c keying, it is necessary to move point to before or after the body.

** TODO Rainbow mode
http://julien.danjou.info/projects/emacs-packages#rainbow-mode

fix or update since it seems broken and colors are white

#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package rainbow-mode
  ;; :ensure t
  ;; :config
  ;; )

  ;; (dolist (hook '(css-mode-hook
  ;;                 html-mode-hook
  ;;                 js-mode-hook
  ;;                 emacs-lisp-mode-hook
  ;;                 org-mode-hook
  ;;                 text-mode-hook
  ;;                 ))
  ;;   (add-hook hook 'rainbow-mode))
#+END_SRC
** rainbow-delimiters
https://github.com/Fanael/rainbow-delimiters
#+BEGIN_SRC emacs-lisp :results none
(use-package rainbow-delimiters
 :ensure t
 :config
 (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
(require 'rainbow-delimiters)
(set-face-attribute 'rainbow-delimiters-unmatched-face nil
                    :foreground 'unspecified
                    :inherit 'error)
 )
#+END_SRC 
** Ranger
   :PROPERTIES:
   :ID:       326350a8-94ad-4a3c-bf9f-e9cbe6a68528
   :END:
https://github.com/ralesi/ranger/

#+BEGIN_SRC emacs-lisp :results none
(use-package ranger
 :ensure t
 :config
(setq ranger-cleanup-eagerly t)
(setq ranger-show-dotfiles t)
(setq ranger-parent-depth 1)
(setq ranger-ignored-extensions '("mkv" "iso" "mp4"))
(setq ranger-cleanup-on-disable t)
(setq ranger-show-literal t)
(setq ranger-width-preview 0.55)

 )
#+END_SRC 
【we】 to open in external app 

** scratch
Instant scratch buffer for current mode
http://pragmaticemacs.com/emacs/instant-scratch-buffer-for-current-mode/

#+BEGIN_SRC emacs-lisp :results none
(use-package scratch
 :ensure t
 :config
 (autoload 'scratch "scratch" nil t)
 )
#+END_SRC
** shrink-whitespace
#+BEGIN_SRC emacs-lisp :results none
(use-package shrink-whitespace
 :ensure t
 :config
 )
#+END_SRC 
** smex
@needed for counsel ivy completions@
#+BEGIN_SRC emacs-lisp :results none
(use-package smex
:ensure t
:config
)
#+END_SRC
** sunrise-commander
*** main 
http://www.emacswiki.org/emacs/Sunrise_Commander_Tips
#+BEGIN_SRC emacs-lisp :results none
(use-package sunrise-commander
 :ensure t
 :config
;;what to shoe in list view
(setq sr-attributes-display-mask '(nil nil t t t t t))
;start with no attributes in view (if set to nil)
(setq sr-show-file-attributes nil)
;sorting
(setq sr-listing-switches "--time-style=locale --group-directories-first -AlDhgG")


;;disbale F keys
;(setq sr-use-commander-keys nil)


;Here’s how to disable “click to visit file” and “cursor follows mouse”.
(setq sr-cursor-follows-mouse nil)
(setq sr-toggle-attribute 1)
(define-key sr-mode-map [mouse-1]        nil)
(define-key sr-mode-map [mouse-movement] nil)

;;nicer icons in modline
(setq sr-modeline-use-utf8-marks t)
;;where is avfs root
(setq sr-avfs-root "~/.avfs")

 )
#+END_SRC 
*** plugins
**** sunrise-x-popviewer

 #+BEGIN_SRC emacs-lisp :results none
 (use-package sunrise-x-popviewer
  :ensure t
  :config
(require 'sunrise-x-popviewer)
(sr-popviewer-mode 1)
;; to open in next pane and not new window
(setq sr-popviewer-select-viewer-action
         (lambda nil (let ((sr-running nil)) (other-window 1))))
  )
 #+END_SRC 
**** sunrise-x-mirror

#+BEGIN_SRC emacs-lisp :results none
(use-package sunrise-x-mirror
 :ensure t
 :config
 (require 'sunrise-x-mirror)
(setq sr-mirror-unionfs-impl (quote unionfs-fuse))
 )
#+END_SRC 
**** sunrise-x-loop
when yo need to copy of move any big files, just prefix the appropriate command with C-u.

#+BEGIN_SRC emacs-lisp :results none
(use-package sunrise-x-loop
 :ensure t
 :config
(require 'sunrise-x-loop) 
 )
#+END_SRC 

**** sunrise-x-modeline
#+BEGIN_SRC emacs-lisp :results none
  (use-package  sunrise-x-modeline
   :ensure t
   :config
   )
#+END_SRC 

**** sunrise-x-tabs

#+BEGIN_SRC emacs-lisp :results none
(use-package sunrise-x-tabs
 :ensure t
 :config
;(require 'sunrise‐x‐tabs) 
 )
#+END_SRC 

**** sunrise-x-checkpoints

#+BEGIN_SRC emacs-lisp :results none
(use-package sunrise-x-checkpoints
 :ensure t
 :config
  )
#+END_SRC 
*** functions
**** open with external programs
#+BEGIN_SRC emacs-lisp :results none
;;; Adding files opened with external apps to the history of recent files.
(defadvice openwith-file-handler
  (around advice-openwith-file-handler (operation &rest args))
  (condition-case description
      ad-do-it
    (error (progn
             (recentf-add-file (car args))
             (error (cadr description))))))
(ad-activate 'openwith-file-handler)

(defun er/sunrise-flatten ()
 (interactive)
 (sr-find "-type f"))

; Kill all sunrise and dired buffers when closing Sunrise Commander
(defun er/kill-all-sunrise-buffers()
      "Kill all dired buffers."
      (interactive)
      (save-excursion
        (let((count 0))
          (dolist(buffer (buffer-list))
            (set-buffer buffer)
            (when (derived-mode-p 'dired-mode 'sr-virtual-mode 'sr-mode)
                (setq count (1+ count))
                (kill-buffer buffer)))
          (message "Killed %i sunrise buffer(s)." count ))))
(setq sr-quit-hook 'er/kill-all-sunrise-buffers)

#+END_SRC 
*** keys
**** main 
#+BEGIN_SRC emacs-lisp :results none
(define-key sr-mode-map (kbd "/") 'sr-fuzzy-narrow) 
(define-key sr-mode-map (kbd "") 'er/sunrise-flatten) 
(define-key sr-mode-map (kbd "\\") 'hydra-sr-chd/body ) 
(define-key sr-mode-map (kbd "`") 'hydra-sunrise-leader/body ) 
;lynx like
(define-key sr-mode-map (kbd "<left>") 'sr-dired-prev-subdir ) 
(define-key sr-mode-map (kbd "<right>") 'sr-advertised-find-file ) 
;move back/forward im history
(define-key sr-mode-map (kbd "M-<left>") 'sr-history-prev ) 
(define-key sr-mode-map (kbd "M-<right>") 'sr-history-next ) 
#+END_SRC
**** hydra chd
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "")
(defhydra hydra-sr-chd  (:color blue :hint nil :columns 4)

"
"
("a" (find-file "~/AUR/") "AUR" )
("b"  (find-file "~/bin/") "bin" )
("c"  nil )
("d" (find-file "~/Downloads/")    "Downloads" )
("e"  (find-file "~/.emacs.d/") "Emacs.d")
("E"  (find-file "~/.emacs.g/") "Emacs.g")
("f"  nil )
("g"  nil )
("h"  (find-file "~/") "HOME" )
("i"  nil )
("j"  nil )
("k"  (find-file "~/BK/") "BK" )
("l"  nil )
("m"  (find-file "~/music/") "music" )
("n"  nil )
("o"  (find-file "~/org/files/") "Org" )
("p"  (find-file "~/mtp") "mtp" )
("r"  (find-file "~/mreview/") "mreview" )
("s"  (find-file "~/Sync/") "Sync" )
("S"  (find-file "~/scripts/" "scripts") )
("t"  (find-file "~/mounts/" "mounts") )
("u"  (find-file "~/Uni//") "Uni" )
("v"  nil)
("w"  (find-file "~/dotfiles/") "dotfiles" )
("x"  nil )
("y"  nil )
("z"  (find-file "~/ZH_tmp//") "ZH_tmp" )
("."  (find-file "~/.config/") "config")
("/"  (find-file "/") "Root")
("q" nil  )

))

#+END_SRC

**** sunrise leader

#+BEGIN_SRC emacs-lisp :results none

(defhydra hydra-sunrise-leader  (:color blue :hint nil)

"

_a_:         _b_:         _c_:        _d_:        _e_:           _f_:         _g_:  
_h_: collapse org tree        _i_: insert text         _j_:       _k_:       _l_:          _m_: helm-mark        _n_: mark position       
_o_: mark prev   _p_ _q_ _r_ wdired   du_p_licate  _s_:       _t_: term           _u_:       
_v_:        _w_:        _x_:       _y_: kill ring       _z_: 
_q_: 

Sunrise:
【C-c C-d】recent dirs 【C-c C-q】wdired 【M-o】equal panes 【C-enter】open in next pane 
【N】copy/rename same dir 【s/r】sort/reverse 【X】exe file 【K】clone (cp tree) 【y】calc size


"

("a" find-file  )
("b"  nil  )
;("c"  company-complete )
("c"  auto-complete )
("d"  nil )
("e"  nil )
("f"  nil )
("g"  nil )
("h"  hide-sublevels )
("i"  hydra-editing-insert/body )
("j"  nil )
("k"  nil )
("l"  nil )
("m"  helm-mark-ring )
("n"  set-mark-command )
("o"  set-mark-command 4 )
("p"  duplicate-current-line-or-region )
("r"  sr-editable-pane )
("s"  nil )
("t"  sr-term-cd )
("T"  sr-term )
("<f9>"  sr-term-cd-newterm )
("u"  nil )
("v"  nil)
("w"  nil )
("x"  nil )
("y"  helm-show-kill-ring )
("z"  nil )
("\\"  z/insert-slsh )
(";"  comment-or-uncomment-region )
("q"  nil )

)
#+END_SRC


** sr-speedbar
SrSpeedbar is mode make SpeedBar show in Current Frame 
http://www.emacswiki.org/emacs/SrSpeedbar

#+BEGIN_SRC emacs-lisp :results none
(use-package sr-speedbar
 :ensure t
 :config
  )
#+END_SRC 

** Swiper
#+BEGIN_SRC emacs-lisp :results none
(use-package swiper 
 :ensure t
 :config
;(ivy-mode 1)
(setq ivy-use-virtual-buffers t)
(global-set-key "\C-s" 'swiper)
(global-set-key "\C-r" 'swiper-at-point)
(global-set-key (kbd "C-c C-r") 'ivy-resume)
 )
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
(defun swiper-at-point ()
  (interactive)
  (swiper (thing-at-point 'symbol)))
#+END_SRC

** swiper helm
#+BEGIN_SRC emacs-lisp :results none
(use-package swiper-helm
 :ensure t
 :config
  )
#+END_SRC 
** tiny
*** config
https://github.com/abo-abo/tiny
#+BEGIN_SRC emacs-lisp :results none
(use-package tiny
  :config
;  (global-set-key (kbd "C-s-t") 'tiny-expand)
)
#+END_SRC
*** examples
General Format: m[range start][separator(s)][range end]
₆In example₆ 
;; mBSEO|F
;;  ||||||
;;  |||||+--> (optional) Format - %x | 0x%x | %c | %s | %(+ x x) | %014.2f | %03d | %(date "Jan 16" (* x 7))
;;  ||||+---> (optional) Pipe character to separate Format for reading clarity
;;  |||+----> (optional) Operator - *xx | (* x x) | (+ x ?A) | *2+3x | (* 2 (+ 3 x))
;;  ||+-----> End value
;;  |+------> (optional) Separator - Space | , | \n (default=Space)
;;  +-------> (optional) Begin value (default=0)
;; - No space allowed between 'm' and 'B'
;; - No space allowed between 'E' and 'O'
 
Fancier Formatting
Do you know how I generated that numbered list of four elements? I used m1\n\n4|%d., which Tiny expands into:

1.

2.

3.

4.
This demonstrates that you can have multiple separator characters; here I use two \n’s for the extra space. But there is that |%d. at the end. Tiny lets you use Emacs Lisp format strings, which you write at the end of your expression and delimit with a vertical bar. The formatting string %d. prints each number as a digit (%d) with a period after it. Used in conjunction with the newline separators it gives me exactly the output I want for a numbered list in Markdown.

** transmission
need to install let-alist and seq packages from melpa
https://github.com/holomorph/transmission/issues/1

#+BEGIN_SRC emacs-lisp :results none
;(add-to-list 'load-path "/home/zeltak/.emacs.g/transmission/")
(require 'transmission)
;(setq transmission-host "10.0.0.2")
#+END_SRC

** Undo tree
#+BEGIN_SRC emacs-lisp :results none
(use-package undo-tree 
:ensure t
:config
(global-undo-tree-mode 1)
(setq undo-tree-auto-save-history t)
(setq undo-tree-history-directory-alist '((".*" . "~/.emacs.t/undo-files")))
(setq undo-tree-mode-lighter "")	 
)
#+END_SRC
** vimish-fold 

#+BEGIN_SRC emacs-lisp :results none
(use-package vimish-fold
 :ensure t
 :config
 (require 'vimish-fold)
;(global-set-key (kbd "<menu> v f") #'vimish-fold)
;(global-set-key (kbd "<menu> v v") #'vimish-fold-delete)
 )
#+END_SRC 


** unfill
https://github.com/purcell/unfill

makes or unmakes a marked section wider/shorter (look fill command)

#+BEGIN_SRC emacs-lisp :results none
(use-package unfill
:ensure t
:config
)
#+END_SRC
** volatile-highlights
https://github.com/k-talo/volatile-highlights.el
#+BEGIN_SRC emacs-lisp :results none
(use-package volatile-highlights
 :ensure t
 :config
(require 'volatile-highlights)
(volatile-highlights-mode t) 
 )
#+END_SRC 

** wanderlust
#+BEGIN_SRC emacs-lisp 1p:results none
(use-package wanderlust
 :ensure t
 :config
 
 )
#+END_SRC 

** worf
look here for more details on keybinds
https://github.com/abo-abo/worf/blob/master/worf.el

#+BEGIN_SRC emacs-lisp :results none
(use-package worf
 :ensure t
 :config
 )
#+END_SRC 

  (worf-define-key map "g" 'worf-goto)
  ;; ——— hide/show ————————————————————————————
  (worf-define-key map "v" 'worf-view)
  ;; ——— files ————————————————————————————————
  (worf-define-key map "F" 'worf-attach-visit)
  (worf-define-key map "A" 'worf-attach)
  (worf-define-key map "V" 'worf-visit)
  ;; ——— refile ———————————————————————————————
  (worf-define-key map "r" 'hydra-refile/body)
  ;; ——— misc —————————————————————————————————
  (worf-define-key map "L" 'worf-copy-heading-id)
  (worf-define-key map "a" 'worf-add :break t)
  (worf-define-key map "s" 'worf-save)
  ;; ——— narrow/widen —————————————————————————
  (worf-define-key map "N" 'org-narrow-to-subtree)
  (worf-define-key map "W" 'widen)
  ;; ——— verbs ————————————————————————————————
  (worf-define-key map "c" 'worf-change-mode)
  (worf-define-key map "d" 'worf-delete-mode)
  (worf-define-key map "y" 'worf-yank-mode)
  (worf-define-key map "C" 'worf-clock-mode)
  (worf-define-key map "w" 'worf-keyword-mode)
  (define-key map "m" 'worf-mark)
  (worf-define-key map "q" 'worf-quit)
  (worf-define-key map "n" 'worf-new-mode)
  ;; ——— nouns ————————————————————————————————
  (worf-define-key map "p" 'worf-property)
  ;; ——— misc —————————————————————————————————
  (worf-define-key map "t" 'worf-todo)
  (worf-define-key map "u" 'undo)

** weechat.el

#+BEGIN_SRC emacs-lisp :results none
  (use-package weechat
   :ensure t
   :config
  (require 'weechat)
(setq weechat-modules '(weechat-button
                        weechat-complete
                        weechat-spelling
                        weechat-corrector
                        weechat-tracking
                        weechat-notifications))
   )
#+END_SRC 

#+BEGIN_SRC emacs-lisp :results none
(eval-after-load 'weechat
  '(progn
     (setq weechat-host-default "karif.server-speed.net"
           weechat-port-default 9001
           weechat-color-list
           '(unspecified "black" "dark gray" "dark red" "red"
                         "dark green" "light green" "brown"
                         "yellow" "RoyalBlue3"
                         "light blue"
                         "dark magenta" "magenta" "dark cyan"
                         "light cyan" "gray" "white")
           weechat-prompt "> "
           weechat-notification-mode t
           weechat-auto-monitor-buffers t 
           weechat-complete-nick-ignore-self nil
           weechat-button-buttonize-nicks nil
           weechat-tracking-types '(:highlight (".+#weechat.el" . :message))
           weechat-sync-active-buffer t)
     (setq weechat-auto-monitor-buffers
      '("freenode.#gmpc"
        "bitlbee.rasi"))
     (set-face-background 'weechat-highlight-face "dark red")
     (set-face-foreground 'weechat-highlight-face "light grey")
     (add-hook 'weechat-mode-hook 'visual-line-mode)
     (tracking-mode)))
#+END_SRC

** winner-mode
#+BEGIN_SRC emacs-lisp :results none
(winner-mode 1)
#+END_SRC
** Wrap region

https://github.com/rejeep/wrap-region.el

#+BEGIN_SRC emacs-lisp :results none
(use-package wrap-region
  :ensure t
  :config
  (wrap-region-add-wrappers
   '(("*" "*" nil org-mode)
     ("~" "~" nil org-mode)
     ("/" "/" nil org-mode)
     ("=" "=" nil org-mode)
     ("_" "_" nil org-mode)
     ("%" "%" nil org-mode)
     ("!" "!" nil org-mode)
     ("`" "`" nil org-mode)
     ("'" "'" nil org-mode)
     ("@" "@" nil org-mode)
     ("$" "$" nil (org-mode latex-mode))
))
  (add-hook 'org-mode-hook 'wrap-region-mode)
  (add-hook 'latex-mode-hook 'wrap-region-mode)
)
#+END_SRC 


** workgroup2
http://workgroups2.readthedocs.org/en/latest/guide/installation.html
#+BEGIN_SRC emacs-lisp :results none
;(use-package workgroups2
; :ensure t
; :config
;(workgroups-mode 1)        ; put this one at the bottom of .emacs (init.el)
;(require 'workgroups2)
;; Change workgroups session file
;(setq wg-session-file "~/.emacs.d/.emacs_workgroups") 
;)
#+END_SRC 

** TODO xah-find
http://ergoemacs.org/emacs/elisp-xah-find-text.html
This is the home page for “xah-find.el”.

This package provides emacs commands for find/replace in a directory, like {grep, rgrep, lgrep, unix sed}, but written entirely in emacs lisp.

This package provides these commands:

xah-find-text
xah-find-text-regex
xah-find-count
xah-find-replace-text
xah-find-replace-text-regex

Press Enter ↵ on a link to jump to the file location. (or mouse clic)k
Press 【Tab ↹】 to jump to next occurence. (【⇧ Shift+Tab ↹】 for previous)
Press 【Alt+p】 or 【Alt+n】 to move cursor to previous/next file name.

#+BEGIN_SRC emacs-lisp :results none
(use-package xah-find
 :ensure t
 :config
  )
#+END_SRC 

** Yasnippet
*** load yasnippet

#+BEGIN_SRC emacs-lisp :results none
(use-package yasnippet
:ensure t
 :config 
(require 'yasnippet)
(yas-global-mode 1)
;; Use custom snippets.
(yas-reload-all)
(setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
;for orgmode properties fix 
(setq yas-indent-line 'fixed)
;set insert at point prompt type- here ido
(setq yas/prompt-functions '(yas/ido-prompt
                            yas/completing-prompt))
)
#+END_SRC
*** function helm 
#+BEGIN_SRC emacs-lisp :results none
(defun shk-yas/helm-prompt (prompt choices &optional display-fn)
  "Use helm to select a snippet. Put this into `yas/prompt-functions.'"
  (interactive)
  (setq display-fn (or display-fn 'identity))
  (if (require 'helm-config)
      (let (tmpsource cands result rmap)
        (setq cands (mapcar (lambda (x) (funcall display-fn x)) choices))
        (setq rmap (mapcar (lambda (x) (cons (funcall display-fn x) x)) choices))
        (setq tmpsource
              (list
	       (cons 'name prompt)
	       (cons 'candidates cands)
	       '(action . (("Expand" . (lambda (selection) selection))))
	       ))
        (setq result (helm-other-buffer '(tmpsource) "*helm-select-yasnippet"))
        (if (null result)
            (signal 'quit "user quit!")
          (cdr (assoc result rmap))))
    nil))
#+END_SRC
    
** org-reveal
https://github.com/yjwen/org-reveal
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/org-reveal")
(load  "/home/zeltak/.emacs.g/org-reveal/ox-reveal.el")
;;where the root reveal folder is
(setq org-reveal-root  "file:///home/zeltak/apps/reveal.js")
#+END_SRC


* Functions
$Note-all my (zeltak) functions should follow the following base syntax$
#+BEGIN_EXAMPLE
Z/MODENAME-HEADER-SUBHEADER-NAME
#+END_EXAMPLE
** Encoding
*** fix unicode characters
#+BEGIN_SRC emacs-lisp :results none
(defun z-fix-characters 
(start end) 
(interactive "r") 
(let ((buffer-invisibility-spec)) (query-replace-regexp "[^\t\n\r\f -~]" ""))
)

(defun z-fix2-characters ()
  (interactive)
  (let ()
    (query-replace-regexp "[^\t\n\r\f -~]" "")
    ))
#+END_SRC
** Editing
*** Increment years

#+BEGIN_SRC emacs-lisp
(defun z-year-increment  (buffer max-year)
  (interactive "b\nsMax year (yy): ")
  (setq max-year (string-to-number max-year))
  (let ((year 2003)
        (newbuf (get-buffer-create "increment-year")))
    (let ((s (with-current-buffer buffer
               (buffer-substring (point-min) (point-max)))))
      (dotimes (n (1+ max-year))
        (with-current-buffer newbuf
          (goto-char (point-max))
          (insert "\n")
          (insert (replace-regexp-in-string (int-to-string year)
                                            (int-to-string (+ year n))
                                            s)))))
    (switch-to-buffer newbuf)))
#+END_SRC

#+RESULTS:
: z-year-increment

*** Get rid of blank lines
#+BEGIN_SRC emacs-lisp :results none
(defun flush-blank-lines ()
    "Removes all blank lines from buffer or region"
     (interactive)
     (save-excursion
       (let (min max)
         (if (equal (region-active-p) nil)
             (mark-whole-buffer))
         (setq min (region-beginning) max (region-end))
         (flush-lines "^ *$" min max t))))
#+END_SRC 
*** Join lines

#+BEGIN_SRC emacs-lisp :results none
(global-set-key (kbd "M-j")
            (lambda ()
                  (interactive)
                  (join-line -1)))
#+END_SRC
*** Fill/unfill paragraph
#+BEGIN_SRC emacs-lisp :results none
(defun unfill-paragraph ()
  "Replace newline chars in current paragraph by single spaces.
This command does the inverse of `fill-paragraph'."
  (interactive)
  (let ((fill-column 90002000)) ; 90002000 is just random. you can use `most-positive-fixnum'
    (fill-paragraph nil)))

(defun unfill-region (start end)
  "Replace newline chars in region by single spaces.
This command does the inverse of `fill-region'."
  (interactive "r")
  (let ((fill-column 90002000))
    (fill-region start end)))

#+END_SRC
*** Count words in region
#+BEGIN_SRC emacs-lisp :results none

(defun z-count-words-region (posBegin posEnd)
  "Print number of words and chars in region."
  (interactive "r")
  (message "Counting …")
  (save-excursion
    (let (wordCount charCount)
      (setq wordCount 0)
      (setq charCount (- posEnd posBegin))
      (goto-char posBegin)
      (while (and (< (point) posEnd)
                  (re-search-forward "\\w+\\W*" posEnd t))
        (setq wordCount (1+ wordCount)))

      (message "Words: %d. Chars: %d." wordCount charCount)
      )))

#+END_SRC
*** Copy and comment
#+BEGIN_SRC emacs-lisp :results none
(defun z/copy-comment-paste ()
  "copy active region/current line, comment, and then paste"
  (interactive)
  (unless (use-region-p)
    (progn
      (beginning-of-line 2)
      (push-mark (line-beginning-position 0))))
  (kill-ring-save (region-beginning) (region-end))
  (comment-region (region-beginning) (region-end))
  (yank)
  (exchange-point-and-mark)
  (indent-according-to-mode))


#+END_SRC
*** comment/uncomment line
#+BEGIN_SRC emacs-lisp :results none
(defun z/comment-line (n)
  "Comment or uncomment current line and leave point after it.
With positive prefix, apply to N lines including current one.
With negative prefix, apply to -N lines above.
If region is active, apply to active region instead."
  (interactive "p")
  (if (use-region-p)
      (comment-or-uncomment-region
       (region-beginning) (region-end))
    (let ((range
           (list (line-beginning-position)
                 (goto-char (line-end-position n)))))
      (comment-or-uncomment-region
       (apply #'min range)
       (apply #'max range)))
    (forward-line 1)
    (back-to-indentation)))

#+END_SRC

*** move line up/down
    #+BEGIN_SRC emacs-lisp :results none
(defun move-line-up ()
  "Move up the current line."
  (interactive)
  (transpose-lines 1)
  (forward-line -2)
  (indent-according-to-mode))

(defun move-line-down ()
  "Move down the current line."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1)
  (indent-according-to-mode))

#+END_SRC
*** insert date
#+BEGIN_SRC emacs-lisp :results none
(defun z-insert-date (&optional addTimeStamp-p)
  "Insert current date and or time. In this format yyyy-mm-dd.
 When called with `universal-argument', insert date and time, e.g. 2012-05-28T07:06:23-07:00
 Replaces text selection.See also `current-date-time-string'."
  (interactive "P")
  (when (region-active-p) (delete-region (region-beginning) (region-end) ) )
  (cond
   ((equal addTimeStamp-p nil ) (insert (format-time-string "%Y-%m-%d")))
   (t (insert (current-date-time-string))) ) )
#+END_SRC
*** copy/paste to/from x clip

#+BEGIN_SRC emacs-lisp :results none
(defun copy-to-x-clipboard ()
  (interactive)
  (if (region-active-p)
      (progn
        (cond
         ((and (display-graphic-p) x-select-enable-clipboard)
          (x-set-selection 'CLIPBOARD (buffer-substring (region-beginning) (region-end))))
         (t (shell-command-on-region (region-beginning) (region-end)
                                     (cond
                                      (*cygwin* "putclip")
                                      (*is-a-mac* "pbcopy")
                                      (*linux* "xsel -ib")))
            ))
        (message "Yanked region to clipboard!")
        (deactivate-mark))
        (message "No region active; can't yank to clipboard!")))

(defun paste-from-x-clipboard()
  (interactive)
  (cond
   ((and (display-graphic-p) x-select-enable-clipboard)
    (insert (x-selection 'CLIPBOARD)))
   (t (shell-command
       (cond
        (*cygwin* "getclip")
        (*is-a-mac* "pbpaste")
        (t "xsel -ob"))
       1))
   ))
#+END_SRC

*** copy and indent lines

#+BEGIN_SRC emacs-lisp :results none
(defun prelude-indent-rigidly-and-copy-to-clipboard (begin end indent)
  "Copy the selected code region to the clipboard, indented according
to Markdown blockquote rules."
  (let ((buffer (current-buffer)))
    (with-temp-buffer
      (insert-buffer-substring-no-properties buffer begin end)
      (indent-rigidly (point-min) (point-max) indent)
      (clipboard-kill-ring-save (point-min) (point-max)))))

(defun prelude-indent-blockquote-and-copy-to-clipboard (begin end)
  "Copy the selected code region to the clipboard, indented according
to markdown blockquote rules (useful to copy snippets to StackOverflow, Assembla, Github."
  (interactive "r")
  (prelude-indent-rigidly-and-copy-to-clipboard begin end 4))

(defun prelude-indent-nested-blockquote-and-copy-to-clipboard (begin end)
  "Copy the selected code region to the clipboard, indented according
to markdown blockquote rules. Useful to add snippets under bullet points."
  (interactive "r")
  (prelude-indent-rigidly-and-copy-to-clipboard begin end 6))

#+END_SRC
*** search replace all document
@currently below code broken@

#+BEGIN_SRC emacs-lisp :results none
;(defun  z/search-replace-file ()
;(interactive)
;(goto-char (point-min))
;(query-replace-regexp ))

#+END_SRC
*** duplicate line/region 
#+BEGIN_SRC emacs-lisp :results none
(defun duplicate-current-line-or-region (arg)
  "Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated. However, if
there's a region, all lines that region covers will be duplicated."
  (interactive "p")
  (let (beg end (origin (point)))
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (let ((region (buffer-substring-no-properties beg end)))
      (dotimes (i arg)
        (goto-char end)
        (newline)
        (insert region)
        (setq end (point)))
      (goto-char (+ origin (* (length region) arg) arg)))))
#+END_SRC

**** old method for line only 
#+BEGIN_SRC emacs-lisp :results none
(defun duplicate-line()
  (interactive)
  (move-beginning-of-line 1)
  (kill-line)
  (yank)
  (open-line 1)
  (next-line 1)
  (yank)
)
#+END_SRC

*** copy current line
#+BEGIN_SRC emacs-lisp :results none
(defun z/copy-line (arg)
    "Copy lines (as many as prefix argument) in the kill ring.
      Ease of use features:
      - Move to start of next line.
      - Appends the copy on sequential calls.
      - Use newline as last char even on the last line of the buffer.
      - If region is active, copy its lines."
    (interactive "p")
    (let ((beg (line-beginning-position))
          (end (line-end-position arg)))
      (when mark-active
        (if (> (point) (mark))
            (setq beg (save-excursion (goto-char (mark)) (line-beginning-position)))
          (setq end (save-excursion (goto-char (mark)) (line-end-position)))))
      (if (eq last-command 'copy-line)
          (kill-append (buffer-substring beg end) (< end beg))
        (kill-ring-save beg end)))
    (kill-append "\n" nil)
    (beginning-of-line (or (and arg (1+ arg)) 2))
    (if (and arg (not (= 1 arg))) (message "%d lines copied" arg)))
#+END_SRC
*** auto spell correction function
From: itai kloog  <zeltak@gmail.com>
http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html

this will store the abbrevs here: 
file:/home/zeltak/.emacs.d/abbrv/personal_abbrv.txt

 #+BEGIN_SRC emacs-lisp :results none
; (define-key ctl-x-map "\C-i" 'endless/ispell-word-then-abbrev)

 (define-prefix-command 'endless/toggle-map)
 ;; The manual recommends C-c for user keys, but C-x t is
 ;; always free, whereas C-c t is used by some modes.
 (define-key ctl-x-map "t" 'endless/toggle-map)
 (define-key endless/toggle-map "w" 'endless/ispell-word-then-abbrev)

 (defun endless/ispell-word-then-abbrev (p)
   "Call `ispell-word'. Then create an abbrev for the correction made.
 With prefix P, create local abbrev. Otherwise it will be global."
   (interactive "P")
   (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
     (call-interactively 'ispell-word)
     (setq aft (downcase (or (thing-at-point 'word) "")))
     (unless (string= aft bef)
       (message "\"%s\" now expands to \"%s\" %sally"
		bef aft (if p "loc" "glob"))
       (define-abbrev
         (if p local-abbrev-table global-abbrev-table)
         bef aft))))
 #+END_SRC

*** common used regex
**** delete all numeric characters
#+BEGIN_SRC emacs-lisp :results none
(defun z/regex-delete-numeric  ()
  "delete all numeric characters"
  (interactive)
  (goto-char (point-min))
  (replace-regexp "[0-9]" "")
)
#+END_SRC

*** Code box
#+BEGIN_SRC emacs-lisp :results none
(defun z/comment-box (b e)
  "Draw a box comment around the region but arrange for the region
to extend to at least the fill column. Place the point after the
comment box."
  (interactive "r")
  (let ((e (copy-marker e t)))
    (goto-char b)
    (end-of-line)
    (insert-char ?  (- fill-column (current-column)))
    (comment-box b e 1)
    (goto-char e)
    (set-marker e nil)))

#+END_SRC
*** insert quick snippets/Unicode texts

#+BEGIN_SRC emacs-lisp :results none
(defun z/insert-keyleft ()
  " insert 【   "
  (interactive)
  (insert "【")
  )

(defun z/insert-keyright ()
  " insert 】   "
  (interactive)
  (insert "】")
  )


(defun z/insert-EOL ()
  " insert EOL"
  (interactive)
  (insert "\\\\")
(backward-char 2)  
)

(defun z/insert-bashscript ()
  " insert #!/bin/sh  "
  (interactive)
  (insert "#!/bin/sh")

(defun z/insert-play ()
  " insert   ‣  "
  (interactive)
  (insert "‣")
)

(defun z/insert-reveal-split ()
  "insert REVEAL split  "
  (interactive)
  (insert "#+REVEAL: split")
)

)


#+END_SRC


*** kill line backwars 
#+BEGIN_SRC emacs-lisp :results none
(defun backward-kill-line (arg)
  "Kill ARG lines backward."
  (interactive "p")
  (kill-line (- 1 arg)))
#+END_SRC
*** copy whole buffer
http://ergoemacs.org/emacs/emacs_copy_cut_all_or_region.html

#+BEGIN_SRC emacs-lisp :results none
(defun z/edit-copy-all-or-region ()
  "Put the whole buffer content to `kill-ring', or text selection if there's one.
Respects `narrow-to-region'.
URL `http://ergoemacs.org/emacs/emacs_copy_cut_all_or_region.html'
Version 2015-08-22"
  (interactive)
  (if (use-region-p)
      (progn
        (kill-new (buffer-substring (region-beginning) (region-end)))
        (message "Text selection copied."))
    (progn
      (kill-new (buffer-string))
      (message "Buffer content copied."))))
#+END_SRC
*** replace underscore
#+BEGIN_SRC emacs-lisp :results none
(defun xah-cycle-hyphen-underscore-space ()
  "Cycle {underscore, space, hypen} chars of current word or text selection.
When called repeatedly, this command cycles the {“_”, “-”, “ ”} characters, in that order.

URL `http://ergoemacs.org/emacs/elisp_change_space-hyphen_underscore.html'
Version 2015-08-17"
  (interactive)
  ;; this function sets a property 「'state」. Possible values are 0 to length of ξcharArray.
  (let (ξp1 ξp2)
    (if (use-region-p)
        (progn
          (setq ξp1 (region-beginning))
          (setq ξp2 (region-end)))
      (let ((ξbounds (bounds-of-thing-at-point 'symbol)))
        (progn
          (setq ξp1 (car ξbounds))
          (setq ξp2 (cdr ξbounds)))))

    (let* ((ξinputText (buffer-substring-no-properties ξp1 ξp2))
           (ξcharArray ["_" "-" " "])
           (ξlength (length ξcharArray))
           (ξregionWasActive-p (region-active-p))
           (ξnowState
            (if (equal last-command this-command )
                (get 'xah-cycle-hyphen-underscore-space 'state)
              0 ))
           (ξchangeTo (elt ξcharArray ξnowState)))
      (save-excursion
        (save-restriction
          (narrow-to-region ξp1 ξp2)
          (goto-char (point-min))
          (while
              (search-forward-regexp
               (concat
                (elt ξcharArray (% (+ ξnowState 1) ξlength))
                "\\|"
                (elt ξcharArray (% (+ ξnowState 2) ξlength)))
               (point-max)
               'NOERROR)
            (replace-match ξchangeTo 'FIXEDCASE 'LITERAL))))
      (when (or (string= ξchangeTo " ") ξregionWasActive-p)
        (goto-char ξp2)
        (set-mark ξp1)
        (setq deactivate-mark nil))
      (put 'xah-cycle-hyphen-underscore-space 'state (% (+ ξnowState 1) ξlength)))))
#+END_SRC
*** Bracket Pair Insertion Commands
#+BEGIN_SRC emacs-lisp :results none
(defun xah-insert-bracket-pair (φleft-bracket φright-bracket)
  "Wrap or Insert a matching bracket and place cursor in between.

If there's a text selection, wrap brackets around it. Else, smartly decide wrap or insert. (basically, if there's no char after cursor, just insert bracket pair.)

φleft-bracket ＆ φright-bracket are strings.

URL `http://ergoemacs.org/emacs/elisp_insert_brackets_by_pair.html'
Version 2015-04-19"
  (if (use-region-p)
      (progn
        (let (
              (ξp1 (region-beginning))
              (ξp2 (region-end)))
          (goto-char ξp2)
          (insert φright-bracket)
          (goto-char ξp1)
          (insert φleft-bracket)
          (goto-char (+ ξp2 2))))
    (progn ; no text selection
      (if
          (or
           (looking-at "[^-_[:alnum:]]")
           (eq (point) (point-max)))
          (progn
            (insert φleft-bracket φright-bracket)
            (search-backward φright-bracket ))
        (progn
          (let (ξp1 ξp2)
            ;; basically, want all alphanumeric, plus hyphen and underscore, but don't want space or punctuations. Also want chinese.
            ;; 我有一帘幽梦，不知与谁能共。多少秘密在其中，欲诉无人能懂。
            (skip-chars-backward "-_[:alnum:]")
            (setq ξp1 (point))
            (skip-chars-forward "-_[:alnum:]")
            (setq ξp2 (point))
            (goto-char ξp2)
            (insert φright-bracket)
            (goto-char ξp1)
            (insert φleft-bracket)
            (goto-char (+ ξp2 (length φleft-bracket)))))))))

#+END_SRC
*** specific paren types enter
#+BEGIN_SRC emacs-lisp :results none
(defun z/insert-black-lenticular-bracket () (interactive) (xah-insert-bracket-pair "【" "】") )
#+END_SRC
(defun xah-insert-single-angle-quote‹› () (interactive) (xah-insert-bracket-pair "‹" "›") )
(defun xah-insert-double-angle-quote«» () (interactive) (xah-insert-bracket-pair "«" "»") )
(defun xah-insert-double-curly-quote“” () (interactive) (xah-insert-bracket-pair "“" "”") )
(defun xah-insert-curly-single-quote‘’ () (interactive) (xah-insert-bracket-pair "‘" "’") )
(defun xah-insert-ascii-double-quote () (interactive) (xah-insert-bracket-pair "\"" "\"") )
(defun xah-insert-ascii-single-quote () (interactive) (xah-insert-bracket-pair "'" "'") )
(defun xah-insert-emacs-quote () (interactive) (xah-insert-bracket-pair "`" "'") )
(defun xah-insert-corner-bracket「」 () (interactive) (xah-insert-bracket-pair "「" "」") )
(defun xah-insert-white-corner-bracket『』 () (interactive) (xah-insert-bracket-pair "『" "』") )
(defun xah-insert-angle-bracket〈〉 () (interactive) (xah-insert-bracket-pair "《" "》") )
(defun xah-insert-double-angle-bracket《》 () (interactive) (xah-insert-bracket-pair "《" "》") )
(defun xah-insert-white-lenticular-bracket〖〗 () (interactive) (xah-insert-bracket-pair "〖" "〗") )
(defun xah-insert-black-lenticular-bracket【】 () (interactive) (xah-insert-bracket-pair "【" "】") )
(defun xah-insert-tortoise-shell-bracket〔〕 () (interactive) (xah-insert-bracket-pair "〔" "〕") )


*** flyspell jump to last correction
#+BEGIN_SRC emacs-lisp :results none
;; move point to previous error
;; based on code by hatschipuh at
;; http://emacs.stackexchange.com/a/14912/2017
(defun z/flyspell-goto-previous-error (arg)
  "Go to arg previous spelling error."
  (interactive "p")
  (while (not (= 0 arg))
    (let ((pos (point))
          (min (point-min)))
      (if (and (eq (current-buffer) flyspell-old-buffer-error)
               (eq pos flyspell-old-pos-error))
          (progn
            (if (= flyspell-old-pos-error min)
                ;; goto beginning of buffer
                (progn
                  (message "Restarting from end of buffer")
                  (goto-char (point-max)))
              (backward-word 1))
            (setq pos (point))))
      ;; seek the next error
      (while (and (> pos min)
                  (let ((ovs (overlays-at pos))
                        (r '()))
                    (while (and (not r) (consp ovs))
                      (if (flyspell-overlay-p (car ovs))
                          (setq r t)
                        (setq ovs (cdr ovs))))
                    (not r)))
        (backward-word 1)
        (setq pos (point)))
      ;; save the current location for next invocation
      (setq arg (1- arg))
      (setq flyspell-old-pos-error pos)
      (setq flyspell-old-buffer-error (current-buffer))
      (goto-char pos)
      (if (= pos min)
          (progn
            (message "No more miss-spelled word!")
            (setq arg 0))
        (forward-word)))))
#+END_SRC
** org
*** convert to same level header
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-convert-header-samelevel  ()
                     (interactive)                                
                     (let ((current-prefix-arg '(4)))             
                       (call-interactively #'org-toggle-heading)))

#+END_SRC

*** tangle only code block at point 
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-tangle-atpoint  ()
                     (interactive)                                
                     (let ((current-prefix-arg '(4)))             
                       (call-interactively #'org-babel-tangle)))

#+END_SRC

*** agenda views
**** org agenda calendar
  
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-calendar ()
"open work agenda"
(interactive)                                
(org-agenda nil "a")
)
#+END_SRC

**** org agenda work 

#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-work ()
"open work agenda"
(interactive)                                
(org-agenda nil "w")
)
#+END_SRC

**** org agenda search
**** org agenda Allan
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-allan ()
"open work agenda"
(interactive)                                
(org-agenda nil "l")
)
#+END_SRC

**** org agenda Joel
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-joel ()
"open work agenda"
(interactive)                                
(org-agenda nil "j")
)
#+END_SRC
**** org agenda cook
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-cook ()
"open work agenda"
(interactive)                                
(org-agenda nil "f")
)
#+END_SRC

**** TODO org export to pdf
#+BEGIN_SRC emacs-lisp :results none
(fset 'expdf
      [?\C-c ?\C-e ?\l ?\o ])
#+END_SRC

**** TODO org TODO spares tree
add all todo states to sparse tree
#+begin_src emacs-lisp
  (defun z/org-sparse-todo ()
    "all todo sparse"
    (interactive)
    (org-match-sparse-tree t )
)
#+end_src


**** org agenda search
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-search()
""
(interactive)                                
(org-agenda nil "s")
)
#+END_SRC
**** org agenda search todo
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-search-todo ()
""
(interactive)                                
(org-agenda nil "S")
)
#+END_SRC


*** link to file
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-link-file  ()
                     (interactive)                                
                     (let ((current-prefix-arg '(4)))             
                       (call-interactively #'org-insert-link)))

#+END_SRC
*** TODO link to any header
    :PROPERTIES:
    :ID:       b9436f8a-478b-4f98-8bc8-65697ffb8c78
    :END:
First we define the base function

#+BEGIN_SRC emacs-lisp
(defun insert-heading-link (dir)
  "select a headline from org-files in dir and insert a link to it."
  (interactive  (list (read-directory-name "Directory: ")))
  (let ((org-agenda-files (f-entries
                           dir
                           (lambda (f)
                             (string=
                              "org"
                              (file-name-extension f)))
                           t)))
    (helm-org-agenda-files-headings)))
#+END_SRC

gives helm buffer to select headlines from org-files in the directory I select and when I press f3 (for the third action), it inserts a link to the selected headline. 
It does the file finding recursively, so big folders can be slow

to add the org id component to the above script eval this as well

#+BEGIN_SRC emacs-lisp
(defun helm-org-insert-id-link-to-heading-at-marker (marker)
  (with-current-buffer (marker-buffer marker)
    (let ((file-name (buffer-file-name))
          (id (save-excursion (goto-char (marker-position marker))
                              (org-id-get-create)
                              (org-id-store-link))))

      (with-helm-current-buffer
        (org-insert-link
         file-name id)))))


(cl-defun helm-source-org-headings-for-files (filenames
                                              &optional (min-depth 1) (max-depth 8))
  (helm-build-sync-source "Org Headings"
    :candidates (helm-org-get-candidates filenames min-depth max-depth)
    :action '(("Go to line" . helm-org-goto-marker)
              ("Refile to this heading" . helm-org-heading-refile)
              ("Insert link to this heading"
               . helm-org-insert-link-to-heading-at-marker)
              ("Insert id link to this heading" .
               helm-org-insert-id-link-to-heading-at-marker))))

#+END_SRC


*** terminal
**** org evaluate to term

 #+begin_src emacs-lisp
 (defadvice org-babel-execute:sh (around sacha activate)
   (if (assoc-default :term (ad-get-arg 1) nil)
     (let ((buffer (make-term "babel" "/bin/zsh")))
       (with-current-buffer buffer
	 (insert (org-babel-expand-body:generic
	      body params (org-babel-variable-assignments:sh params)))
	 (term-send-input))
 (pop-to-buffer buffer))
     ad-do-it))
 #+end_src

*** editing
**** Insert current time stamp

#+BEGIN_SRC emacs-lisp :results none
(defun org-timestamp-now ()
  "Inserts org timestamp at end of heading"
  (interactive)
  (save-excursion
    (org-back-to-heading)
    (org-end-of-line nil)
    (insert " ")
    (org-insert-time-stamp nil nil t nil nil nil)))
#+END_SRC

**** Insert time stamp selector 

#+BEGIN_SRC emacs-lisp :results none
(defun org-timestamp-select ()
  "Inserts org timestamp at end of heading"
  (interactive)
  (save-excursion
    (org-back-to-heading)
    (org-end-of-line nil)
    (org-time-stamp-inactive nil)))

#+END_SRC
**** import ods file into org table
#+BEGIN_SRC emacs-lisp :results none
(defun org-table-import-ods (&optional file-name)
(interactive "fFile: ")
(let ((csv-file (org-odt-convert file-name "csv"))
(pos (point)))
(save-excursion
(insert (with-temp-buffer
(insert-file-contents csv-file)
(org-table-convert-region (point-min) (point-max) '(4))
(buffer-string))))))
#+END_SRC
**** convert lines to checkboxes
 
#+BEGIN_SRC emacs-lisp :results none
(defun org-set-line-checkbox (arg)
  (interactive "P")
  (let ((n (or arg 1)))
    (when (region-active-p)
      (setq n (count-lines (region-beginning)
                           (region-end)))
      (goto-char (region-beginning)))
    (dotimes (i n)
      (beginning-of-line)
      (insert "- [ ] ")
      (forward-line))
    (beginning-of-line)))
#+END_SRC
    
**** convert lines to headline
 
#+BEGIN_SRC emacs-lisp :results none
(defun org-set-line-headline (arg)
  (interactive "P")
  (let ((n (or arg 1)))
    (when (region-active-p)
      (setq n (count-lines (region-beginning)
                           (region-end)))
      (goto-char (region-beginning)))
    (dotimes (i n)
      (beginning-of-line)
      (insert "** TODO ")
      (forward-line))
    (beginning-of-line)))
#+END_SRC
    
**** read only function
Make some org-sections read-only

$Note- you !MUST! tag the header :read_only: other wise it wont work$ 

#+BEGIN_SRC emacs-lisp :results none
(defun org-mark-readonly ()
(interactive)
(org-map-entries
(lambda ()
(let* ((element (org-element-at-point))
(begin (org-element-property :begin element))
(end (org-element-property :end element)))
(add-text-properties begin (- end 1) '(read-only t
font-lock-face '(:background "#FFE3E3")))))
"read_only")
(message "Made readonly!"))
(defun org-remove-readonly ()
(interactive)
(org-map-entries
(lambda ()
(let* ((element (org-element-at-point))
(begin (org-element-property :begin element))
(end (org-element-property :end element))
(inhibit-read-only t))
(remove-text-properties begin (- end 1) '(read-only t font-lock-face '(:background "yellow")))))
"read_only"))
(add-hook 'org-mode-hook 'org-mark-readonly)
#+END_SRC

*** TODO code blocks
**** comment inside org code block 
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-comment ()    
(interactive)
(org-edit-special)
(mark-whole-buffer)
(comment-dwim nil)
(org-edit-src-exit))

#+END_SRC
**** TODO paste code block
***** z/org-cblock-paste-lisp
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-lisp ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_SRC emacs-lisp\n")
  (yank)
  (insert "\n#+END_SRC"))
#+END_SRC
***** z/org-cblock-paste-sh
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-sh ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_SRC sh\n")
  (yank)
  (insert "\n#+END_SRC"))
#+END_SRC
***** z/org-cblock-paste-EXAMPLE
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-example ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_EXAMPLE\n")
  (yank)
  (insert "\n#+END_EXAMPLE"))
#+END_SRC
***** z/org-cblock-paste-R
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-R ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_SRC R :session Rorg  :results none\n")
  (yank)
  (insert "\n#+END_SRC"))
#+END_SRC
***** z/org-cblock-paste-SAS
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-SAS ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_SRC SAS\n")
  (yank)
  (insert "\n#+END_SRC"))
#+END_SRC
***** z/org-cblock-paste-QUOTE
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-QUOTE ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_QUOTE\n")
  (yank)
  (insert "\n#+END_QUOTE"))
#+END_SRC
**** interactive wrap
***** z/org-cblock-iwrap-emacs-lisp
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-iwrap-emacs-lisp (&optional lang lines)
  "Wrap sexp-at-point or region in src-block.
Use Org-Babel LANGuage for the src-block if given, Emacs-Lisp
otherwise. A region instead of the sexp-at-point is wrapped if
either
   - optional argument LINES is an (positive or negative) integer
   - or the region is active
In the first case the region is determined by moving +/- LINES
forward/backward from point using `forward-line', in the second
case the active region is used.
When called with prefix argument 'C-u', prompt the user for the
Org-Babel language to use. When called with two prefix arguments
'C-u C-u', prompt the user for both the Org-Babel language to use
and the number of lines to be wrapped."
  (interactive
   (cond
    ((equal current-prefix-arg nil) nil)
    ((equal current-prefix-arg '(4))
     (list
      (ido-completing-read "Org-Babel language: "
                           (mapcar
                            (lambda (--lang)
                              (symbol-name (car --lang)))
                            org-babel-load-languages)
                           nil nil nil nil "emacs-lisp")))
    ((equal current-prefix-arg '(16))
     (list
      (ido-completing-read "Org-Babel language: "
                           (mapcar
                            (lambda (--lang)
                              (symbol-name (car --lang)))
                            org-babel-load-languages)
                           nil nil nil nil "emacs-lisp")
      (read-number "Number of lines to wrap: " 1)))))
  (let* ((language (or lang "emacs-lisp"))
         (beg (or (and (not lines)
		       (region-active-p)
		       (region-beginning))
                  (point)))
         (marker (save-excursion (goto-char beg) (point-marker)))
         (bol (save-excursion (goto-char beg) (bolp)))
         (end (cond
	       (lines (save-excursion
                        (forward-line lines) (point)))
	       ((region-active-p)(region-end))
	       (t (save-excursion
                    (forward-sexp) (point)))))
         (cut-strg (buffer-substring beg end)))
    (delete-region beg end)
    (goto-char (marker-position marker))
    (insert
     (format
      "%s#+begin_src %s\n%s%s#+end_src\n"
      (if (or (and lines (< lines 0)) bol) "" "\n")
      language
      cut-strg
      (if lines "" "\n")))
    (set-marker marker nil)))
#+end_src
***** z/org-cblock-iwrap-ASK 
 #+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-iwrap-ASK ()
(interactive)
(let ((current-prefix-arg '(4)))
(call-interactively
'z/org-cblock-iwrap-emacs-lisp)))
 #+END_SRC
***** z/org-cblock-iwrap-ASK-LINE 
 #+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-iwrap-ASK-LINE ()
(interactive)
(let ((current-prefix-arg '(4)))
(call-interactively
'z/org-cblock-iwrap-emacs-lisp)))
 #+END_SRC
***** z/org-cblock-iwrap-R
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-iwrap-R ()
(interactive)
(z/org-cblock-iwrap-emacs-lisp  "R" ))
#+end_src
***** z/org-cblock-iwrap-sh
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-iwrap-sh ()
(interactive)
(z/org-cblock-iwrap-emacs-lisp  "sh" ))
#+end_src

***** z/org-cblock-nowrap-EXAMPLE
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-nowrap-example ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_EXAMPLE\n")
  (insert "\n#+END_EXAMPLE"))
#+END_SRC
**** menu for wrapping 
#+BEGIN_SRC emacs-lisp :results none
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; function to wrap blocks of text in org templates                       ;;
;; e.g. latex or src etc                                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun z/org-cblock-iwrap-menu ()
  "Make a template at point."
  (interactive)
  (if (org-at-table-p)
      (call-interactively 'org-table-rotate-recalc-marks)
    (let* ((choices '(("s" . "SRC")
                      ("e" . "EXAMPLE")
                      ("q" . "QUOTE")
                      ("v" . "VERSE")
                      ("c" . "CENTER")
                      ("l" . "LaTeX")
                      ("h" . "HTML")
                      ("r" . "R")
                      ("a" . "ASCII")))
           (key
            (key-description
             (vector
              (read-key
               (concat (propertize "Template type: " 'face 'minibuffer-prompt)
                       (mapconcat (lambda (choice)
                                    (concat (propertize (car choice) 'face 'font-lock-type-face)
                                            ": "
                                            (cdr choice)))
                                  choices
                                  ", ")))))))
      (let ((result (assoc key choices)))
        (when result
          (let ((choice (cdr result)))
            (cond
             ((region-active-p)
              (let ((start (region-beginning))
                    (end (region-end)))
                (goto-char end)
                (insert "#+END_" choice "\n")
                (goto-char start)
                (insert "#+BEGIN_" choice "\n")))
             (t
              (insert "#+BEGIN_" choice "\n")
              (save-excursion (insert "#+END_" choice))))))))))

#+END_SRC
*** food 	
**** inbox Recipe Template
based on the following blog post:
http://lebensverrueckt.haktar.org/articles/org-mode-Food/#comment-1348609811

#+BEGIN_SRC emacs-lisp :results none
(defun recipe-template ()
        (interactive)
        (goto-line 0)
        (search-forward "* Inbox")
         (org-meta-return)
         (org-metaright)
         (setq recipe-name (read-string "Title: "))
         (insert recipe-name)
         (org-todo "COOK") 
         (org-set-tags)
         (org-meta-return)
         (org-metaright)
         (insert "Ingridients")
         (org-meta-return)
         (insert "Preperation")
         (search-backward recipe-name)
         (setq src1 (read-string "Time: "))
         (org-set-property "Time" src1)
         (setq src2 (read-string "Rating: "))
         (org-set-property "Rating" src2)
         (setq src3 (read-string "Sources: "))
         (org-set-property "Source" src3)
         (setq src4 (read-string "Ammount: "))
         (org-set-property "Ammount" src4)
         (setq src5 (read-string "Fav: "))
         (org-set-property "Fav" src5)
         (search-forward "Ingridients")
         (evil-open-below 1)
         (beginning-of-visual-line)
)
#+END_SRC
**** ADD Recipe Template

#+BEGIN_SRC emacs-lisp :results none
(defun blank-recipe-template ()
        (interactive)
         (org-meta-return)
         (org-metaright)
         (setq recipe-name (read-string "Title: "))
         (insert recipe-name)
         (org-set-tags)
         (org-meta-return)
         (org-metaright)
         (insert "Ingridients")
         (org-meta-return)
         (insert "Preperation")
         (search-backward recipe-name)
         (setq src1 (read-string "Time: "))
         (org-set-property "Time" src1)
         (setq src2 (read-string "Rating: "))
         (org-set-property "Rating" src2)
         (setq src3 (read-string "Sources: "))
         (org-set-property "Source" src3)
         (setq src4 (read-string "Ammount: "))
         (org-set-property "Ammount" src4)
         (setq src5 (read-string "Fav: "))
         (org-set-property "Fav" src5)
         (search-forward "Ingridients")
         (evil-open-below 1)
         (beginning-of-visual-line)
)
#+END_SRC
**** add Travel Template

#+BEGIN_SRC emacs-lisp :results none
(defun travel-template ()
        (interactive)
        (goto-line 0)
        (search-forward "* Inbox")
         (org-meta-return)
         (org-metaright)
         (setq travel-name (read-string "Title: "))
         (insert travel-name)
         (org-set-tags)
         (org-meta-return)
         (org-metaright)
         (insert "Details")
         (org-meta-return)
         (search-backward travel-name)
         (setq src1 (read-string "Rating: "))
         (org-set-property "Rating" src1)
         (setq src2 (read-string "Sources: "))
         (org-set-property "Source" src2)
         (setq src3 (read-string "Fav: "))
         (org-set-property "Fav" src3)
         (search-forward "Details")
         (evil-open-below 1)
)
#+END_SRC

*** movment org specific
**** go to top header

#+BEGIN_SRC emacs-lisp :results none
; Speed commands are really useful, but I often want to make use of
; them when I'm not at the beginning of a header. Ths command brings
; you back to the beginning of an item's header, so that you can do
; speed commands.
 
(defun org-go-speed ()
"Goes to the beginning of an element's header, so that you can
execute speed commands."
(interactive)
(when (equal major-mode 'org-mode)
(if (org-at-heading-p)
(org-beginning-of-line)
(org-up-element))))
 
#+END_SRC
     
*** send header via Email 		 

#+BEGIN_SRC emacs-lisp :results none
  (defun z/org-email-heading ()
    "Send the current org-mode heading as the body of an email, with headline as the subject.
  use these properties
  TO
  CC
  BCC
  OTHER-HEADERS is an alist specifying additional
  header fields.  Elements look like (HEADER . VALUE) where both
  HEADER and VALUE are strings.
  Save when it was sent as a SENT property. this is overwritten on
  subsequent sends."
    (interactive)
    ; store location.
    (setq *email-heading-point* (set-marker (make-marker) (point)))
    (save-excursion
      (org-mark-subtree)
      (let ((content (buffer-substring (point) (mark)))
            (TO (org-entry-get (point) "TO" t))
            (SUBJECT (nth 4 (org-heading-components)))
            (OTHER-HEADERS (eval (org-entry-get (point) "OTHER-HEADERS")))
            (continue nil)
            (switch-function nil)
            (yank-action nil)
            (send-actions '((email-send-action . nil)))
            (return-action '(email-heading-return)))
        
        (compose-mail TO SUBJECT OTHER-HEADERS continue switch-function yank-action send-actions return-action)
        (message-goto-body)
        (insert content)
        (when CC
          (message-goto-cc)
          (insert CC))
        (when BCC
          (message-goto-bcc)
          (insert BCC))
        (if TO
            (message-goto-body)
          (message-goto-to)))))

#+END_SRC
*** Send email to myself
#+BEGIN_SRC emacs-lisp
(defun z/org-email-heading-me ()
  "Send the current org-mode heading as the body of an email, with headline as the subject."
  (interactive)
  (save-excursion
    (org-mark-subtree)
    (let ((content (buffer-substring (point) (mark)))
          (SUBJECT (nth 4 (org-heading-components))))

      (compose-mail "ikloog@gmail.com" SUBJECT)
      (message-goto-body)
      (insert content)
      (message-send)
      (message-kill-buffer))))
#+END_SRC
*** exporting
**** export to reveal and browse
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-export-revel-browse ()
"export to org reveal"
(interactive)                                
(org-reveal-export-to-html-and-browse)
)
#+END_SRC
**** export to reveal html  file
 #+BEGIN_SRC emacs-lisp :results none
 (defun z/org-export-revel-html ()
 "export to org reveal"
 (interactive)                                
 (org-reveal-export-to-html)
 )
 #+END_SRC
**** export subtree to file
 #+BEGIN_SRC emacs-lisp :results none
 (defun z/org-export-revel-subtree ()
 "export to org reveal"
 (interactive)                                
 (org-reveal-export-current-subtree)
 )
 #+END_SRC

*** movements 
**** TODO move to top and collapse
     :PROPERTIES:
     :ID:       14d0aa60-975b-4fb1-9065-45650b64afc1
     :END:
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-move-top-collapse  ()
     (interactive)            
     (beginning-of-buffer)                    
     (hide-sublevels 1)
)
#+END_SRC
** hydra related
*** slash \
#+BEGIN_SRC emacs-lisp :results none
(defun z/insert-slsh ()
  " insert     "
  (interactive)
  (insert "\\")
)
#+END_SRC
** Root actions
*** edit file as root
#+BEGIN_SRC emacs-lisp :results none
(defun z-edit-file-as-root ()
  "Edit the file that is associated with the current buffer as root"
  (interactive)
  (if (buffer-file-name)
      (progn
        (setq file (concat "/sudo:root@localhost:" (buffer-file-name)))
        (find-file file))
    (message "Current buffer does not have an associated file.")))


#+END_SRC
** Buffers
*** kill other buffers
#+BEGIN_SRC emacs-lisp :results none
(defun z-kill-other-buffers ()
      "Kill all other buffers."
      (interactive)
      (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

#+END_SRC

*** movment in buffer
#+BEGIN_SRC emacs-lisp :results none
(defun next-user-buffer ()
  "Switch to the next user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun previous-user-buffer ()
  "Switch to the previous user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

(defun next-emacs-buffer ()
  "Switch to the next emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun previous-emacs-buffer ()
  "Switch to the previous emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))


(defun switch-to-previous-buffer ()
  "Switch to previously open buffer.
Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))


#+END_SRC
*** save current file and close window
#+BEGIN_SRC emacs-lisp :results none
(defun z-save-buffer-close-window ()
  "DOCSTRING"
  (interactive)
    (save-buffer)
    (kill-this-buffer)
  )
#+END_SRC
*** move to other window and close current
#+BEGIN_SRC emacs-lisp :results none
(defun z/buffer-close-andmove-other   ()
     (interactive)    
     (ace-window 1)        
      (ace-delete-window)
)
#+END_SRC
** open a specific dir
#+BEGIN_SRC emacs-lisp :results none
(defun ood () (interactive) (dired "/home/zeltak/org"))
#+END_SRC
** General emacs
*** create scratch buffer
#+BEGIN_SRC emacs-lisp :results none
(defun create-scratch-buffer nil
   "create a scratch buffer"
   (interactive)
   (switch-to-buffer (get-buffer-create "*scratch*"))
   (lisp-interaction-mode))  
#+END_SRC
*** describe last comman
http://stackoverflow.com/questions/275842/is-there-a-repeat-last-command-in-emacsd
#+BEGIN_SRC emacs-lisp :results none
(defun describe-last-function() 
  (interactive) 
  (describe-function last-command))
#+END_SRC
*** Launch ansi-term
#+BEGIN_SRC emacs-lisp :results none
;; taken from here: http://www.enigmacurry.com/2008/12/26/emacs-ansi-term-tricks/
(defun z/launch--ansi-term ()
  "If the current buffer is:
     1) a running ansi-term named *ansi-term*, rename it.
     2) a stopped ansi-term, kill it and create a new one.
     3) a non ansi-term, go to an already running ansi-term
        or start a new one while killing a defunt one"
  (interactive)
  (let ((is-term (string= "term-mode" major-mode))
        (is-running (term-check-proc (buffer-name)))
        (term-cmd "/bin/zsh")
        (anon-term (get-buffer "*ansi-term*")))
    (if is-term
        (if is-running
            (if (string= "*ansi-term*" (buffer-name))
                ;; (call-interactively 'rename-buffer)
                (ansi-term term-cmd)
              (if anon-term
                  (switch-to-buffer "*ansi-term*")
                (ansi-term term-cmd)))
          (kill-buffer (buffer-name))
          (ansi-term term-cmd))
      (if anon-term
          (if (term-check-proc "*ansi-term*")
              (switch-to-buffer "*ansi-term*")
            (kill-buffer "*ansi-term*")
            (ansi-term term-cmd))
        (ansi-term term-cmd)))))
#+END_SRC
** toggles 
*** auto narrow/widen

#+BEGIN_SRC emacs-lisp :results none
(defun z/narrow-or-widen-dwim ()
"If the buffer is narrowed, it widens. Otherwise, it narrows to region, or Org subtree."
(interactive)
(cond ((buffer-narrowed-p) (widen))
((region-active-p) (narrow-to-region (region-beginning) (region-end)))
((equal major-mode 'org-mode) (org-narrow-to-subtree))
(t (error "Please select a region to narrow to"))))
#+END_SRC

** outside Emacs
*** search google
#+BEGIN_SRC emacs-lisp :results none
(require 'thingatpt)

(defun google-search ()
  "Googles a query or region if any."
  (interactive)
  (browse-url
   (concat
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
    (if mark-active
        (buffer-substring (region-beginning) (region-end))
      (read-string "Google: ")))))
#+END_SRC

** helm 
*** swish-e

#+BEGIN_SRC emacs-lisp :results none
(defun helm-swish-e-candidates (query)
  "Generate a list of cons cells (swish-e result . path)."
  (let* ((result (shell-command-to-string
		  (format "swish-e -f ~/.swish-e/index.swish-e -x \"%%r\t%%p\n\" -w %s"
			  (shell-quote-argument query))))
	 (lines (s-split "\n" result t))
	 (candidates '()))
    (loop for line in lines
	  unless (or  (s-starts-with? "#" line)
		      (s-starts-with? "." line))
	  collect (cons line (cdr (s-split "\t" line))))))


(defun helm-swish-e (query)
  "Run a swish-e query and provide helm selection buffer of the results."
  (interactive "sQuery: ")
  (helm :sources `(((name . ,(format "swish-e: %s" query))
		    (candidates . ,(helm-swish-e-candidates query))
		    (action . (("open" . (lambda (f)
					   (find-file (car f)))))))
		   ((name . "New search")
		    (dummy)
		    (action . (("search" . (lambda (f)
					     (helm-swish-e helm-pattern)))))))))
#+END_SRC

*** TODO helm hotspot menu
#+BEGIN_SRC emacs-lisp :results none
(defun hotspots ()
  "helm interface to my hotspots, which includes my locations,
org-files and bookmarks"
  (interactive)
  (helm :sources `(((name . "Mail and News")
                    (candidates . (("Mail" . (lambda ()
                                               (if (get-buffer "*mu4e-headers*")
                                                   (progn
                                                     (switch-to-buffer "*mu4e-headers*")
                                                     (delete-other-windows))

                                                 (mu4e))))
                                   ("Calendar" . (lambda ()  (browse-url "https://www.google.com/calendar/render")))
                                   ("RSS" . elfeed)
                                   ("Agenda" . (lambda () (org-agenda "" "w")))))
                    (action . (("Open" . (lambda (x) (funcall x))))))
                   ((name . "My Locations")
                    (candidates . (("master" . "~/org/files/")
                                   (".emacs.d" . "~/.emacs.d/" )
                                   ("todo" . "~/org/files/agenda/todo.org")))
                    (action . (("Open" . (lambda (x) (find-file x))))))

                   ((name . "My org files")
                    (candidates . ,(f-entries "~/org/files/"))
                    (action . (("Open" . (lambda (x) (find-file x))))))
                   helm-source-recentf
                   helm-source-bookmarks
                   helm-source-bookmark-set)))
#+END_SRC
** dired
*** marks
**** mark non org
#+BEGIN_SRC emacs-lisp :results none
(defun z/del-nonorg-files ()
(interactive)
(dired-mark-files-regexp "\\.org$") 
(dired-toggle-marks)
(dired-do-delete)
)
#+END_SRC
*** open in external (default) app
http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html

#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-open-in-external-app ()
  "Open the current file or dired marked files in external app.
The app is chosen from your OS's preference."
  (interactive)
  (let* (
         (ξfile-list
          (if (string-equal major-mode "dired-mode")
              (dired-get-marked-files)
            (list (buffer-file-name))))
         (ξdo-it-p (if (<= (length ξfile-list) 5)
                       t
                     (y-or-n-p "Open more than 5 files? "))))

    (when ξdo-it-p
      (cond
       ((string-equal system-type "windows-nt")
        (mapc
         (lambda (fPath)
           (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t))) ξfile-list))
       ((string-equal system-type "darwin")
        (mapc
         (lambda (fPath) (shell-command (format "open \"%s\"" fPath)))  ξfile-list))
       ((string-equal system-type "gnu/linux")
        (mapc
         (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath))) ξfile-list))))))
#+END_SRC
*** open in WM/DE file manafer
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-open-in-desktop ()
  "Show current file in desktop (OS's file manager)."
  (interactive)
  (cond
   ((string-equal system-type "windows-nt")
    (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
   ((string-equal system-type "darwin") (shell-command "open ."))
   ((string-equal system-type "gnu/linux")
    (let ((process-connection-type nil)) (start-process "" nil "xdg-open" "."))
    ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. ⁖ with nautilus
    ) ))
#+END_SRC

*** get marked files size
#+BEGIN_SRC emacs-lisp :results none
 (defun z/dired-get-size ()
  (interactive)
  (let ((files (dired-get-marked-files)))
    (with-temp-buffer
      (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
      (message "Size of all marked files: %s"
               (progn 
                 (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
                  (match-string 1))))))
#+END_SRC

*** beet import
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-beet-import ()
  (interactive)
  (sr-term)
  (let* ((fmt "beet import %s\n")
         (file (sr-clex-file sr-selected-window))
         (command (format fmt file)))
    (if (not (equal sr-terminal-program "eshell"))
        (term-send-raw-string command)
      (insert command)
      (eshell-send-input))))
#+END_SRC
*** beet import single
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-beet-import-single ()
  (interactive)
  (sr-term)
  (let* ((fmt "beet import -s %s\n")
         (file (sr-clex-file sr-selected-window))
         (command (format fmt file)))
    (if (not (equal sr-terminal-program "eshell"))
        (term-send-raw-string command)
      (insert command)
      (eshell-send-input))))
#+END_SRC
*** make executable
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-make-exec ()
  (interactive)
  (sr-term)
  (let* ((fmt "chmod +x %s\n")
         (file (sr-clex-file sr-selected-window))
         (command (format fmt file)))
    (if (not (equal sr-terminal-program "eshell"))
        (term-send-raw-string command)
      (insert command)
      (eshell-send-input))))
#+END_SRC
*** fb
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-fb-upload ()
  (interactive)
  (sr-term)
  (let* ((fmt "fb %s\n")
         (file (sr-clex-file sr-selected-window))
         (command (format fmt file)))
    (if (not (equal sr-terminal-program "eshell"))
        (term-send-raw-string command)
      (insert command)
      (eshell-send-input)
      (shell-command "notify-send fb uploaded")
)))
#+END_SRC
*** mpc add
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-mpd-add ()
  (interactive)
  (sr-term)
  (let* ((fmt "mpc add file:/ %s\n")
         (file (sr-clex-file sr-selected-window))
         (command (format fmt file)))
    (if (not (equal sr-terminal-program "eshell"))
        (term-send-raw-string command)
      (insert command)
      (eshell-send-input))))
#+END_SRC







*** sshfs qnap
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-ssh-qnap ()
  (interactive)
  (sr-term)
  (let* ((fmt "sshfs -p 12121 admin@10.0.0.2:/share/MD0_DATA/ /home/zeltak/mounts/lraid \n")
         (file (sr-clex-file sr-selected-window))
         (command (format fmt file)))
    (if (not (equal sr-terminal-program "eshell"))
        (term-send-raw-string command)
      (insert command)
      (eshell-send-input))))
#+END_SRC








*** mediainfo
#+BEGIN_SRC emacs-lisp :results none
(fset 'z/dired-media-info
   [?& ?m ?e ?d ?i ?a ?i ?n ?f ?o return ])
#+END_SRC
*** nmap network
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-nmap-network ()
"map all available IP on my netwrok"
(interactive)
(sr-term )
(insert " nmap -sP 10.0.0.1/24" )
(eshell-send-input)
)
#+END_SRC
*** dired sort
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-sort-menu ()
  "Sort dired dir listing in different ways.
Prompt for a choice.
URL `http://ergoemacs.org/emacs/dired_sort.html'
Version 2015-07-30"
  (interactive)
  (let (ξsort-by ξarg)
    (setq ξsort-by (ido-completing-read "Sort by:" '( "date" "size" "name" "dir")))
    (cond
     ((equal ξsort-by "name") (setq ξarg "-Al --si --time-style long-iso "))
     ((equal ξsort-by "date") (setq ξarg "-Al --si --time-style long-iso -t"))
     ((equal ξsort-by "size") (setq ξarg "-Al --si --time-style long-iso -S"))
     ((equal ξsort-by "dir") (setq ξarg "-Al --si --time-style long-iso --group-directories-first"))
     (t (error "logic error 09535" )))
    (dired-sort-other ξarg )))
#+END_SRC
*** lgs
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-backup-lgs ()
"run laptop git script"
(interactive)
(sr-term )
(insert "~/bin/lgs.sh" )
(eshell-send-input)
)
#+END_SRC

**** TODO additional commands
cuetag.sh {f}  *.flac
shnsplit -f {F}  -o flac {oF}
** isearch
#+BEGIN_SRC emacs-lisp :results none
(defun isearch-delete-something ()
  "Delete non-matching text or the last character."
  ;; Mostly copied from `isearch-del-char' and Drew's answer on the page above
  (interactive)
  (if (= 0 (length isearch-string))
      (ding)
    (setq isearch-string
          (substring isearch-string
                     0
                     (or (isearch-fail-pos) (1- (length isearch-string)))))
    (setq isearch-message
          (mapconcat #'isearch-text-char-description isearch-string "")))
  (if isearch-other-end (goto-char isearch-other-end))
  (isearch-search)
  (isearch-push-state)
  (isearch-update))

(define-key isearch-mode-map (kbd "<backspace>") 
  #'isearch-delete-something)
#+END_SRC

** mail
*** yas mail functions
#+BEGIN_SRC emacs-lisp :results none
(defun my-yas-get-first-name-from-to-field ()
  (let ((rlt "AGENT_NAME") str)
    (save-excursion
      (goto-char (point-min))
      ;; first line in email could be some hidden line containing NO to field
      (setq str (buffer-substring-no-properties (point-min) (point-max))))
    (if (string-match "^To: \"\\([^ ,]+\\)" str)
        (setq rlt (match-string 1 str)))
    (message "rlt=%s" rlt)
    rlt))
#+END_SRC
* Key binds
  :PROPERTIES:
  :ID:       d4e38ca1-43ac-4fb5-a31f-5b432a4c0418
  :END:
** 1-unbind keys
#+BEGIN_SRC emacs-lisp :results none
(global-unset-key (kbd "<f1>"))
(global-unset-key (kbd "<f2>"))
(global-unset-key (kbd "<f3>"))
(global-unset-key (kbd "<f4>"))
(global-unset-key (kbd "<f5>"))
(global-unset-key (kbd "<f6>"))
(global-unset-key (kbd "<f7>"))
(global-unset-key (kbd "<f8>"))
(global-unset-key (kbd "<f9>"))
(global-unset-key (kbd "<f10>"))
(global-unset-key (kbd "<f11>"))
(global-unset-key (kbd "<f12>"))
(global-unset-key (kbd "C-v"))
(global-unset-key (kbd "C-M-p"))
(global-unset-key (kbd "C-M-e"))
(global-unset-key (kbd "C-M-b"))
(global-unset-key (kbd "C-M-b"))
(global-unset-key (kbd "C-M-t"))
#+END_SRC
** global
#+BEGIN_SRC emacs-lisp :results none
(global-set-key (kbd "M-x") 'counsel-M-x)
#+END_SRC
*** switch keybind between transpose char and lines
#+BEGIN_SRC emacs-lisp :results none
(global-set-key "\C-t" #'transpose-lines)
(define-key ctl-x-map "\C-t" #'transpose-chars)
#+END_SRC
** editing 
#+BEGIN_SRC emacs-lisp :results none
(key-chord-define-global "yy"     'z/copy-line)
(global-set-key (kbd "C-+") 'z/copy-line)
(key-chord-define-global "jj"     'avy-goto-word-or-subword-1)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
;;(global-set-key (kbd "C-<tab>") 'dabbrev-expand)
;;(define-key minibuffer-local-map (kbd "C-<tab>") 'dabbrev-expand)
#+END_SRC
** movment
#+BEGIN_SRC emacs-lisp :results none
(global-unset-key (kbd "M-`"))
;(global-set-key (kbd "M-`") 'avy-goto-line)
(global-set-key (kbd "C-<up>") 'windmove-up)
(global-set-key (kbd "C-<down>") 'windmove-down)
(global-set-key (kbd "C-<right>") 'windmove-right)
(global-set-key (kbd "C-<left>") 'windmove-left)
#+END_SRC

quick switch other windw 
#+BEGIN_SRC emacs-lisp :results none
;;(global-set-key (kbd "M-1") 'other-window)
(global-set-key (kbd "M-1") 'ace-window)
#+END_SRC


** org
*** base binds 
#+BEGIN_SRC emacs-lisp :results none
;Create an ID for the entry at point if it does not yet have one.
(global-set-key "\C-ca" 'org-agenda)
(global-set-key (kbd "C-c c") 'org-capture)
(global-set-key "\C-cs" 'org-babel-execute-subtree)
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-cb" 'org-iswitchb)

#+END_SRC
*** swap C and M RETURN
#+BEGIN_SRC emacs-lisp :results none
(with-eval-after-load "org" 
(define-key org-mode-map (kbd "<C-return>") 'org-insert-heading)
(define-key org-mode-map (kbd "<M-return>")  'org-insert-heading-respect-content)
) 
#+END_SRC

** isearch
#+BEGIN_SRC emacs-lisp :results none
(progn
  ;; set arrow keys in isearch. left/right is backward/forward, up/down is history. press Return to exit
  (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat )
  (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance )
  (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward) ; single key, useful
  (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward) ; single key, useful
 )
#+END_SRC
** dired
#+BEGIN_SRC emacs-lisp :results none
(define-key dired-mode-map (kbd "<left>") 'diredp-up-directory-reuse-dir-buffer )
(define-key dired-mode-map (kbd "<right>") 'diredp-find-file-reuse-dir-buffer )
(define-key dired-mode-map (kbd "S-RET") 'dired-open-in-external-app )
#+END_SRC
** key-chord

#+BEGIN_SRC emacs-lisp :results none
(key-chord-define-global "3e" 'hydra-editing/body)
(key-chord-define-global "9o" 'hydra-org-edit/body)
#+END_SRC
** Ess/org tangle
#+BEGIN_SRC emacs-lisp :results none
(global-set-key (kbd "C-c x") 'org-babel-execute-subtree)
#+END_SRC
* hydra
  :PROPERTIES:
  :ID:       e240cc34-4260-4f99-9dce-e34a77c7fa8a
  :END:
*** hydra faces
#+BEGIN_SRC emacs-lisp :results none
(defface hydra-face-orange
    '((t (:foreground "orange" :bold t)))
  "Orange face. For fun.")

(defface hydra-face-red
    '((t (:foreground "red" :bold t)))
  "red face. For fun.")

(defface hydra-face-green
    '((t (:foreground "green" :bold t)))
  "green face. For fun.")

#+END_SRC

*** TODO hydra leader

#+BEGIN_SRC emacs-lisp :results none

(global-set-key
   (kbd "\\")
(defhydra hydra-leader  (:color blue  :columns 4 :hints nil)

"
LEADER:【C-A-W】-append to killring
"
("\]" z/insert-slsh "insert \\")
("<backspace>"   "empty")
("\\"  avy-goto-char-timer  "avy jump")
("<f12>" z/buffer-close-andmove-other "move back to window and close" :exit t)   
("a" nil )
;("c"  company-complete )
("c"  auto-complete )
("d"  org-cut-subtree "org-cut"   )
("f"  nil )
("g"  hydra-goto/body )
("h"  z/org-move-top-collapse   "collapse tree")
("H"  hide-sublevels "collapse tree")
("i"  hydra-editing-insert/body "insert symbol" )
("j"  nil )
("y"  org-copy-subtree  "org-copy" )
("l"  avy-goto-line "jump line" )
("m"  helm-mark-ring "HELM mark ")
("n"  set-mark-command "mark position")
("b"  set-mark-command 4 "mark prev" )
("o"   hydra-org-edit/body "org edit" :face 'hydra-face-green )
("p"  org-paste-subtree  "org-paste")
("e"  duplicate-thing  "duplicate")
("r"  repeat "repeat last command" )
("s"  nil )
("t"  helm-top "top")
("u"  nil )
("v"  nil)
("w"  wrap-region "wrap symbol" )
("x"  nil )
("k"  helm-show-kill-ring "kill ring")
("z"  avy-zap-to-cha "avy zap")
(";"  comment-or-uncomment-region )
("q"  nil )

))
#+END_SRC
*** Emacs//toggles (f1)
**** main toggles 
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f1>")
(defhydra hydra-toggles (:color blue  :columns 6)
"Toggles:   【M-g M-g】 goto line 【C-x SPACE】 start mark rectangle 
easy-kill: 【M-w w】 select word // w, +- , 1..9 to increment (0 to reset)//【C-space】 turn selection to region// 【M-3】easy-mark
"
("a" pandoc-mode "pandoc"  )
("b" bug-hunter-file "bug hunter" :face 'hydra-face-orange )
("c" cua-mode "cua" :face 'hydra-face-red )
("d" tool-bar-mode "toggle toolbar"   )
("e" evil-mode "evil")
("f" fci-mode "fci" )
("g" google-search "google")
("h" hydra-toggles-help/body "help" )
("i"  nil )
("j"  helm-colors "color pallete" )
("k" key-chord-mode "key-chord"  )
("l" linum-mode  "linium")
("m" hydra-toggles-macro/body "macro menu")
("n" start-kbd-macro "start macro" :face 'hydra-face-green)
("o" end-kbd-macro "end macro" :face 'hydra-face-red)
("O" org-mode "org-mode" )
("p" list-packages "elpa"  )
("r" read-only-mode "read-only")
("s" scratch "scratch")
("S" create-scratch-buffer "New scratch" )
("t" lentic-mode  "lentic")
("u" electric-pair-mode "electric-pair")
("v" view-mode "view-mode")
("w" whitespace-mode "whitespace")
("x" eval-buffer "eval buffer")
("X" eval-region "eval-region")
("y" nil )
("z" nil )
("=" text-scale-increase :color red )
("-" text-scale-decrease :color red)
("G"  indent-guide-mode "guide-mode")
("q" nil "cancel")
))
#+END_SRC

**** extra macro commaqnds

 #+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-toggles-macro  (:color blue :hint nil )
      "macro commands
      "
      ("s" start-kbd-macro  "start macro" ) 
      ("e"   "end macro" ) 
      ("e" kmacro-end-and-call-macro  "use C-x e" ) 
      ("n" name-last-kbd-macro  "name macro" ) 
      ("i" insert-kbd-macro  "insert macro" ) 
      ("q" nil "cancel" nil)
 )
 #+END_SRC

**** help menu commands
#+BEGIN_SRC emacs-lisp :results none

(global-set-key
   (kbd "")
(defhydra hydra-toggles-help (:color blue :hint nil)

"
_k_ :describe key  _v_ describe variable _f_ describe functiom  
M-1- change windows
M-2 expand region (select gradualy regions)
~movment~ >> 【C-e//C-a】  (end/start of line)
~editing~ >>  【C-BKSP//A-BKSP】 (kill word start/end of line)



_q_: 
"

("a" nil )
("b"  nil  )
("c"  nil )
("d"  describe-last-function "describe last command used" )
("e"  nil )
("f"  describe-function )
("g"  nil )
("h"  nil )
("i"  nil )
("j"  nil )
("k"  describe-key )
("l"  nil )
("m"  nil )
("n"  nil )
("o"  nil )
("p"  nil )
("r"  nil )
("s"  nil )
("t"  nil )
("u"  nil )
("v"  describe-variable)
("w"  nil )
("x"  nil )
("y"  nil )
("z"  nil )
("q"  nil )

))
#+END_SRC

*** dired hydra (f2)
**** main
#+BEGIN_SRC emacs-lisp :results none

(global-set-key
   (kbd "<f2>")
(defhydra hydra-dired-main (:color blue :hint nil)

"

_a_:         _b_:         _c_: configs        _d_:mark/unmark        _e_:           _ff_//_fd_//_fd_ (find/find lisp/dirs)         _g_:  
_h_:         _i_:         _j_:dired-jump       _k_:       _l_:          _m_:        _n_:      
_o_: dired operations       _p_:peep dired        _r_:       _s_:       _t_: toggles          _u_:       
_v_:        _w_:        _x_:       _y_:       _z_: 
_q_: 

【s】sort 【+】 add dir 【&/!】 open with 【M-n】 cycle diredx guesses 
【C/R/D/S】 copy/move(rename)/delete/symlink
【S-5-m】 mark by string // ^test(start with) txtDOLLAR (end with) 
【*s】 mark all 【*t】 invert mark 【*d】 mark for deletion 【k】 hide marked 【g】unhide mark 【g】 refresh
【Q】query replace marked files 【o】open file new window 【V】open file read only 【i】open dir-view below

"
("<f2>" dired )
("<f1>" sunrise )
("a" nil )
("b"  nil  )
("c"  hydra-dired-configs/body )
("d"  nil )
("e"  nil )
("ff"  find-dired )
("fl"  find-lisp-find-dired )
("fd"  find-lisp-find-dired-subdirectories )
("g"  nil )
("h"  nil )
("i"  nil )
("j"  dired-jump )
("k"  nil )
("l"  nil )
("m"  diredp-mark/unmark-extension )
("n"  dired-narrow-regexp )
("o"  hydra-dired-operation/body )
("p"  peep-dired )
("r"  nil )
("s"  nil )
("t"  hydra-dired-configs/body )
("u"  nil )
("v"  nil)
("w"  nil )
("x"  nil )
("y"  nil )
("z"   hydra-dired-filter/body  "filter" )
("q"  nil )

))
#+END_SRC

**** dired togles
**** dired filter 
 #+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-dired-filter (:color blue )
      "
Filter by:
      "
     ("e" dired-filter-by-extension  "extension 【/.】" ) 
     ("r" dired-filter-by-regexp  "regex 【/r】" ) 
     ("f" dired-filter-by-file  "file 【/f】" ) 
     ("n" dired-filter-by-name  "name 【/n】" ) 
      ("q" nil "cancel" nil)
 )
 #+END_SRC

dired-omit-mode

 #+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-dired-configs (:color blue )
      "
      "
     ("o" dired-omit-mode  "dired omit" ) 
     ("t" dired-details-toggle  "dired details" ) 
     ("w" wdired-change-to-wdired-mode  "wdired" ) 
      ("q" nil "cancel" nil)
 )
 #+END_SRC

dired-omit-mode

**** dired operations
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "")
(defhydra hydra-dired-operation (:color blue :hint nil)

"

_a_:         _b_:         _c_: clean non-org        _d_:        _e_:           _f_:         _g_:  
_h_:         _i_:         _j_:       _k_:       _l_:          _m_:        _n_:      
_o_:        _p_:        _r_:       _s_:       _t_:           _u_:       
_v_:        _w_:        _x_:       _y_:       _z_: 
_q_: 

"



("a" nil )
("b"  nil  )
("c"  z/del-nonorg-files )
("d"  nil )
("e"  nil )
("f"  nil )
("g"  nil )
("h"  nil )
("i"  nil )
("j"  nil )
("k"  nil )
("l"  nil )
("m"  nil )
("n"  nil )
("o"  nil )
("p"  nil )
("r"  nil )
("s"  nil )
("t"  nil )
("u"  nil )
("v"  nil)
("w"  nil )
("x"  nil )
("y"  nil )
("z"  nil )
("q"  nil )

))
#+END_SRC
*** search/spelling/editing  (F3)

#+BEGIN_SRC emacs-lisp :results none
  (global-set-key
  (kbd "<f3>")
  (defhydra hydra-spell  (:color blue :hint nil :columns 4)

  "
【C-SPACE】 recntangle select // 【C-;】 ispell cycle // 【C-x z】 repeat last command- keep press 【z】to repeat
 "
  ("<f3>" endless/ispell-word-then-abbrev "check and add" )
  ("<f2>" flyspell-auto-correct-previous-word "correct last word" )
  ("<f4>" z/flyspell-goto-previous-error "correct last word" )
  ("1" helm-swoop "Helm-swoop")
  ("2" helm-multi-swoop "Helm-multi-swoop")
  ("3" helm-multi-swoop-org "Helm-multi-swoop-org")
  ("a" helm-apropos "Helm-Apropos")
  ("b"  backward-kill-line  "kill backwards")
  ("c"  cycle-spacing "cycle spacing")
  ("d"  helm-do-grep "helm-grep" )
  ("e"  hydra-editing/body "editing menu" 'hydra-face-green)
  ("f"  helm-find-files "Helm FF" )
  ("g"  rgrep "Rgrep")
  ("h"  highlight-symbol "HS symbol")
  ("H"  highlight-symbol-remove-all "HS remove")
  ("i"  ispell "ispell")
  ("j"  highlight-symbol-next  :color red  "HS Next")
  ("k"  highlight-symbol-prev  :color red  "HS Prev")
  ("l"  helm-locate "helm-locate")
  ("L"  counsel-locate "council-locate")
  ("m"  flyspell-check-next-highlighted-word "check next error")
  ("n"  flyspell-goto-next-error "check next error" )
  ("o"  helm-occur "helm Occur")
  ("p"  nil )
  ("r"  hydra-rectangle/body "rectangle menu")
  ("R"  anzu-query-replace-at-cursor "Replace@cursor")
  ("s"  isearch-forward "isearch" )
  ("S"  isearch-forward-symbol-at-point "isearch@point" )
  ("t"  nil )
  ("u"  imenu "imenu")
  ("v"  nil)
  ("w"  ispell-word "ispeel word" )
  ("x"  xah-cycle-hyphen-underscore-space "cycle-underscore" )
  ("y"  nil )
  ("z"  counsel-recoll "recoll" )
  ("9"  goto-last-change "goto last change" )
  ("0"  goto-last-change-revrese "goto prev change" )
  ("q"  nil )

  ))
#+END_SRC

*** code (f4)
 #+BEGIN_SRC emacs-lisp :results none
   (global-set-key
    (kbd "<f4>")
    (defhydra hydra-org-blocks (:color blue :hint nil :columns 4)
    "
to wrap by symbol mark region and then issue symbol, like: 【*】
"
    ("<f4>" z/org-cblock-iwrap-emacs-lisp "WRAP-Elisp" )
    ("<f3>" z/org-cblock-iwrap-sh  "Bash" )
    ("r" z/org-cblock-iwrap-emacs-R "WRAP-R" )
    ("a" z/org-cblock-iwrap-ASK  "Ask" )
    ("l" z/org-cblock-iwrap-ASK-LINE "Ask line" )
    ("m" z/org-cblock-iwrap-menu "Ask line" )
    ("pl" z/org-cblock-paste-lisp "paste lisp" )
    ("pb" z/org-cblock-paste-sh "paste bash" )
    ("pr" z/org-cblock-paste-R "paste R" )
    ("ps" z/org-cblock-paste-SAS  "paste SAS" )
    ("pe" z/org-cblock-paste-example  "paste Example" )
    ("pq" z/org-cblock-paste-QUOTE "paste QUOTE" )
    ("e" z/org-cblock-nowrap-example "insert Example block" )
    ("q" nil "cancel")))

 #+END_SRC
   
*** mu4e (F5)

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f5>")
(defhydra hydra-mu4e (:color blue  :columns 2 :hints nil)
  "
【M-Enter】 open link 【R】 Reply to sender 
【+】flag (star)
"
  ("<f5>"     mu4e            "start mu4e")
  ("<f6>"     helm-mu            "helm mu4e")
  ("ez" z/org-email-heading-me "email myslef the tree")
  ("ex" z/org-email-heading "email other the tree")
  ("o"     mu4e-headers-change-sorting            "sort")
  ("z"   z/org-email-heading              "email header")
    ("q"     nil                          "cancel" )
))
#+END_SRC
*** latex/bib (F6)

#+BEGIN_SRC emacs-lisp :results none

(global-set-key
   (kbd "<f6>")
(defhydra hydra-bib  (:color blue :hint nil :columns 4)

"
Bib:
"

("<f6>" helm-bibtex "helm-bibtex")
("a" nil )
("b"  nil  )
("c"  org-ref-clean-bibtex-entry "clean bib" )
("d"  doi-utils-insert-bibtex-entry-from-doi "add by doi" )
("e"  ebib )
("f"  nil )
("g"  nil )
("h"  nil )
("i"  nil )
("j"  nil )
("k"  helm-bibtex-ikloog-publications "kloog papers" )
("K"  helm-bibtex-ikloog-publications-all "kloog ALL")
("l"  nil )
("m"  nil )
("n"  org-bibtex-create "new bib entry")
("o"  nil )
("p"  helm-bibtex-ikloog-prep "kloog prep")
("r"  helm-resume "helm resume")
("s"  bibtex-sort-buffer "sort buffer")
("t"  nil )
("u"  nil )
("v"  bibtex-validate "validtae" )
("V"  bibtex-validate-globally "validate-check for dups") ; check for dup keys
("w"  nil )
("x"  nil )
("y"  org-bibtex-yank "yank bibtex")
("z"  nil )
("q"  nil )

))


#+END_SRC

*** ???? (F7)

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f7>")
(defhydra hydra-f7 (:color blue  :columns 2 :hints nil)
  "
"
  ("<f7>"     company-complete            "complete")
  ("<f6>"     company-dabbrev            "dabbrev comp")
  ("y"   company-yasnippet  "yasnippet comp")
  ("m"   company-manual-begin  "manual comp")
  ("c"   company-complete-common  "commom comp")
  ("n"   company-select-next  "next comp")
    ("q"     nil                          "cancel" )
))
#+END_SRC



*** bookmark hydra (F8)
whats this:  (global-set-key (kbd "C-c h") 'helm-command-prefix)

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f8>")
(defhydra  hydra-open  (:color blue :hint nil :columns 4)
"
BKMK Menu
"
("<f8>" helm-bookmarks "BKMK's")
("<f7>" helm-mini "helm-mini")
("<f9>" projectile-find-file  "projectile ff")
("7" org-iswitchb "org buffers")
("a" nil )
("b"  bmkp-bookmark-set-confirm-overwrite "add BKMK" )
("c"  helm-chrome-bookmarks "Chorme BKMK")
("d"  nil )
("e"  nil )
("f"  bmkp-bmenu-filter-tags-incrementally "BKMK menu filter")
("g"  nil )
("h"  nil )
("i"  nil )
("j"  helm-projectile-switch-to-buffer "Helm projectile switch" )
("k"  nil )
("l"  nil )
("m"  bookmark-bmenu-list "BKMK menu")
("n"  nil )
("o"  helm-projectile "Helm Projectile")
("p"  projectile-find-file "projectile find file")
("r"  helm-recentf "Helm Recents" )
("s"  bookmark-save "BKMK Save" )
("t"  z/launch--ansi-term "ansi-term" )
("u"  nil )
("v"  nil)
("w"  nil )
("x"  nil )
("y"  nil )
("z"  nil )
("q"  nil )

))

#+END_SRC

*** org (F9)
**** org main
     :PROPERTIES:
     :ID:       5d5567f8-9f16-4b76-adb6-8600ce16e2ec
     :END:

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f9>")
(defhydra hydra-org (:color blue :hint nil :columns 4)

"ORG editing
【C-c -】 convert to dashed lines  【C-M-l】 org table menu
"

("<f9>" helm-org-headlines "helm org headers")
("<f10> w" worf-goto "worf org headers")
("<f8>" z/org-insert-heading-link "link/refile")
("RET"  org-insert-todo-heading "org todo header//check list")
("<f10> RET"  org-insert-subheading "org sub header")
("<f10> t"  org-insert-todo-subheading "org sub header")
("."  org-do-demote "<" :color red)
(","  org-do-promote ">" :color red)
("<"  org-promote-subtree "T<" :color red)
(">"  org-demote-subtree "T>" :color red)

("a"  org-sort "sort")
("b"  worf-mode "worf"  )
("c"  org-columns "Columns" )
("C"  org-columns-quit "quit Columns" )
("d"  org-download-screenshot "screenshot")
("D"  org-download-delete "del screenshot")
("E"  org-export-dispatch "export")
("ep" org-latex-export-to-pdf "export latex")
("er" z/org-export-revel-browse "export reveal browse")
("et" z/org-export-revel-subtree "export reveal subtree")
("ey" z/org-export-revel-html  "export reveal html ")
("f"  hydra-org-food/body "food menu"  :face 'hydra-face-orange )
("g"  org-set-tags "tags dialog")
("h"  org-insert-heading "insert header")
("i"  org-toggle-inline-images "toggle images")
("j"  nil )
("k"  nil )
("l"  hydra-org-links/body "link menu" :face 'hydra-face-green)
("m"  org-mark-subtree "mark subtree" )
("n"  helm-swish-e "swish")
("o"  org-occur "org-occur" )
("p"  nil )
("r"  org-refile "refile")
("R"  z/prefix-org-refile "jump to header using refile")
("s"  hydra-org-time/body "time menu" :face 'hydra-face-orange )
("t"  org-todo "todo dialog")
("u"  nil )
("v"  org-babel-execute-subtree "exe block")
("w"  z/narrow-or-widen-dwim "Toggle narrow//widen" )
("x"  org-archive-subtree "Archive" )
("-"  org-toggle-heading "Header lower" )
("="  z/org-convert-header-samelevel "Header same")
("0"  org-ctrl-c-star "convert lines to headers")
("\\"  hydra-org-table/body "table menu"  :face 'hydra-face-orange )
(";"  z/comment-org-in-src-block "comment block" )
("y"  nil )
("z"  nil )
("<home>" outline-up-heading  "up main header" :color red)
("<down>" org-forward-heading-same-level  "up header" :color red)
("<up>" org-backward-heading-same-level  "down header" :color red)
("q"  nil )

))
#+END_SRC
   
**** extra org links commands
 #+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-org-links (:color blue  :hint nil :columns 3)
      "
link menus 
      "
     ("u" org-link-edit-forward-slurp  "forward slurp")
     ("y" org-link-edit-backward-slurp  "back  slurp")
     ("j" org-link-edit-forward-barf  "forward edit")
     ("k" org-link-edit-backward-barf  "backward edit")
     ("i" org-insert-link   "insert (or edit if on link)//also 【C-c C-l】" ) 
     ("d" org-id-create "just create Id")
     ("c" org-id-copy  "copy(and create) to killring" ) 
     ("s" org-id-store-link  "store org-id" ) 
     ("f" z/org-link-file  "link to file (via helm)" ) 
     ("w" worf-copy-heading-id  "worf copy id ot killring" ) 
     ("q" nil "cancel" nil)
 )
 #+END_SRC

org-link-edit-forward-barf
;; - org-link-edit-backward-barf

**** org cooking 
#+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-org-food ()
   "org-food "
   ("b" cooking-sparse-tree-breakfeast "breakfeast_view" :color blue)
   ("m" cooking-sparse-tree-main "main_view" :color blue)
   ("r" recipe-template "recipe-template" :color blue)
   ("t" travel-template  "travel-template" :color blue)
   ("q" nil "cancel")
)
#+END_SRC

**** org bable

#+BEGIN_SRC emacs-lisp :results none

(global-set-key
   (kbd "C-M-v")
(defhydra hydra-org-tangle  (:color blue :hint nil)

"
_a_:         _b_:         _c_:        _d_:        _e_:           _f_:         _g_:  
_h_:         _i_:         _j_:       _k_:       _l_:          _m_:        _n_:      
_o_:        _p_: tang-atpoint        _r_:       _s_:       _t_: tangle file           _u_:       
_v_:        _w_:        _x_:       _y_:       _z_: 
_q_: quit 

"

("a" nil )
("b"  nil  )
("c"  nil )
("d"  nil )
("e"  nil )
("f"  nil )
("g"  nil )
("h"  nil )
("i"  nil )
("j"  nil )
("k"  nil )
("l"  nil )
("m"  nil )
("n"  nil )
("o"  nil )
("p"  z/org-tangle-atpoint )
("r"  nil )
("s"  nil )
("t"  org-babel-tangle )
("u"  nil )
("v"  nil)
("w"  nil )
("x"  nil )
("y"  nil )
("z"  nil )
("q"  nil )

))


#+END_SRC


**** orgmode time functions 

 #+BEGIN_SRC emacs-lisp :results none
  (defhydra hydra-org-time (:color blue)
    "time command"
    ("a"  org-timestamp-select "select time stamp")
    ("s" org-timestamp-now  "timestamp current" )
    ("i" z-insert-date "insert current data")  
    ("d" org-deadline  "set deadline")  
    ("i" org-schedule  "set schedule")  
    ("q" nil "cancel")
 )
 #+END_SRC



*** org editing (C-M-o)

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "C-M-o")
 (defhydra hydra-org-edit (:color blue :hint nil :columns 4)
   "orgmode editing "
   ("t" org-insert-todo-heading-respect-content "insert TODO" )
   ("d" org-cut-subtree  "org cut" )
   ("y" org-copy-subtree "org copy" )
   ("p" org-paste-subtree  "org paste" )
   ("e" z/org-email-heading  "email header" )
   ("z" z/org-email-heading-me  "email header ikloog" )
   ("r" org-copy  "copy via refile" )
   ("h" org-set-line-headline "line to headline" )
   ("c" org-set-line-checkbox  "line to checkbox" )
   (";" z/org-cblock-comment  "line to checkbox" )
   ("s" hydra-org-time/body "time stamps" )
   ("w" worf-mode "Worf mode" )
   ("<up>" org-move-subtree-up "header up" :color red )
   ("<down>" org-move-subtree-down "header down" :color red)
   ("q" nil "cancel")))

#+END_SRC

(define-key evil-normal-state-map (kbd "]h") 'org-metaright)
(define-key evil-normal-state-map (kbd "[h") 'org-metaleft)
(define-key evil-normal-state-map (kbd "]j") 'org-metadown)
(define-key evil-normal-state-map (kbd "[j") 'org-metaup)
(define-key evil-normal-state-map (kbd "]k") 'outline-demote)
(define-key evil-normal-state-map (kbd "[k") 'outline-promote)
(define-key evil-normal-state-map (kbd "]o") 'outline-next-visible-heading)
(define-key evil-normal-state-map (kbd "[o") 'outline-previous-visible-heading)
(define-key evil-normal-state-map (kbd "]t") 'outline-forward-same-level)
(define-key evil-normal-state-map (kbd "[t") 'outline-backward-same-level)
(define-key evil-normal-state-map (kbd "]b") 'org-next-block)
(define-key evil-normal-state-map (kbd "[b") 'org-previous-block)
(define-key evil-normal-state-map (kbd "]r") 'org-table-move-row-down)
(define-key evil-normal-state-map (kbd "[r") 'org-table-move-row-up)
(define-key evil-normal-state-map (kbd "]c") 'org-table-move-column-right)
(define-key evil-normal-state-map (kbd "[c") 'org-table-move-column-left)
(define-key evil-normal-state-map (kbd "]f") 'org-table-next-field)
(define-key evil-normal-state-map (kbd "[f") 'org-table-previous-field)
(define-key evil-normal-state-map (kbd "]l") 'org-next-link)
(define-key evil-normal-state-map (kbd "[l") 'org-previous-link)
(define-key evil-normal-state-map (kbd "]u") 'org-down-element)
(define-key evil-normal-state-map (kbd "[u") 'org-up-element)


*** agenda (F10)
**** org agenda main
     :PROPERTIES:
     :ID:       5d5567f8-9f16-4b76-adb6-8600ce16e2ec
     :END:
#+BEGIN_SRC emacs-lisp :results none
  (global-set-key
     (kbd "<f10>")
  (defhydra hydra-org-agenda (:color blue :hint nil :columns 4)
"AGENDA:
【SPACE//TAB】open//open-go item in side view 【F】will toggle follow mode for space/tab view
【A】Append another view 【/】 filter tag 【=】 filter regex 【|】 clean all filters
【v】Choose view 【f】forward in time 【b】back in time 【.】goto today 【j】 jump to date
【S-left//right】 change deadline 【k】 launch capture with date/task
【:】 set tags 【,】set priority (then choose) 【S-U/D/L/R】 change todo/pri 
【m,u,U...】 dired marking 【M-m】toggle marking 【B】 execute on marks via dispatcher 
"
      ("<f10>" z/org-agenda-calendar  "org agenda"  )
      ("c"  org-agenda-columns  "agenda columns" )
      ("t"    org-agenda-todo      "change todo")
      ("k"    org-agenda-kill      "delete C-k")
      ("m"    org-agenda-bulk-toggle  "bulk mark"  :color red ) 
      ("x"    org-agenda-bulk-action  "bulk exe")
      ("x"   org-agenda-archive      "archive ")
      ("w"   org-agenda-refile      "refile ")
      (":"   org-agenda-set-tags      "set tags ")
      (","   org-agenda-priority      "priority (S-UP/S-Dn to change as well ")
      ("s"   org-agenda-schedule      "schedule task ")
      ("d"   org-agenda-deadline      "deadline task ")
      ("p"   org-agenda-date-prompt      "prompt date ")
       ("q"     nil                          "cancel" )
  ))
#+END_SRC

*** TODOS  (F11)
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f11>")
   (defhydra hydra-buffer  (:color blue :hint nil :columns 4)
     "TODO commands "
     ("<f11>" org-agenda "org-agnda" )
     ("l" z/org-agenda-allan "Allan" )
     ("j" z/org-agenda-joel  "Joel"  )
     ("s"   z/org-agenda-search     "regex search")
     ("t"   z/org-agenda-search-todo     "regex search TODO")
      ("c"   z/org-agenda-cook      "cook")
     ("fa" (org-tags-view nil "Cuisine=\"American\"") "food-american" )
     ("fa" (org-tags-view nil "Cuisine=\"American\"") "food-american" )
     ("d" "")
     ("i" "" )
     ("c" ""  )
     ("k"  "" )
     ("n" "" )
     ("p" (org-agenda nil "w") "work+home"  )
     ("w" z/org-agenda-work  "Work"  )
     ("q" nil "cancel")))

#+END_SRC


*** hydra spliter
 #+BEGIN_SRC emacs-lisp :results none
; (require 'hydra-examples)
; (hydra-create "C-M-o" hydra-example-move-window-splitter)

; (hydra-create "C-M-o"
;   '(("h" hydra-move-splitter-left)
;     ("j" hydra-move-splitter-down)
;     ("k" hydra-move-splitter-up)
;     ("l" hydra-move-splitter-right)))
 #+END_SRC

*** yas (C-M-y)
*** rectangle 
#+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-rectangle (:color blue  :columns 6 :hint nil)
   "rectangle commands "
   ("1" rectangle-number-lines "rectangle lines" :color blue)
   ("q" nil "cancel"))
#+END_SRC
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "C-M-y")
 (defhydra hydra-yas ()
   "yas command "
   ("a" yas-activate-extra-mode "enable Emacs mode for yas" :color blue)
   ("n" yas-new-snippet "add new snippet" :color blue)
   ("v" yas-visit-snippet-file "visit" :color blue)
   ("i" yas-insert-snippet "insert_point" :color blue)
   ("r" yas-reload-all  "reload" :color blue)
   ("t" yas-tryout-snippet  "try snipet" :color blue)
   ("q" nil "cancel")))
#+END_SRC
*** org tables (C-M-t)
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "C-M-l")

(defhydra hydra-org-table (:color blue  :columns 6)
"【C-c +】 will sum a column and move to clip  【C-space】 blank field 【M-left/right】move column left/right  【M-S-left/right】kill/add column 
【M-up/down】 move row up/down 【M-S-down】 insert row  【M-S-up】 kill row
【|-】 will start a dashed line 【C-c +】 org sum 【C-c ?/}】 find/show out field info 
【@row$column】>>  @2$3 will mean 2nd row, 3rd column 
 $1..$3f  firtst three fields in the current row // @2$1..@4$3  6 fields between these two fields
FORUMLAS: 【C-c =】 insert formula 【C-c *】 recalculate formula  vmean/vsum 
【:=】insert formula directly >> :=vsum(@2$3..@32$3)
"
     ("i" org-table-insert-row  "insert row" :color blue) 
     ("y" org-table-copy-region  "copy" :color blue) 
     ("d" org-table-cut-region  "cut" :color blue) 
     ("p" org-table-paste-rectangle  "paste" :color blue) 
     ("s" org-table-sort-lines  "sort" :color blue) 
     ("c" org-table-create-or-convert-from-region  "convert" ) 
     ("w" quick-calc  "quick calc" ) 
   ("q" nil "cancel")))
#+END_SRC
*** Editing (C-M-e)
**** main editing command 

 #+BEGIN_SRC emacs-lisp :results none
   (global-set-key                         
    (kbd "C-M-e")
    (defhydra hydra-editing (:color blue :hint nil :columns 4)
      "editing command"
      ("e" hydra-edit-extra/body  "Extra editing commands")
      ("<up>" drag-stuff-up  "marked up" :color red)
      ("<down>" drag-stuff-down  "marked down" :color red)
      ;("<left>" drag-stuff-left  "marked left" :color red)
      ;("<right>" drag-stuff-right "marked right" :color red)
      ("p" duplicate-current-line-or-region  "duplicate" :color red)
      (";"  hydra-commenting/body  "comment!" )
      ("i"  hydra-editing-insert/body  "insert" )   
      ("f" flush-blank-line  "flush blank" )
      ("u" z-fix-characters "fix unicode" )
      ("g" google-search "google searh selected" )
      ("c" z/comment-box "comment box" )
      ("u" upcase-region  "upcase " )
      ("d" downcase-region  "downcase " )
      ("h" z/edit-copy-all-or-region  "copy buffer" )
      ("w" shrink-whitespace  "shrink-whitespace" )
      ("R" revert-buffer  "revert buffer before changes" ) 
      ("q" nil "cancel")))

 #+END_SRC
**** extra editing commands

 #+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-edit-extra (:color blue :hint nil )
      "
 fix _u_nicode issue  // u_p_case region // _d_owncase region 
      "
      ("u" z-fix-characters  "fix unicode" ) 
      ("p" upcase-region  "upcase region" ) 
      ("d" downcase-region  "downcase region" ) 
      ("f" toggle-fill-unfill  "fill/unfill")
      ("r" z-edit-file-as-root  "edit as root")
      ("q" nil "cancel" nil)
      ("1" z/regex-delete-numeric "delete numbers")
 )

 #+END_SRC

**** commenting sub hydra 

#+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-commenting (:color blue  )
     "
comment  _;_ // comment _t_o line // comment para_g_raph // co_p_y-paste-comment 
comment _e_macs function  // copy-paste-comment-function _r_  

     "
     (";" evilnc-comment-or-uncomment-lines  "comment" ) 
     ("t" evilnc-quick-comment-or-uncomment-to-the-line   "c 2 line"  nil ) 
     ("g" evilnc-comment-or-uncomment-paragraphs  "c paragraph"  nil ) 
     ("p" evilnc-copy-and-comment-lines  "c,c,p"  nil ) 
     ("e" z/comment-line  "comment-line-emacsfun" :color blue)
     ("r" z/copy-comment-paste  "c,c,p-fun " :color blue)
     ("q" nil "cancel" nil)
)

#+END_SRC

**** hydra-editing-insert (insert Unicode)
add the org faces macros here (%Tip%, $Note$ etc)

#+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-editing-insert (:color blue)
  "unicode"
  ("k"     z/insert-black-lenticular-bracket  "【】") 
  ("b"     z/insert-bashscript  "insert basg #!") 
  ("p"     z/insert-play  " ‣") 
  ("o"     z/insert-EOL  " \\") 
  ("r"    z/insert-reveal-split  "reveal-split") 
  ("q" nil "cancel" nil)
)
#+END_SRC
*** password-store (C-M-p)
**** main editing command 
 #+BEGIN_SRC emacs-lisp :results none
   (global-set-key                         
    (kbd "C-M-p")
    (defhydra hydra-password-store (:color blue :columns 4 :hint nil)
      "password store command"
      ("e" password-store-edit   "edit pass" )
      ("d" password-store-remove   "delete pass" )
      ("q" nil "cancel")))

 #+END_SRC
*** ace (C-M;)
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "C-M-;")
 (defhydra hydra-avi ()
   "yas command "
   ("g" avi-goto-char-2 "avi-goto-char-2" :color blue)
   ("c" avi-goto-char "avi-goto-char" :color blue)
   ("l" avi-goto-line "avi-goto-line" :color blue)
   ("4" avi-copy-line  "avi-copy-line" :color blue)
   ("3" avi-move-line  "avi-move-line" :color blue)
   ("r" avi-copy-region  "avi-copy-region" :color blue)
   ("a" avi-goto-word-1  "avi-goto-word-1" :color blue)
   ("v" avi-goto-word-0  "avi-goto-word-0" :color blue)
   ("z" ace-jump-zap  "zap text" :color blue)
   ("q" nil "cancel")))
#+END_SRC

*** windows (F12)

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "<f12>")
 (defhydra hydra-window (:color blue :hint nil :columns 5)
 "Window and buffer Operations"
   ("<f12>" switch-to-previous-buffer  "last buffer"  )
   ("<f11>" ace-delete-window "delete window")
   ("<home>" ace-window "ace-window//also M-1" :exit t)   
   ("=" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right))
        "Split Vertical (|)")
   ("-" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down))
        "Split horzizontal (-)")
   ("<left>" hydra-move-splitter-left "resize left"  :color red)
   ("<right>" hydra-move-splitter-right "resize right"  :color red)
   ("<up>" hydra-move-splitter-up "resize up"  :color red)
   ("<down>" hydra-move-splitter-down "resize down"  :color red)
   ("t" ace-swap-window  "transpose (ace-swap)")
   ("i" ace-maximize-window "ace-one" )
   ("r" resize-window "resize menu" )
   ;;Note winer mode must be enabled
   ("u" winner-undo "winner undo")
   ("s" save-buffer "save buffer"  )
   ("a" write-file  "save as.."  )
   ("x" kill-this-buffer "kill buffer"  )
   ("c" z-save-buffer-close-window "save and close"  )
   ("n" next-user-buffer  "next buffer" )
   ("p" previous-user-buffer "prev buffer"  )
   ("N" next-emacs-buffer "next Emacs  buffer"  )
   ("P" previous-emacs-buffer "prev emacs buffer"  )
   ("da" ace-delete-window)
   ("db" kill-this-buffer)
   ("df" delete-frame "delete frame")
   ("kw" delete-window "delete window")
   ("ka" delete-other-windows "delete all other  windows")
   ("kh" kill-buffer "helm kill buffer" )
   ("kb" z-kill-other-buffers "kill all but current" )
   ("q" nil "cancel")))

#+END_SRC
*** hydra goto
pop-global-mark this will move you to prev position 

#+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-goto  (:color blue :hint nil :columns 5)
  "goto"
  ("g" goto-line "line")
  ("c" goto-char "char")
  ("o" ace-link-org "goto org link")
  ("2" er/expand-region "expand")
  ("q" nil "quit"))
#+END_SRC
(global-set-key (kbd "<f3> o") 'back-button-global)

*** TODO vim

#+BEGIN_SRC emacs-lisp :results none
  (defhydra hydra-vi (:body-pre hydra-vi/pre
                      :color    amaranth)
    "vi"
    ;; basic navigation
    ("l"        forward-char                  nil)
    ("h"        backward-char                 nil)
    ("j"        next-line                     nil)
    ("k"        previous-line                 nil)
    ;; mark
    ("m"        set-mark-command              "mark")
    ("C-o"      (set-mark-command 4)          "jump to prev location")
    ;; beginning/end of line
    ("a"        back-to-indentation-or-beginning-of-line "beg of line/indentation")
    ("^"        back-to-indentation-or-beginning-of-line "beg of line/indentation")
    ("$"        move-end-of-line              "end of line")
    ;; word navigation
    ("e"        forward-word                  "end of word")
    ("w"        modi/forward-word-begin       "beg of next word")
    ("b"        backward-word                 "beg of word")
    ;; page scrolling
    ("<prior>"  scroll-down-command           "page up")
    ("<next>"   scroll-up-command             "page down")
    ;; delete/cut/copy/paste
    ("x"        delete-forward-char           "del char")
    ("d"        my/iregister-cut              "cut/del")
    ("D"                 "cut/del line")
    ("y"        my/iregister-copy             "copy")
    ("p"        yank                          "paste")
    ;; beginning/end of buffer and go to line
    ("g"        hydra-vi/beginning-of-buffer  "beg of buffer/goto line")
    ("G"        hydra-vi/end-of-buffer        "end of buffer/goto line")
    ("<return>" goto-line                     "goto line")
    ;; undo/redo
    ("u"        undo-tree-undo                "undo")
    ("C-r"      undo-tree-redo                "redo")
    ;; misc
    ("<SPC>"    ace-jump-mode                 "ace jump")
    ;; exit points
    ("q"        hydra-vi/post                 "cancel" :color blue))

#+END_SRC


* Macros
** org faces
*** general
#+BEGIN_SRC emacs-lisp :results none
(fset 'orgstyle-tnote
   [?! home ?!])
(define-key org-mode-map (kbd "C-1") 'orgstyle-tnote)


(fset 'orgstyle-warning
   "@\341@WARNING:")
(define-key org-mode-map (kbd "C-2") 'orgstyle-warning)

(fset 'orgstyle-warning2
   [?@ home ?@])
(define-key org-mode-map (kbd "C-S-2") 'orgstyle-warning2)



(fset 'orgstyle-com1
   [?~ home ?~])
(define-key org-mode-map (kbd "C-3") 'orgstyle-com1)

(fset 'orgstyle-note
   "$\341$NOTE:")
(define-key org-mode-map (kbd "C-4") 'orgstyle-note)

(fset 'orgstyle-note2
   [?$ home ?$])
(define-key org-mode-map (kbd "C-S-4") 'orgstyle-note2)

(fset 'orgstyle-tip
   "%\341%TIP:")
(define-key org-mode-map (kbd "C-5") 'orgstyle-tip)


(fset 'orgstyle-tip2
   [?% home ?%])
(define-key org-mode-map (kbd "C-S-5") 'orgstyle-tip2)


(fset 'orgstyle-code
   [?^ home ?^])
(define-key org-mode-map (kbd "C-6") 'orgstyle-code)

(fset 'orgstyle-header
   [?& home ?&])
(define-key org-mode-map (kbd "C-7") 'orgstyle-header)

(fset 'orgstyle-bold
   [?* home ?*])
(define-key org-mode-map (kbd "C-7") 'orgstyle-bold)

(fset 'orgstyle-highlight-green
   [?' home ?'])
(define-key org-mode-map (kbd "C-9") 'orgstyle-highlight-green)

(fset 'orgstyle-com2
   [?` home ?`])
(define-key org-mode-map (kbd "C-0") 'orgstyle-com2)

(fset 'underline_net_delete
   [?\M-% ?\  return return ?!])

#+END_SRC

** Editing
*** lines not paragraphs
#+BEGIN_SRC emacs-lisp :results none
;;;; Saved macros
;; Saved macro - adds latex end-lines to verse passages
(fset 'versify
      [?\C-a ?\C-e ?\\ ?\\ down])

;(global-set-key (kbd "") 'versify)
#+END_SRC

** prefix macro
#+BEGIN_SRC emacs-lisp :results none
(defmacro C-u (&rest args)
  (let ((prefix (list 4)))
    (while (cdr args)
      (cond
       ((eq (car args) 'C-u)
        (setf (car prefix) (* 4 (car prefix))))
       ((eq (car args) 'M-x)
        ;; ignore
        t)
       (t
        (error "Unknown arg %S" (car args))))
      (setq args (cdr args)))
    (unless (functionp (car args))
      (error "%S is not a function" (car args)))
    `(lambda ()
       (interactive)
       (let ((current-prefix-arg ',prefix))
         (call-interactively ',(car args))))))
#+END_SRC
** mu4e
*** delete and exe
#+BEGIN_SRC emacs-lisp :results none
(fset 'del_exe_mu4e
   [?d ?x ?y ])

#+END_SRC

* Settings
  :PROPERTIES:
  :ID:       0991546e-92b4-42d3-9b99-d3c639d2d5f8
  :END:
** XDG/open with 
*** set emacs browser
#+BEGIN_SRC emacs-lisp :results none
(setq browse-url-browser-function (quote browse-url-generic))
(setq browse-url-generic-program "chromium")
#+END_SRC
** Backup
Auto-backup is triggered when you save a file - it will keep the old version of the file around, adding a ~ to its name. 
auto-save-mode auto-saves a file every few seconds 
here we put these files in the /tmp dir

#+BEGIN_SRC emacs-lisp :results none
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+END_SRC

** Save and sessions
#+BEGIN_SRC emacs-lisp :results none
;If I reopen a file, I want to start at the line at which I was when I closed it.
; save the place in files
(require 'saveplace)
(setq-default save-place t)

; save minibuffer history
(require 'savehist)

(setq savehist-additional-variables '(search-ring
                                      regexp-search-ring
                                      file-name-history
                                      extended-command-history
                                      kill-ring
                                      sr-history-registry
                                        ))

;;autosave
;(setq auto-save-visited-file-name t)
;(setq auto-save-interval 20) ; twenty keystrokes
(setq auto-save-timeout 60) ; ten idle seconds

(savehist-mode t)

#+END_SRC

** history

#+BEGIN_SRC emacs-lisp :results none
(setq savehist-file "/home/zeltak/.emacs.t/hist.txt")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC

** recentf

$note its built into emacs no intsall needed$

#+BEGIN_SRC emacs-lisp :results none
(setq recentf-save-file "/home/zeltak/.emacs.t/recentf")  ;; (setq recentf-auto-cleanup 'never) ;; disable before we start recentf!
(require 'recentf)
(recentf-mode 1)
(setq recentf-max-menu-items 50)
;(setq recentf-auto-cleanup 'never) ;; disable before we start recentf!
#+END_SRC

** Remote
*** ssh
#+BEGIN_SRC emacs-lisp :results none
(require 'tramp) ; Remote file editing via ssh
(setq tramp-default-method "ssh")
#+END_SRC
** TERM
*** set default term zshrc
#+BEGIN_SRC emacs-lisp :results none
(setq explicit-shell-file-name "/bin/zsh")
#+END_SRC
** performance improvement
#+BEGIN_SRC emacs-lisp :results none
(setq cache-long-scans nil)
#+END_SRC
** Editing
*** spelling
#+begin_src emacs-lisp results none
;Spelling
(autoload 'flyspell-mode "flyspell" "On-the-fly spelling checker." t)
(autoload 'flyspell-delay-command "flyspell" "Delay on command." t)
(autoload 'tex-mode-flyspell-verify "flyspell" "" t) 


(defun flyspell-check-next-highlighted-word ()
  "custom function to spell check next highlighted word"
  (interactive)
  (flyspell-goto-next-error)
  (ispell-word)
  )

#+end_src
*** warn on large files
set currently to 100mb
#+BEGIN_SRC emacs-lisp :results none
;; warn when opening files bigger than 100MB
(setq large-file-warning-threshold 100000000)
#+END_SRC
* Org
** Base
*** org base configs
**** define org mode locations for all operations
#+BEGIN_SRC emacs-lisp :results none
(setq org-directory "~/org/files/")
(setq org-default-notes-file "~/org/files/refile.org")
#+END_SRC 
**** main configs
#+BEGIN_SRC emacs-lisp :results none
;associate these files with org

(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))

;make new headings appear after the content for the current one
(setq org-insert-heading-respect-content t)

;allow RETURN to open links
(setq org-return-follows-link nil)
;going to the beginning and end of the heading instead of the current line
(setq org-special-ctrl-a/e t)
;rebind certain one-letter keybindings when the cursor is at the beginning of the row - most notably ‘t’ for org-todo instead of ‘C-c C-t’
(setq org-startup-align-all-tables t)
(setq org-archive-location (concat org-directory "archive/%s_archive::"))
(setq org-attach-store-link-p)
;to make ido mode work in org mode as wel
(setq org-completion-use-ido t)
;allow speedkeys
(setq org-use-speed-commands t)
(setq org-speed-commands-user nil)
(setq org-src-fontify-natively t);; syntax highlighting the source code
 

#+END_SRC
*** add time stamp on every org header
    :PROPERTIES:
    :LAST-EDITED: [03-08-2015(20:57)]
    :END:
this will update when the header text will change

#+BEGIN_SRC emacs-lisp
  ;;   (defun update-last-edited (beg end length)
  ;;     (when
  ;;         (and
  ;;          (not (org-before-first-heading-p))
  ;;          (org-get-heading))
  ;;       (org-entry-put nil "LAST-EDITED" (format-time-string "[%d-%m-%Y(%H:%M)]"))))

  ;; (add-hook 'org-mode-hook (lambda ()
  ;; (add-to-list 'after-change-functions 'update-last-edited))) 
#+END_SRC

*** Save all org buffers every hour
    :PROPERTIES:
    :LAST-EDITED: [02-08-2015(21:32)]
    :END:

#+BEGIN_SRC emacs-lisp :results none
(run-at-time "00:59" 3600 'org-save-all-org-buffers)
#+END_SRC 

*** linium mode and flyspell
#+begin_src emacs-lisp
;enable flyspelll
(add-hook 'org-mode-hook  
          (lambda ()      
            (flyspell-mode)))

;;disable linemode on org
(defun my-org-mode-hook () 
  (linum-mode 0)) 
(add-hook 'org-mode-hook 'my-org-mode-hook)
#+end_src
*** make default notes read-only
#+BEGIN_SRC emacs-lisp :results none
;(add-hook 'org-mode-hook (lambda () (view-mode 1)))
#+END_SRC
*** make org mode read-only after 5 minutes @may cause wierd issues@

@Warning- this may cause strange behviour@

#+begin_src emacs-lisp :results none
  ;; (defvar tj/last-buffer-tick nil)
  ;; (make-variable-buffer-local 'tj/last-buffer-tick)
  
  ;; (defun tj/new-buffer-ticks-p ()
  ;;   (let ((curr-tick (buffer-modified-tick))
  ;;         (last-tick tj/last-buffer-tick))
  ;;     (setq tj/last-buffer-tick curr-tick)
  ;;     (and last-tick (= last-tick curr-tick))))
  
  ;; (defun tj/reset-view-mode ()
  ;;   (run-with-timer 0 (* 5 60)
  ;;                   (lambda ()
  ;;                     (when (tj/new-buffer-ticks-p)
  ;;                       (view-mode t)))))
  
  ;; (add-hook 'org-mode-hook 'tj/reset-view-mode)
#+end_src

*** enable shift selection 

use setq org-support-shift-select:

'always- to always use it
'nil- to disable on org mode
't- for When outside special context

#+BEGIN_SRC emacs-lisp :results none
(setq org-support-shift-select 't)
#+END_SRC

*** Header behavior
#+BEGIN_SRC emacs-lisp :results none
;; when creating new headers make sure there isn't a space
(setq org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))
;;;this will make sure there are no empty lines betwwn headers after collapsing headers 
(setq org-cycle-separator-lines 0) 
#+END_SRC 
** custom link types
*** grep link
#+BEGIN_SRC emacs-lisp :results none
(org-add-link-type
 "grep"
 (defun endless/follow-grep-link (regexp)
   "Run `rgrep' with REGEXP as argument."
   (grep-compute-defaults)
   (rgrep regexp "*" (expand-file-name "./"))))
#+END_SRC 
*** dired links
#+BEGIN_SRC emacs-lisp :results none
  (org-add-link-type "file+emacs+dired" 'org-open-file-with-emacs-dired)
  (add-hook 'org-store-link-functions 'org-dired-store-link)

  (defun org-open-file-with-emacs-dired (path)
    "Open in dired."
    (let ((d (file-name-directory path))
          (f (file-name-nondirectory path)))
      (dired d)
      (goto-char (point-min))
      (search-forward f nil t)))

  (defun org-dired-store-link ()
    "Store link to files/directories from dired."
    (require 'dired+)
    (when (eq major-mode 'dired-mode)
      (let ((f (dired-get-filename)))
        (setq link (concat "file+emacs+dired" ":" f)
              desc (concat f " (dired)"))
        (org-add-link-props :link link :description desc)
        link)))
#+end_src

*** org link open with
#+BEGIN_SRC emacs-lisp :results none
(eval-after-load "org"
  (lambda ()
    (if (assoc "\\.avi\\'" org-file-apps)
	(setcdr (assoc "\\.avi\\'" org-file-apps) "vlc %s")
      (add-to-list 'org-file-apps '("\\.avi\\'" . "vlc %s") t))
    (if (assoc "\\.mp4\\'" org-file-apps)
	(setcdr (assoc "\\.mp4\\'" org-file-apps) "vlc %s")
      (add-to-list 'org-file-apps '("\\.mp4\\'" . "vlc %s") t))))

#+END_SRC

*** insert id based links
this will make org-store-link use id when creating a link.
#+BEGIN_SRC emacs-lisp :results none
(require 'org-id)
(setq org-id-link-to-org-use-id t)
;; Use global IDs
;; Update ID file .org-id-locations on startup
(org-id-update-id-locations)
 #+END_SRC

** loading on startup
*** org moduls

#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'org-modules "org-habit")
#+END_SRC

** Agenda
*** set agenda location
#+BEGIN_SRC emacs-lisp :results none
(setq org-agenda-files '("~/org/files/agenda/"))
#+END_SRC
*** agenda popup behivour
#+BEGIN_SRC emacs-lisp :results none
(setq org-agenda-window-setup "current-window")
(setq org-agenda-restore-windows-after-quit t)
#+END_SRC

*** agenda view
#+BEGIN_SRC emacs-lisp :results none
;change agenda colors
;(setq org-upcoming-deadline '(:foreground "blue" :weight bold))
;max days to show in agenda view
(setq org-agenda-ndays 7)
;start agenda from today!
(setq org-agenda-start-on-weekday nil)
;Items that have deadlines are displayed 10 days in advance
(setq org-deadline-warning-days 10)
;don’t display items that are done in my agenda.
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-span 14)
#+END_SRC

*** look and feel

#+BEGIN_SRC emacs-lisp :results none
;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)
;; Compact the block agenda view
(setq org-agenda-compact-blocks t)
;; Always hilight the current agenda line
(add-hook 'org-agenda-mode-hook
          '(lambda () (hl-line-mode 1))
          'append)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;;  Enable display of the time grid so we can see the marker for the current time
(setq org-agenda-time-grid (quote ((daily today remove-match)
                                  #("----------------" 0 16 (org-heading t))
                                  (0900 1100 1300 1500 1700))))

;; Display tags farther right
(setq org-agenda-tags-column -102)
#+END_SRC

*** specific sparse trees 
***** breakfeast
#+BEGIN_SRC emacs-lisp :results none
  (defun cooking-sparse-tree-breakfeast ()
    (interactive)
    (org-match-sparse-tree t "+TODO=\"COOK\"+Type=\"breakfest\""))

  (defun cooking-sparse-tree-main ()
    (interactive)
    (org-match-sparse-tree t "+TODO=\"COOK\"+Type=\"main\""))

  (defun cooking-sparse-tree-sweet ()
    (interactive)
    (org-match-sparse-tree t "+TODO=\"COOK\"+Type=\"sweet\""))

  (defun cooking-sparse-tree-meat ()
    (interactive)
    (org-match-sparse-tree t "+TODO=\"COOK\"+Type=\"meat\""))

  (defun cooking-sparse-tree-fav ()
    (interactive)
    (org-match-sparse-tree t "+Fav=\"y\""))

#+end_src

*** export agenda
#+BEGIN_SRC emacs-lisp :results none
          (setq org-agenda-exporter-settings
                '((ps-number-of-columns 2)
                  (ps-landscape-mode t)
                  (org-agenda-add-entry-text-maxlines 5)
                  (htmlize-output-type 'css)))
#+END_SRC
*** habits
#+BEGIN_SRC emacs-lisp :results none
(setq org-habit-graph-column 70)
(setq org-habit-show-habits-only-for-today nil)
#+END_SRC

*** get popups for meetings
#+BEGIN_SRC emacs-lisp
 (appt-activate 1)
 (org-agenda-to-appt)
#+END_SRC

thos  will be reminded of things in your org files, before the appointment time (I think 12 min is the default)
You could also add this, so that the appointments refresh and new get added every time that you call the agenda:

#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-finalize-hook (lambda ()  (org-agenda-to-appt t)))
#+END_SRC
*** Sorting by date and priority

#+BEGIN_SRC emacs-lisp :results none
(setq org-agenda-sorting-strategy
      '((agenda time-up priority-down tag-up effort-up category-keep)
        (todo user-defined-up todo-state-up priority-down effort-up)
        (tags user-defined-up)
        (search category-keep)))
(setq org-agenda-cmp-user-defined 'my/org-sort-agenda-items-user-defined)
(require 'cl)
(defun my/org-get-context (txt)
  "Find the context."
  (car (member-if
        (lambda (item) (string-match "@" item))
        (get-text-property 1 'tags txt))))

(defun my/org-compare-dates (a b)
  "Return 1 if A should go after B, -1 if B should go after A, or 0 if a = b."
  (cond
   ((and (= a 0) (= b 0)) nil)
   ((= a 0) 1)
   ((= b 0) -1)
   ((> a b) 1)
   ((< a b) -1)
   (t nil)))

(defun my/org-complete-cmp (a b)
  (let* ((state-a (or (get-text-property 1 'todo-state a) ""))
         (state-b (or (get-text-property 1 'todo-state b) "")))
    (or
     (if (member state-a org-done-keywords-for-agenda) 1)
     (if (member state-b org-done-keywords-for-agenda) -1))))

(defun my/org-date-cmp (a b)
  (let* ((sched-a (or (get-text-property 1 'org-scheduled a) 0))
         (sched-b (or (get-text-property 1 'org-scheduled b) 0))
         (deadline-a (or (get-text-property 1 'org-deadline a) 0))
         (deadline-b (or (get-text-property 1 'org-deadline b) 0)))
    (or
     (my/org-compare-dates
      (my/org-min-date sched-a deadline-a)
      (my/org-min-date sched-b deadline-b)))))

(defun my/org-min-date (a b)
  "Return the smaller of A or B, except for 0."
  (funcall (if (and (> a 0) (> b 0)) 'min 'max) a b))

(defun my/org-sort-agenda-items-user-defined (a b)
  ;; compare by deadline, then scheduled date; done tasks are listed at the very bottom
  (or
   (my/org-complete-cmp a b)
   (my/org-date-cmp a b)))

(defun my/org-context-cmp (a b)
  "Compare CONTEXT-A and CONTEXT-B."
  (let ((context-a (my/org-get-context a))
        (context-b (my/org-get-context b)))
    (cond
     ((null context-a) +1)
     ((null context-b) -1)
     ((string< context-a context-b) -1)
     ((string< context-b context-a) +1)
     (t nil))))

(defun my/org-sort-agenda-items-todo (a b)
  (or
   (org-cmp-time a b)
   (my/org-complete-cmp a b)
   (my/org-context-cmp a b)
   (my/org-date-cmp a b)
   (org-cmp-todo-state a b)
   (org-cmp-priority a b)
   (org-cmp-effort a b)))
#+END_SRC

** 'my custom agenda command'
   :PROPERTIES:
   :ID:       4b396dfc-0c1c-407c-9d2d-6cca29c8879c
   :END:
look here for more info
http://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html

and here id:cf2c69b4-3d4c-4f81-a01d-bbbe1d120e62

$Note$ that to get the priorities to appear first you need to use priorities-down.

("w" tags-todo "CATEGORY=\"work\"")


(org-agenda-view-columns-initially t)

 will start the view in a column view

also the headers can be customized

(org-columns-default-format "%50ITEM %TODO %3PRIORITY %Effort{:} %TAGS")

-sorting:
(org-agenda-sorting-strategy '(priority-down  tag-up ))

@add@- deadline column , time column to agenda column view

#+BEGIN_SRC emacs-lisp :results none
(setq org-agenda-custom-commands 
'(

;;TODO sparse tree
("O" occur-tree "TODO")


 ("D" "Timeline for today" ((agenda "" ))
           ((org-agenda-ndays 1)
            ;;(org-agenda-show-log t)
           ;; (org-agenda-log-mode-items '(clock closed))
            (org-agenda-entry-types '())))





;;;;;ALL

;all common tasks (from research|bgu|home files)
("p" "all" todo "TODO|BGU|EXP" 
(
(org-agenda-files (list "~/org/files/agenda/Research.org"  "~/org/files/agenda/bgu.org" "~/org/files/agenda/home.org" ))
(org-agenda-sorting-strategy '(priority-down effort-down deadline-up))
 (org-agenda-cmp-user-defined 'my/org-sort-agenda-items-todo)
(org-columns-default-format "%50ITEM %TODO %10PRIORITY %20DEADLINE %TAGS")
))



;;;;;;;WORK;;;;;;;;;;;;;;;;;;;;;;

;work related only tasks (from research|bgu files)
("w" "work" todo "TODO|BGU|EXP" 
(
(org-agenda-files (list "~/org/files/agenda/Research.org"  "~/org/files/agenda/bgu.org" ))
;(org-agenda-sorting-strategy '(priority-down effort-down))
(org-agenda-view-columns-initially t)
;;(org-agenda-sorting-strategy '(priority-down  tag-up ))

))
         
;;;;;;;;;;;Allan;;;;;;;;;;;;;;;;;;;;
;;custom sparse tree
("L" occur-tree "allan")

; allan todos
("l" "allan tasks" tags-todo "allan"
(
(org-agenda-files (list "~/org/files/agenda/Research.org"  "~/org/files/agenda/bgu.org"))
(org-agenda-sorting-strategy '(priority-down effort-down))
))


;;;;;;;;;Joel;;;;;;;;;;;;;;;;
("j" "joel tasks" tags-todo "joel"
(
(org-agenda-files (list "~/org/files/agenda/Research.org"  "~/org/files/agenda/bgu.org"))
(org-agenda-sorting-strategy '(priority-down effort-down))
))

;;custom sparse tree
("J" occur-tree "joel")



;;;;;;;;;;;;;COOKING;;;;;;;;;;;

("f" . "Food commands")


("fb" "food" todo "COOK" 
         (
    (org-agenda-files '("~/org/files/agenda/food.org")) 
    (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
))


("fd" "cook dessert" tags-todo "dessert" 
         (
    (org-agenda-files '("~/org/files/agenda/food.org")) 
    (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
))


("fp" "protein" tags-todo "protein" 
         (
    (org-agenda-files '("~/org/files/agenda/food.org")) 
    (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
))

("fo" "soup" tags-todo "soup" 
         (
    (org-agenda-files '("~/org/files/agenda/food.org")) 
    (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
))


("fs" "side" tags-todo "side" 
         (
    (org-agenda-files '("~/org/files/agenda/food.org")) 
    (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
))


("fb" "breakfest" tags-todo "breakfest" 
         (
    (org-agenda-files '("~/org/files/agenda/food.org")) 
    (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
))


("fk" "drink" tags-todo "drink" 
         (
    (org-agenda-files '("~/org/files/agenda/food.org")) 
    (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
))

("fl" "salad" tags-todo "salad" 
         (
    (org-agenda-files '("~/org/files/agenda/food.org")) 
    (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
))




;;;;;;;;;;;;;COOKING;;;;;;;;;;;
("fc" "to cook"  tags "Cuisine=\"American\""
          (
         (org-agenda-files '("~/org/files/agenda/food.org")) 
    (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.

))







;;;;;;;;;;;;;;;;;TECH;;;;;;;;;;;;;;
("c" "tech" todo "TODO" 
         (
         (org-agenda-files '("~/org/files/agenda/TODO.org")) 
          (org-agenda-sorting-strategy 
          '(priority-up effort-down)
)
)
)

;;;;;;;;;;;;;;;;;HOME;;;;;;;;;;;;;;;;


("h" "home" todo "TODO" 
         (
         (org-agenda-files '("~/org/files/agenda/home.org")) 
          (org-agenda-sorting-strategy 
          '(priority-up effort-down)
)
)
)


("x" "Agenda and Home-related tasks"
               (
               (agenda "")
               (tags-todo "+PRIORITY=\"A\"")
               (tags "garden")
)
)



;;end brackets for setq
)
)

#+END_SRC

** Images
*** base
**** inline images by default at startup
#+begin_src emacs-lisp :results none
;;iimage in org (display images in org files)
(setq org-startup-with-inline-images t)
#+end_src
**** size defaults @Warning- this may screw up image config@ 

#+BEGIN_SRC emacs-lisp :results none
;;set the org image default size
;(setq org-image-actual-width nil)
(setq org-image-actual-width '(400))

#+END_SRC
** Tags
*** tag inheritance
make sure child headers don't get the header tags

#+BEGIN_SRC emacs-lisp :results none
(setq org-use-tag-inheritance nil)
#+END_SRC

*** org-tag-faces
#+begin_src emacs-lisp results none
  ;; (setq org-tag-faces
  ;;   '(("Indian" . (:foreground "#00000"))
  ;;      ("Asian"  . (:foreground "#C00000"))
  ;;      ("israeli"  . (:foreground "#C0a000"))))
#+end_src


*** tag searches function  
    :PROPERTIES:
    :ID:       c1e25ca7-8cbd-4bd8-b417-3ac09c61474b
    :END:
#+BEGIN_SRC emacs-lisp :results none
(org-add-link-type
 "tag"
 (defun endless/follow-tag-link (tag)
   "Display a list of TODO headlines with tag TAG.
With prefix argument, also display headlines without a TODO keyword."
   (org-tags-view (null current-prefix-arg) tag)))
#+END_SRC
** Todo
*** org todo config
#+BEGIN_SRC emacs-lisp :results none
;allow fast todo
(setq org-use-fast-todo-selection t)
;allow shift-left right to change todo state
(setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC
*** todo keywords
#+begin_src emacs-lisp :results none
(setq org-todo-keywords
      (quote ((sequence "TODO(t)"  "|" "DONE(d)")
              (sequence "TASK(f)" "|" "DONE(d)")
)))
(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("TASK" :foreground "magenta" :weight bold)
              ("NEXT" :foreground "blue" :weight bold)
              ("PAUSED" :foreground "gray" :weight bold)
              ("SUBMITTED" :foreground "#FFC612" :weight bold)
              ("K_TRACK" :foreground "#45D0FF" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("PUB" :foreground "#00FF37" :weight bold)
              ("PREP" :foreground "#FF7BD0" :weight bold)
              ("SUB" :foreground "#CE008B" :weight bold)
              ("COOK" :background "#0CFB32" :foreground "#001F57" :weight bold)
              ("SHOP" :background "#9CFFBB" :foreground "#004D18" :weight bold)
              )))
#+end_src


*** auto add tags						  :CANCELLED:
#+BEGIN_SRC emacs-lisp :results none
(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
              ("WAITING" ("WAITING" . t))
              ("HOLD" ("WAITING" . t) ("HOLD" . t))
              (done ("WAITING") ("HOLD"))
              ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
              ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
              ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
#+END_SRC
*** priorities
**** TODO This can mess up the sort order in org-agenda-sorting-strategy and thus its commented out
 #+BEGIN_SRC emacs-lisp :results none
   ;; ;;set priority range from A to C with default A
   ;; (setq org-highest-priority ?A)
   ;; (setq org-lowest-priority ?C)
   ;; (setq org-default-priority ?A)

 #+END_SRC
**** colours for priorities
#+BEGIN_SRC emacs-lisp
(setq org-priority-faces '((?A . (:foreground "#F0DFAF" :weight bold))
                           (?B . (:foreground "LightSteelBlue"))
                           (?C . (:foreground "OliveDrab"))))
#+END_SRC

** Refile
*** set which refile method to us (currently helm)
this command below will use helm for completion since in the above helm config we sepcify these two commands: (require 'helm-config) and (helm-mode 1)
#+BEGIN_SRC emacs-lisp :results none
(setq org-outline-path-complete-in-steps nil)
#+END_SRC
*** settings for paths and headers shown
#+BEGIN_SRC emacs-lisp :results none
;;list everything instead of stepping through each level gradually
(setq org-outline-path-complete-in-steps nil)
;; Refile on top of file max
(setq org-refile-use-outline-path 'file )
#+END_SRC
*** set heading depth
set how many levels of headers to show while refiling 
#+begin_src emacs-lisp results none
; Targets include this file and any file contributing to the agenda - up to 9 levels deep
(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))))
#+end_src

#+RESULTS:

** Capture
*** load org-protocl and org-capture
#+BEGIN_SRC emacs-lisp :results none
(require 'org-protocol)
(require 'org-capture)
#+END_SRC
*** make org take up 1 frame
    :PROPERTIES:
    :ID:       14e63bf0-0966-4074-98af-bdce51a5f2d4
    :END:
#+BEGIN_SRC emacs-lisp :results none
  ;; (defadvice org-capture (around bp/org-capture--around)
  ;;   (flet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
  ;;     ad-do-it))
  ;; (ad-activate 'org-capture)

#+END_SRC

#+BEGIN_SRC emacs-lisp :results none

(defadvice org-capture
    (after make-full-window-frame activate)
  "Advise capture to be the only window when used as a popup"
  (if (equal "emacs-capture" (frame-parameter nil 'name))
      (delete-other-windows)))

(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame"
  (if (equal "emacs-capture" (frame-parameter nil 'name))
      (delete-frame)))
#+END_SRC

*** make C-c x close and save frame
#+BEGIN_SRC emacs-lisp :results none
  ;; (defun my-capture-finalize ()
  ;;   (interactive)
  ;;   (org-capture-finalize)
  ;;   (delete-frame))

  ;; (add-hook 'org-capture-mode-hook
  ;;           (lambda ()
  ;;             (define-key org-capture-mode-map "\C-c\C-x" (function my-capture-finalize))))
  ;; ((lambda nil (define-key org-capture-mode-map "" (function my-capture-finalize))))
#+END_SRC
** TODO Capture templates
    :PROPERTIES:
    :ID:       2bf19d27-a0af-4e4c-91f1-9723a2dedf18
    :END:
#+BEGIN_SRC emacs-lisp :results none
 (setq org-capture-templates
          (quote ( 


;;; email

;;;; wanderlust

;("e" "Email Todo" entry (file+headline "~/org/files/agenda/bgu.org" "TD")
;                              "* TODO %a\n%?Added: %U\nDEADLINE: %^t\n" :prepend t)



("e" "Email Todo" entry (file+headline "~/org/files/agenda/bgu.org" "TD")
                             "* TODO Read Message%? (%:fromname about %:subject)\nAdded:%U\n%a\nDEADLINE: %^t")




;;;;; food
;; define food group

("f" "Food")

;;;; new recipe Inbox
("ff" "new recipe" entry (file+headline "/home/zeltak/org/files/agenda/food.org" "Inbox")
"* COOK %^{Recipe Name} %^g     
    :PROPERTIES:
    :ID: %(org-id-uuid)
    :Time: %^{minutes|-|10|15|30|60}
    :Rating: %^{rating?|-|1|2|3|4|5}
    :Source: %^{Source?}
    :Cuisine: %^{Cuisine?|-|Indian|Thai|Vietnamese|Asian|Chinese|Israeli|Italian|American|EastEuro|Mexican|French|Persian|Austrian}
    :Type: %^{Type?|-|ain|side|starter|sweets|drinks|sauce|breakfast}
    :Serves: %^{Type?|-|1|2|4|6|8}
    :Fav: %^{}
    :END:
%^{prompt|** Ingredients}
%?
%^{prompt|** Preparation}
"
"Capture Template for food recipe")



;; add to shopping cart
("fs" "todo_shopping" entry (file+headline "~/org/files/agenda/food.org" "shopping")
"* SHOP %^{Description} " )




;;;; travel  simple template
  ("v" "travel" entry (file+headline "/home/zeltak/org/files/agenda/travel.org" "Inbox")
  "*  %^{Description}   %^g 
  %t 
  %^{address}p
  %^{Rating}p
  %^{URL}p
  %^{map}p
  %^{Fav}p
  %?
  "
   )

  ;;;; Tech  Todos

  ("x" "nix_TD" entry (file+headline "~/org/files/agenda/TODO.org" "TODO")
   "*  %^{Description}" )

  ;;;; Home Todos

  ("h" "Home_TD" entry (file+headline "~/org/files/agenda/home.org" "HomeTD")
   "* TODO  %?\n%T" )


  ;;; Uni todos

  ("u" "research_TD" entry (file+headline "~/org/files/agenda/research.org" "scheduled mail/calls/meetings")
   "* TODO  %?\n%T" )

  ;;;BGU todos 
  ("b" "BGU_TD" entry (file+headline "~/org/files/agenda/bgu.org" "TD")
   "* TODO  %?\n%T" )


  ;; for mail 
  ("r" "respond" entry (file+headline  "~/org/files/agenda/Research.org" "Mails")
   "* TODO Respond to %:from on %:subject\nSCHEDULED: %t\n\n%U\n\n%a\n\n" )


  ;;; web capture
  ("w" "webCapture" entry (file+headline "refile.org" "Web")  "* BOOKMARKS %T\n%c\%a\n%i\n Note:%?" :prepend t :jump-to-captured t :empty-lines-after 1 :unnarrowed t)


  ;;;;; media related 
  ("m" "Media")

  ("mm" "dl_movie" entry (file+headline "~/org/files/agenda/dl.org" "Movies")
   "*  %^{Description}  " )

  ("mp" "dl_movie_prerelease" entry (file+headline "~/org/files/agenda/dl.org" "Movies")
   "*   %^{Description}   :Pre_Release: " )

  ("mt" "dl_TV" entry (file+headline "~/org/files/agenda/dl.org" "TV")
   "*  %^{Description}" )

  ("ms" "dl_music" entry (file+headline "~/org/files/agenda/dl.org" "Music")
   "*  %^{Description}" )

  ("mc" "dl_comics" entry (file+headline "~/org/files/agenda/dl.org" "comics")
   "*  %^{Description}" )

("c" "Contacts" entry (file "/home/zeltak/org/files/PIM/contacts.org")
               "* %(org-contacts-template-name)
:PROPERTIES:
:EMAIL: %(org-contacts-template-email)
:END:")

("l" "Temp Links from the interwebs" item
         (file+headline "links.org" "Temporary Links")
         "%?\nEntered on %U\n \%i\n %a")

    )))
#+END_SRC


** mobile org
*** setup
#+begin_src emacs-lisp :results none
;;For agenda files locations, each location you add within " "
(require 'org-mobile)
(setq org-mobile-directory "~/Dropbox/MobileOrg/")
;; Set to the name of the file where new captures will be stored after pulling from mobile
(setq org-mobile-inbox-for-pull "~/org/files/from-mobile.org")

#+end_src

*** auto sync
**** (old, keep around since thid DOES work)
#+BEGIN_SRC emacs-lisp :results none
  ;; (defvar org-mobile-push-timer nil
  ;;   "Timer that `org-mobile-push-timer' used to reschedule itself, or nil.")

  ;; (defun org-mobile-push-with-delay (secs)
  ;;   (when org-mobile-push-timer
  ;;     (cancel-timer org-mobile-push-timer))
  ;;   (setq org-mobile-push-timer
  ;;         (run-with-idle-timer
  ;;          (* 1 secs) nil 'org-mobile-push)))

  ;; (add-hook 'after-save-hook 
  ;;  (lambda () 
  ;;    (when (eq major-mode 'org-mode)
  ;;      (dolist (file (org-mobile-files-alist))
  ;;       (if (string= (file-truename (expand-file-name (car file)))
  ;;                    (file-truename (buffer-file-name)))
  ;;            (org-mobile-push-with-delay 30)))
  ;;    )))

  ;; (run-at-time "00:05" 86400 '(lambda () (org-mobile-push-with-delay 1))) ;; refreshes agenda file each day

#+END_SRC

**** auto push
#+BEGIN_SRC emacs-lisp :results none
  ;; ;; Fork the work (async) of pushing to mobile
  ;; ;; https://gist.github.com/3111823 ASYNC org mobile push...
  ;; (require 'gnus-async) 
  ;; ;; Define a timer variable
  ;; (defvar org-mobile-push-timer nil
  ;;   "Timer that `org-mobile-push-timer' used to reschedule itself, or nil.")
  ;; ;; Push to mobile when the idle timer runs out
  ;; (defun org-mobile-push-with-delay (secs)
  ;;    (when org-mobile-push-timer
  ;;     (cancel-timer org-mobile-push-timer))
  ;;   (setq org-mobile-push-timer
  ;;         (run-with-idle-timer
  ;;          (* 1 secs) nil 'org-mobile-push)))
  ;; ;; After saving files, start an idle timer after which we are going to push 
  ;; (add-hook 'after-save-hook 
  ;;  (lambda () 
  ;;    (if (or (eq major-mode 'org-mode) (eq major-mode 'org-agenda-mode))
  ;;      (dolist (file (org-mobile-files-alist))
  ;;        (if (string= (expand-file-name (car file)) (buffer-file-name))
  ;;            (org-mobile-push-with-delay 10)))
  ;;      )))
  ;; ;; Run after midnight each day (or each morning upon wakeup?).
  ;; (run-at-time "00:01" 86400 '(lambda () (org-mobile-push-with-delay 1)))
  ;; ;; Run 1 minute after launch, and once a day after that.
  ;; (run-at-time "1 min" 86400 '(lambda () (org-mobile-push-with-delay 1)))
#+END_SRC
**** auto pull
#+BEGIN_SRC emacs-lisp :results none
  ;; ;; watch mobileorg.org for changes, and then call org-mobile-pull
  ;; ;; http://stackoverflow.com/questions/3456782/emacs-lisp-how-to-monitor-changes-of-a-file-directory
  ;; (defun install-monitor (file secs)
  ;;   (run-with-timer
  ;;    0 secs
  ;;    (lambda (f p)
  ;;      (unless (< p (second (time-since (elt (file-attributes f) 5))))
  ;;        (org-mobile-pull)))
  ;;    file secs))
  ;; (defvar monitor-timer (install-monitor (concat org-mobile-directory "/mobileorg.org") 30)
  ;;   "Check if file changed every 30 s.")
#+END_SRC

** Babel
*** languages
#+BEGIN_SRC emacs-lisp :results none
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (sh . t)
   (matlab . t)
   (sqlite . t)
   (ruby . t)
   (perl . t)
   (org . t)
   (dot . t)
   (gnuplot . t)
   (octave .t)
   (plantuml . t)
   (R . t)
   ))
#+END_SRC
    
*** disable confirm for these languages
#+BEGIN_SRC emacs-lisp :results none
  ;; (defun my-org-confirm-babel-evaluate (lang body)
  ;;     (not (string= lang "emacs-lisp")))  ; don't ask for lisp
  ;; (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+END_SRC
*** enable prompt-free code running
#+BEGIN_SRC emacs-lisp :results none
;; enable prompt-free code running
(setq org-confirm-babel-evaluate nil        ;; for running code blocks
      org-confirm-elisp-link-function nil   ;; for elisp links
      org-confirm-shell-link-function nil)  ;; for shell links 
#+END_SRC
*** done eval when exporting code
#+BEGIN_SRC emacs-lisp :results none
(setq org-export-babel-evaluate nil)
#+END_SRC
*** Fonts
#+BEGIN_SRC emacs-lisp :results none
;; fontify code in code blocks
(setq org-src-fontify-natively t)
#+END_SRC 
** font locks
 

#+BEGIN_SRC emacs-lisp :results none
;warning
(font-lock-add-keywords
 'org-mode
'(("\\(@[^@\n]+@\\)" (0 '(:foreground "#B40000" :background "#FFDDDD" :weight bold) t))))

;tip
(font-lock-add-keywords
 'org-mode
'(("\\(%[^%\n]+%\\)" (0 '(:weight ultra-bold :background "#DDFFDD" :foreground "#000000") t))))

;notice
(font-lock-add-keywords
 'org-mode
'(("\\(![^!\n]+!\\)" (0 '(:weight ultra-bold :foreground "#B40000") t))))

;high-green
(font-lock-add-keywords
 'org-mode
'(("\\('[^'\n]+'\\)" (0 '(:background "#35FF00" :weight ultra-bold) t))))

;high-yellow
(font-lock-add-keywords
 'org-mode
'(("\\(`[^`\n]+`\\)" (0 '(:foreground "#000000" :weight ultra-bold :background "#FBFF00") t))))

;
(font-lock-add-keywords
 'org-mode
'(("\\(₆[^₆\n]+₆\\)" (0 '(:foreground "#000000" :underline t :background "#FF9AEA" :weight ultra-bold) t))))

;
(font-lock-add-keywords
 'org-mode
'(("\\(₅[^₅\n]+₅\\)" (0 '(:weight ultra-bold :foreground "#1E00DE") t))))


;
(font-lock-add-keywords
 'org-mode
'(("\\(₄[^₄\n]+₄\\)" (0 '(:weight ultra-bold :foreground "#FF9800") t))))

;blusish
(font-lock-add-keywords
 'org-mode
'(("\\(•[^•\n]•+\\)" (0 '(:weight ultra-bold :foreground "#393D900") t))))


 
;;;;SPECIFIC WORDS 

;server
(font-lock-add-keywords
'org-mode
'(("\\b[Ss]erver\\b" (0 '(:weight ultra-bold :foreground "#FF9800") t))))

;client
(font-lock-add-keywords
'org-mode
'(("\\b[Cc]lient\\b" (0 '(:weight ultra-bold :foreground "#0044FF") t))))

;private
(font-lock-add-keywords
'org-mode
'(("\\b[Pp]rivate\\b" (0 '(:weight ultra-bold :foreground "#FF6767") t))))

;public
(font-lock-add-keywords
'org-mode
'(("\\b[Pp]ublic\\b" (0 '(:weight ultra-bold :foreground "#59BD7E") t))))


;In Example
(font-lock-add-keywords
'org-mode
'(("\\b[Ii]n example\\b" (0 '(:foreground "#000000" :underline t :background "#FF9AEA" :weight ultra-bold) t))))


;header
(font-lock-add-keywords
 'org-mode
'(("\\(‡[^‡\n]+‡\\)" (0 '(:foreground "#ffffff" :weight ultra-bold :slant italic :background "#59BD7F" :height 1.3) t))))

;;;FOR SPECIAL CHARACTERS

;for key shortucts
(font-lock-add-keywords
 'org-mode
'(("\\(\\?[^?\n]+\\?\\)" (0 '(:foreground "#000000" :weight ultra-bold :background "#FF9C2C") t))))

;for $Note$ 
(font-lock-add-keywords
 'org-mode
'(("\\(\\$[^$\n]+\\$\\)" (0 '(:background "#DDDDFF" :foreground "#000000" :weight ultra-bold) t))))

;for ^
(font-lock-add-keywords
 'org-mode
'(("\\(\\^[^^\n]+\\^\\)" (0 '(:weight bold  :box (:line-width 1 :color "#A5A0FF")  :foreground "#00006F" :background "#FFFFFF") t))))

;for † 
(font-lock-add-keywords
 'org-mode
'(("\\(\\†[^†\n]+\\†\\)" (0 '(:weight bold  :box (:line-width 1 :color "#A5A0FF")  :foreground "#00006F" :background "#FFFFFF") t))))

#+END_SRC

The following characters are special : . * + ? ^ $ \ [

more characters :
http://en.wikipedia.org/wiki/List_of_Unicode_characters
#+BEGIN_EXAMPLE
†•‖‣․‥ 	… ⁅⁆	⁑⁒⁓⁔⁕⁖⁗⁘⁙⁚⁛⁜⁝₀ 	₁₂₃₄	₅₆₇₈₉ ₊ ₋ ₌
#+END_EXAMPLE

** look and feel
*** make code blocks look better
#+BEGIN_SRC emacs-lisp :results none
;    (defun prettier-org-code-blocks ()
;      (interactive)
;      (font-lock-add-keywords nil
;        '(("\\(\+begin_src\\)"
;           (0 (progn (compose-region (match-beginning 1) (match-end 1) ?¦)
;                     nil)))
;          ("\\(\+end_src\\)"
;           (0 (progn (compose-region (match-beginning 1) (match-end 1) ?¦)
;                     nil))))))
;    (add-hook 'org-mode-hook 'prettier-org-code-blocks)
#+END_SRC
*** TODO Changing the org-mode ellipsis
#+BEGIN_SRC emacs-lisp :results none
(setq org-ellipsis "⤵")
#+END_SRC
Other interesting characters are ↴, ⬎, ⤷, and ⋱.

** Export/publishing
*** export in background
@this casues org-reveal to spit an error@
#+BEGIN_SRC emacs-lisp :results none
;(setq org-export-in-background t)
#+END_SRC
*** add ODT, beamer etc  exporters
**** base 
#+BEGIN_SRC emacs-lisp :results none
(require 'ox-odt)
(require 'ox-beamer)
(require 'ox-latex)

#+END_SRC
**** korma
#+BEGIN_SRC emacs-lisp :results none
(eval-after-load 'ox '(require 'ox-koma-letter))

(eval-after-load 'ox-latex
  '(add-to-list 'org-latex-packages-alist '("AUTO" "babel" t) t))

#+END_SRC
*** export locations for publishing 
#+BEGIN_SRC emacs-lisp :results none
     (setq org-publish-project-alist
           '(
              ("Help_files"
              :base-directory "~/org/files/help/"
              :publishing-directory "~/org/files/export/"
              :section-numbers nil
              :table-of-contents nil
              :publishing-function org-ascii-publish-to-ascii
                     )
              ("econf"
              :base-directory "~/org/files/agenda/"
              :publishing-directory "~/org/files/export/"
              :section-numbers nil
              :table-of-contents nil
              :publishing-function org-html-publish-to-html
                     )
))
#+END_SRC

*** visual option 
**** remove the “Validate XHTML 1.0” message from HTML export
#+BEGIN_SRC emacs-lisp :results none
(setq org-export-html-validation-link nil)
#+END_SRC
**** disregard _ as subscript
#+BEGIN_SRC emacs-lisp :results none
org-use-sub-superscripts nil        ;; don't use `_' for subscript
#+END_SRC

** org attach
#+BEGIN_SRC emacs-lisp :results none
(setq org-attach-directory "/home/zeltak/org/attach/files_2015/")
#+END_SRC
* look and feel
** Base

#+begin_src emacs-lisp results none
;; Remove splash screen
(setq inhibit-splash-screen t)

;; transient mode-importnat!
(transient-mark-mode 1)

;;winner mode by def-alut

;m use C-c <left> to restore the previous window configuration
(winner-mode 1)

; syntax highlighting everywhere
(global-font-lock-mode 1)

;;clipboard to sysclip
(setq x-select-enable-clipboard t)

;;paren mode- show visually matching parens
(show-paren-mode 1)
;show line numbers
(global-linum-mode 0) ; display line numbers in margin. Emacs 23 only

;visual line
(global-visual-line-mode 1) ; 1 for on, 0 for off.

;; don't show text in scratch buffer
(setq initial-scratch-message nil)


; Add word wrapping/wrap, may cause lines to be to short if enabled
;(global-visual-line-mode t)
(setq line-move-visual nil)


;;disable tooltips
(tooltip-mode -1)

#+end_src

#+RESULTS:

** start maximized
#+BEGIN_SRC emacs-lisp :results none
;Start maximized, please
(custom-set-variables
 '(initial-frame-alist (quote ((fullscreen . maximized))))) ;; start maximized

#+END_SRC
** scroll
#+BEGIN_SRC emacs-lisp :results none
; scroll one line at a time (less "jumpy" than defaults)
(setq scroll-margin 5
scroll-conservatively 9999
scroll-step 1)
#+END_SRC
** toolbars
turn on off toolbars with icons
1 to switch on and -1 to switch off
#+BEGIN_SRC emacs-lisp :results none
(tool-bar-mode -1)
#+END_SRC
** mouse and cursor

#+BEGIN_SRC emacs-lisp :results none
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time

(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling

(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse

;make cursor blink (use -1 to disable):
(blink-cursor-mode -1)

;;Keep the cursor steady when scrolling
(setq scroll-preserve-screen-position t)


#+END_SRC
** Menus
*** Add language switching menu
 
#+begin_src emacs-lisp results none
(define-key-after global-map [menu-bar file lang-modes] 
  (cons "Language Modes" (make-sparse-keymap "major modes")) 'kill-buffer )

(define-key global-map [menu-bar file lang-modes bash] '("Bash" . sh-mode))
(define-key global-map [menu-bar file lang-modes org] '("Org" . org-mode))
(define-key global-map [menu-bar file lang-modes tcl] '("TCL" . tcl-mode))
(define-key global-map [menu-bar file lang-modes ruby] '("Ruby" . ruby-mode))
(define-key global-map [menu-bar file lang-modes python] '("Python" . python-mode))
(define-key global-map [menu-bar file lang-modes php] '("PHP" . php-mode))
(define-key global-map [menu-bar file lang-modes perl] '("Perl" . cperl-mode))
(define-key global-map [menu-bar file lang-modes separator1] '("--"))
(define-key global-map [menu-bar file lang-modes haskell] '("Haskell" . haskell-mode))
(define-key global-map [menu-bar file lang-modes ocaml] '("OCaml" . tuareg-mode))
(define-key global-map [menu-bar file lang-modes elisp] '("Emacs Lisp" . emacs-lisp-mode))
(define-key global-map [menu-bar file lang-modes separator2] '("--"))
(define-key global-map [menu-bar file lang-modes latex] '("LaTeX" . latex-mode))
(define-key global-map [menu-bar file lang-modes js] '("Javascript" . js2-mode))
(define-key global-map [menu-bar file lang-modes xml] '("XML (xml-mode)" . xml-mode))
(define-key global-map [menu-bar file lang-modes nxml] '("XML (nxml-mode)" . nxml-mode))
(define-key global-map [menu-bar file lang-modes html] '("HTML" . html-mode))
(define-key global-map [menu-bar file lang-modes htmlhelper] '("HTML (html-helper-mode)" . html-helper-mode))
(define-key global-map [menu-bar file lang-modes css] '("CSS" . css-mode))
(define-key global-map [menu-bar file lang-modes separator3] '("--"))
(define-key global-map [menu-bar file lang-modes java] '("Java" . java-mode))
(define-key global-map [menu-bar file lang-modes c++] '("C++" . c++-mode))
(define-key global-map [menu-bar file lang-modes c] '("C" . c-mode))
#+end_src

*** Add zeltak menu
 
#+begin_src emacs-lisp results none
  ;; (easy-menu-define zmenu global-map "zglobal-menu"
  ;;   '("zglobal"
       
  ;; ("Programs" ;; submenu
  ;;        [""  (djcb-term-start-or-switch "mutt" t)]
  ;;        ["mc"    (djcb-term-start-or-switch "mc" t)]
  ;;        ["htop"  (djcb-term-start-or-switch "htop" t)]
  ;;        ["iotop" (djcb-term-start-or-switch "iotop" t)])
    
  ;;      ;; http://emacs-fu.blogspot.com/2009/03/math-formulae-in-webpages.html
  ;;      ;; this submenu is only visible when in org--mode
  ;;      ("Org"  :visible (or (string= major-mode "org-mode") (string= major-mode "org-mode"))
  ;;        ["Insert formula"   texdrive-insert-formula :help "Insert some formula"]
  ;;        ["Generate images"  texdrive-generate-images :help "(Re)generate the images for the formulae"])
       
  ;;      ;; http://emacs-fu.blogspot.com/2009/03/twitter.html
  ;;      ("Twitter" ;; submenu
  ;;        ["View friends" twitter-get-friends-timeline]
  ;;        ["What are you doing?" twitter-status-edit])
  
  ;;      ("Misc"  ;; submenu
  ;;        ;; http://emacs-fu.blogspot.com/2009/01/counting-words.html
  ;;        ["Count words" djcb-count-words]
  
  ;;        ;;http://emacs-fu.blogspot.com/2008/12/showing-line-numbers.html
  ;;        ["Show/hide line numbers" linum]
  
  ;;        ;; http://emacs-fu.blogspot.com/2008/12/running-emacs-in-full-screen-mode.html
  ;;        ["Toggle full-screen" djcb-fullscreen-toggle])))
  
  (easy-menu-define zorg org-mode-map "zorg-menu"
    '("zorg"
       ;; http://emacs-fu.blogspot.com/2008/12/running-console-programs-inside-emacs.html
       ("images" ;; submenu
         ["org toggle inline"  (org-toggle-inline-images t)]
         ["mc"    (fun1  t)]
         ["htop"  (fun2  t)]
         ["iotop" (fun3  t)])
       
       ;; http://emacs-fu.blogspot.com/2009/03/twitter.html
       ("Twitter" ;; submenu
         ["View friends" twitter-get-friends-timeline]
         ["What are you doing?" twitter-status-edit])
  
       ("Misc"  ;; submenu
         ;; http://emacs-fu.blogspot.com/2009/01/counting-words.html
         ["Count words" djcb-count-words]
  
         ;;http://emacs-fu.blogspot.com/2008/12/showing-line-numbers.html
         ["Show/hide line numbers" linum]
  
         ;; http://emacs-fu.blogspot.com/2008/12/running-emacs-in-full-screen-mode.html
         ["Toggle full-screen" djcb-fullscreen-toggle])))
  
  
#+end_src

** Theme and colors
*** disable answering yes to "unsafe" themes 
#+begin_src emacs-lisp
(setq custom-safe-themes t)    
#+end_src
*** change background based on file type
#+begin_src emacs-lisp results none

;; sample code for setting a background color depending on file name extension

; (defun my-set-theme-on-mode ()
;   "set background color depending on file suffix"
;   (interactive)
;   (let ((fileNameSuffix (file-name-extension (buffer-file-name) ) ))
;     (cond
;      ((string= fileNameSuffix "py" ) (set-background-color "honeydew"))
;      ((string= fileNameSuffix "txt" ) (set-background-color "cornsilk"))
;      (t (message "%s" "no match found"))
;      )
;     ))
;
; (add-hook 'find-file-hook 'my-set-theme-on-mode)
#+end_src

** Evil mode look and feel
*** Cursor colors by state
#+BEGIN_SRC emacs-lisp :results none
;color in emacs mode
(setq evil-emacs-state-cursor '("cyan" box))
;nomral state mode
(setq evil-normal-state-cursor '("green" box))
;visual state mode
(setq evil-visual-state-cursor '("orange" box))
;inset state mode
(setq evil-insert-state-cursor '("red" box))
(setq evil-replace-state-cursor '("red" box))
(setq evil-operator-state-cursor '("red" hollow))

#+END_SRC 
* Dired
*** main options 
**** Sort Directories First
#+BEGIN_SRC emacs-lisp :results none
;; Make sizes human-readable by default, sort version numbers
;; correctly, and put dotfiles and capital-letters first.
(setq-default dired-listing-switches "-alhv --group-directories-first ")

#+END_SRC
**** Auto guess target
Set this variable to non-nil, Dired will try to guess a default target directory. This means: if there is a dired buffer displayed in the next window, use its current subdir, instead of the current subdir of this dired buffer. The target is used in the prompt for file copy, rename etc.
#+BEGIN_SRC emacs-lisp :results none
(setq dired-dwim-target t)
#+END_SRC
**** copy from one dired dir to the next dired dir shown in a split window
#+BEGIN_SRC emacs-lisp :results none
(setq dired-dwim-target t)
#+END_SRC
**** Always Recursion
Always recursively delete directory

#+BEGIN_SRC emacs-lisp :results none
(setq dired-recursive-deletes 'always); “always” means no asking
;Always recursively copy directory
;(setq dired-recursive-copies 'top) ; “top” means ask once
(setq dired-recursive-copies 'always) ; never ask

#+END_SRC

**** Allow running multiple async commands simultaneously
#+BEGIN_SRC emacs-lisp :results none
;; Allow running multiple async commands simultaneously
(defadvice shell-command (after shell-in-new-buffer (command &optional output-buffer error-buffer))
  (when (get-buffer "*Async Shell Command*")
    (with-current-buffer "*Async Shell Command*"
      (rename-uniquely))))
(ad-activate 'shell-command)
#+END_SRC

**** dired find
#+BEGIN_SRC emacs-lisp :results none
(require 'find-dired)
(setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
#+END_SRC 
*** dired omit 
Omitting a file means removing it from the directory listing. Omitting is useful for keeping Dired buffers free of “uninteresting” files (for instance, auto-save, auxiliary, backup, and revision control files) so that the user can concentrate on the interesting files.
To activate it, add this to your .emacs

#+BEGIN_SRC emacs-lisp :results none
(setq-default dired-omit-mode t)
#+END_SRC

To toggle the mode, bind it to a keystroke that you like

(define-key dired-mode-map (kbd "C-o") 'dired-omit-mode)

dired-omit-files contains the regex of the files to hide in Dired Mode. For example, if you want to hide the files that begin with . and #, set that variable like this

(setq-default dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\.")

The variable dired-omit-extensions holds the list of all file extensions to hide in Dired Omit Mode. You can modify the list to add more file extensions to hide or remove the ones that you would like to show.

(add-to-list 'dired-omit-extension ".example")
(delete 'dired-omit-extension ".example")

**** start and toggle
@Note: If you are using Dired Omit Mode with dired+, remember to put the config of Dired Omit Mode before loading (require) dired+ since some feature of dired+ use the config from Dired Omit Mode (for example for displaying the file names).@
#+BEGIN_SRC emacs-lisp :results none
;To activate it, add this to your .emacs
(setq-default dired-omit-mode t)
;To toggle the mode, bind it to a keystroke that you like
(define-key dired-mode-map (kbd "C-o") 'dired-omit-mode)
#+END_SRC

*** TODO wdired mode
functions to get tab etc to work 

#+BEGIN_SRC emacs-lisp :results none
(defun my-mark-file-name-for-rename ()
    "Mark file name on current line except its extension"
    (interactive)

    ;; get the file file name first
    ;; full-name: full file name
    ;; extension: extension of the file
    ;; base-name: file name without extension
    (let ((full-name (file-name-nondirectory (dired-get-filename)))
          extension base-name)
      
      ;; check if it's a dir or a file
      ;; TODO not use if, use switch case check for symlink
      (if (file-directory-p full-name)
          (progn
            ;; if file name is directory, mark file name should mark the whole
            ;; file name
            (call-interactively 'end-of-line) ;move the end of line
            (backward-char (length full-name)) ;back to the beginning
            (set-mark (point))
            (forward-char (length full-name)))
        (progn
          ;; if current file is a file, mark file name mark only the base name,
          ;; exclude the extension
          (setq extension (file-name-extension full-name))
          (setq base-name (file-name-sans-extension full-name))
          (call-interactively 'end-of-line)
          (backward-char (length full-name))
          (set-mark (point))
          (forward-char (length base-name))))))

  (defun my-mark-file-name-forward ()
    "Mark file name on the next line"
    (interactive)
    (deactivate-mark)
    (next-line)
    (my-mark-file-name-for-rename))

  (defun my-mark-file-name-backward ()
    "Mark file name on the next line"
    (interactive)
    (deactivate-mark)
    (previous-line)
    (my-mark-file-name-for-rename))

#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
  ;; (require 'wdired)

  ;; (eval-after-load 'wdired
  ;;   (progn
  ;;     (define-key wdired-mode-map (kbd "TAB") 'my-mark-file-name-forward)
  ;;     (define-key wdired-mode-map (kbd "S-<tab>") 'my-mark-file-name-backward)
  ;;     (define-key wdired-mode-map (kbd "s-a") 'my-mark-file-name-for-rename))) ;
#+END_SRC
*** archive files
#+BEGIN_SRC emacs-lisp :results none
;; Handle zip compression
(eval-after-load "dired-aux"
  '(add-to-list 'dired-compress-file-suffixes
                '("\\.zip\\'" ".zip" "unzip")))
#+END_SRC
*** navigate
**** TODO auto open/enter file/dir in isearch
#+BEGIN_SRC emacs-lisp :results none
(add-hook 'isearch-mode-end-hook 
  (lambda ()
    (when (and (eq major-mode 'dired-mode)
           (not isearch-mode-end-hook-quit))
      (dired-find-file))))



(add-hook 'isearch-mode-end-hook 
  (lambda ()
    (when (and (eq major-mode 'sunrise-mode)
           (not isearch-mode-end-hook-quit))
      (dired-find-file))))
#+END_SRC

*** archives
**** TODO compress to tar in dired
this will only work on Emacs 25..keep track!
http://oremacs.com/2015/10/23/dired-compress/

This new command dired-do-compress-to, bound to c, will prompt me for a file name of the output archive. So now it's easier to type in that file name, if you use ido-mode / ivy-mode / helm-mode. What's more, the command will be automatically determined from the archive extension and executed. Here's the corresponding customization variable:

#+BEGIN_SRC emacs-lisp :results none
  ;; (define-key dired-mode-map "c" 'dired-do-compress-to)

  ;; (defvar dired-compress-files-alist
  ;;   '(("\\.tar\\.gz\\'" . "tar -c %i | gzip -c9 > %o")
  ;;     ("\\.zip\\'" . "zip %o -r --filesync %i"))
  ;;   "Control the compression shell command for `dired-do-compress-to'.

  ;; Each element is (REGEXP . CMD), where REGEXP is the name of the
  ;; archive to which you want to compress, and CMD the the
  ;; corresponding command.

  ;; Within CMD, %i denotes the input file(s), and %o denotes the
  ;; output file. %i path(s) are relative, while %o is absolute.")

#+END_SRC
**** zip
http://stackoverflow.com/questions/1431351/how-do-i-uncompress-unzip-within-emacs
#+BEGIN_SRC emacs-lisp :results none
(eval-after-load "dired-aux"
   '(add-to-list 'dired-compress-file-suffixes 
                 '("\\.zip\\'" ".zip" "unzip")))

(eval-after-load "dired"
  '(define-key dired-mode-map "z" 'dired-zip-files))
(defun dired-zip-files (zip-file)
  "Create an archive containing the marked files."
  (interactive "sEnter name of zip file: ")

  ;; create the zip file
  (let ((zip-file (if (string-match ".zip$" zip-file) zip-file (concat zip-file ".zip"))))
    (shell-command 
     (concat "zip " 
             zip-file
             " "
             (concat-string-list 
              (mapcar
               '(lambda (filename)
                  (file-name-nondirectory filename))
               (dired-get-marked-files))))))

  (revert-buffer)

  ;; remove the mark on all the files  "*" to " "
  ;; (dired-change-marks 42 ?\040)
  ;; mark zip file
  ;; (dired-mark-files-regexp (filename-to-regexp zip-file))
  )

(defun concat-string-list (list) 
   "Return a string which is a concatenation of all elements of the list separated by spaces" 
    (mapconcat '(lambda (obj) (format "%s" obj)) list " "))
#+END_SRC 

* Aliases
** settings
#+BEGIN_SRC emacs-lisp :results none
(defalias 'yes-or-no-p 'y-or-n-p) ; y or n is enough
(defalias 'list-buffers 'ibuffer) ; always use ibuffer
(defalias '~ 'make-backup)
(defalias 'lp 'list-packages)
(defalias 'lm 'lini)
(defalias 'rr 'regex-replace)
(defalias 'em 'evil-mode)
(defalias 'iss 'ispell) ;check spelling on buffer or region if marked
(defalias 'bks 'bmkp-save-menu-list-state) ;check spelling on buffer or region if marked

#+END_SRC

** Editing
#+BEGIN_SRC emacs-lisp :results none

(defalias 'sl 'sort-lines)
(defalias 'rr 'reverse-region)
(defalias 'rs 'replace-string)
(defalias 'g 'grep)
(defalias 'gf 'grep-find)
(defalias 'fd 'find-dired)
(defalias 'rb 'revert-buffer)
(defalias 'sh 'shell)
(defalias 'ps 'powershell)
(defalias 'fb 'flyspell-buffer)
(defalias 'sbc 'set-background-color)
(defalias 'rof 'recentf-open-files)
(defalias 'lcd 'list-colors-display)

#+END_SRC

** major/minor modes
#+BEGIN_SRC emacs-lisp :results none
; major modes
(defalias 'hm 'html-mode)
(defalias 'tm 'text-mode)
(defalias 'elm 'emacs-lisp-mode)
(defalias 'om 'org-mode)
(defalias 'ssm 'shell-script-mode)
(defalias 'html6-mode 'xah-html6-mode)

; minor modes
(defalias 'wsm 'whitespace-mode)
(defalias 'gwsm 'global-whitespace-mode)
(defalias 'dsm 'desktop-save-mode)
(defalias 'acm 'auto-complete-mode)
(defalias 'vlm 'visual-line-mode)
(defalias 'glm 'global-linum-mode)
#+END_SRC
** Code
#+BEGIN_SRC emacs-lisp :results none
; elisp
(defalias 'eb 'eval-buffer)
(defalias 'er 'eval-region)
(defalias 'ed 'eval-defun)
(defalias 'eis 'elisp-index-search)
(defalias 'lf 'load-file)


;escapes
(defalias '\\ 'escape-quotes-region)
(defalias '\[ 'remove-square-brackets)
(defalias '\" 'replace-straight-quotes)
#+END_SRC
+
* Abbreviations
** global 
#+BEGIN_SRC emacs-lisp :results none
;; stop asking whether to save newly added abbrev when quitting emacs
(setq save-abbrevs t)
;; turn on abbrev mode globally
(setq-default abbrev-mode t)
#+END_SRC

** personal abbriviations
*** new collected abbrv
to quickly peak at the personal file look here:

file:/home/zeltak/.emacs.d/abbrv/personal_abbrv.txt

to set 
#+BEGIN_SRC emacs-lisp :results none
(setq abbrev-file-name "/home/zeltak/.emacs.d/abbrv/personal_abbrv.txt")
#+END_SRC
to autoload it 
#+BEGIN_SRC emacs-lisp :results none
(load "/home/zeltak/.emacs.d/abbrv/personal_abbrv.txt")
#+END_SRC

*** loads a huge common abbreviations file

file:/home/zeltak/.emacs.d/avvrv/common_abbrv.txt

#+BEGIN_SRC emacs-lisp :results none
(load "/home/zeltak/.emacs.d/abbrv/common_abbrv.txt")
#+END_SRC

*** misc abbrv file (general stuff to quick add)

file:/home/zeltak/.emacs.d/abbrv/misc_abbrv.txt

#+BEGIN_SRC emacs-lisp :results none
(load "/home/zeltak/.emacs.d/abbrv/misc_abbrv.txt")
#+END_SRC
* minor modes
** vimrc mode
#+BEGIN_SRC emacs-lisp :results none
(define-generic-mode 'vimrc-generic-mode
    '()
    '()
    '(("^[\t ]*:?\\(!\\|ab\\|map\\|unmap\\)[^\r\n\"]*\"[^\r\n\"]*\\(\"[^\r\n\"]*\"[^\r\n\"]*\\)*$"
       (0 font-lock-warning-face))
      ("\\(^\\|[\t ]\\)\\(\".*\\)$"
      (2 font-lock-comment-face))
      ("\"\\([^\n\r\"\\]\\|\\.\\)*\""
       (0 font-lock-string-face)))
    '("/vimrc\\'" "\\.vim\\(rc\\)?\\'")
    '((lambda ()
        (modify-syntax-entry ?\" ".")))
    "Generic mode for Vim configuration files.")
#+END_SRC
* Extensions
** Xha menu dirs
#+BEGIN_SRC emacs-lisp :results none
(if (string= system-name "zuni") 
(progn

(defvar xah-filelist nil "alist for files i need to open frequently. Key is a short abbrev, Value is file path.")
(setq xah-filelist
      '(
        ("z" . "~/ZH_tmp/" )
        ("k " . "~/BK/" )
        ("l" . "~/org/files/Tech/linux.org" )
        ("f" . "~/org/files/agenda/food.org" )
        ("v" . "~/org/files/Home/travel.org" )
        ("h" . "~/org/files/Home/home.org" )
        ("m" . "~/org/files/from-mobile.org" )
        ("v" . "~/org/files/files/agenda/travel.org" )
        ("h" . "~/org/files/files/Home/home.org" )
        ("p" . "~/org/files/files/uni/papers/papers.org" )
        ("E" . "~/.emacs.d/init.el" )
        ("B" . "/home/zeltak/.config/beets/config.yaml" )
        ("S" . "~/.config/sxhkd/sxhkdrc" )
        ("I" . "~/.i3/config" )
        ("X" . "~/.xinitrc" )
        ("B" . "~/.interrobangrc" )
        ("Z" . "~/.zshrc" )
        ("o" . "~/org/attach/" )
        ) )
)

(progn

(defvar xah-filelist nil "alist for files i need to open frequently. Key is a short abbrev, Value is file path.")
(setq xah-filelist
      '(
       ("z" . "~/ZH_tmp/" )
        ("k " . "~/BK/" )
        ("l" . "~/org/files/Tech/linux.org" )
        ("f" . "~/org/files/agenda/food.org" )
        ("v" . "~/org/files/Home/travel.org" )
        ("h" . "~/org/files/Home/home.org" )
        ("m" . "~/org/files/from-mobile.org" )
        ("v" . "~/org/files/files/agenda/travel.org" )
        ("h" . "~/org/files/files/Home/home.org" )
        ("p" . "~/org/files/files/uni/papers/papers.org" )
        ("E" . "~/.emacs.d/init.el" )
        ("B" . "/home/zeltak/.config/beets/config.yaml" )
        ("S" . "~/.config/sxhkd/sxhkdrc" )
        ("I" . "~/.i3/config" )
        ("X" . "~/.xinitrc" )
        ("B" . "~/.interrobangrc" )
        ("Z" . "~/.zshrc" )
        ("o" . "~/org/attach/" )
        ) )
)
)

#+END_SRC

** z/dired-jump-folders
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-jump-folders  (openCode)
  "Prompt to open a file from a pre-defined set."
  (interactive
   (list (ido-completing-read "Open:" (mapcar (lambda (x) (car x)) xah-filelist)))
   )
  (find-file (cdr (assoc openCode xah-filelist)) ) )
#+END_SRC

** menu per machine
(if (string= system-name "voices") 
(progn
COMMAND1
COMMAND2
)

(progn
COMMAND1
COMMAND2
)
)


#+END_EXAMPLE
** edit webpages with emacs
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/extra/edit-server/")
(require 'edit-server)
(edit-server-start)
#+END_SRC
* R/ESS
** load ess
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/ESS/lisp/")
(load "ess-site")
#+END_SRC
** output
*** make scrolling always hit bottom
#+BEGIN_SRC emacs-lisp :results none
  (setq comint-scroll-to-bottom-on-input t)
  (setq comint-scroll-to-bottom-on-output t)
  (setq comint-move-point-for-output t)
#+END_SRC
** default dirs
*** transfile file
#+BEGIN_SRC emacs-lisp :results none
;don't ask to save file
;(setq ess-ask-about-transfile nil)
(setq ess-ask-about-transfile nil)
#+END_SRC

*** default directory 
#+BEGIN_SRC emacs-lisp :results none
(setq ess-ask-for-ess-directory nil)
;define deault ess dir
(setq ess-directory "/home/zeltak/ZH_tmp/")
#+END_SRC
*** local process name 
#+BEGIN_SRC emacs-lisp :results none
(setq ess-local-process-name "Runi")
#+END_SRC

*** history file
global command history file and have:
#+BEGIN_SRC emacs-lisp :results none
 (setq ess-history-directory "~/.essrhist/")
#+END_SRC
** functions
*** clear shell function
#+BEGIN_SRC emacs-lisp :results none
(defun clear-shell ()
   (interactive)
   (let ((old-max comint-buffer-maximum-size))
     (setq comint-buffer-maximum-size 0)
     (comint-truncate-buffer)
     (setq comint-buffer-maximum-size old-max))) 
#+END_SRC 
*** This recalls the R statement from your R statement history, but it tries to match it with the one which is already on your line.

#+BEGIN_SRC emacs-lisp :results none
(add-hook 'inferior-ess-mode-hook
    '(lambda nil
          (define-key inferior-ess-mode-map [\C-up]
              'comint-previous-matching-input-from-input)
          (define-key inferior-ess-mode-map [\C-down]
              'comint-next-matching-input-from-input)
          (define-key inferior-ess-mode-map [\C-x \t]
              'comint-dynamic-complete-filename)
     )
 )
#+END_SRC
This recalls the R statement from your R statement history, but it tries to match it with the one which is already on your line. So, for example, typing pl in R process and pressing \C-up (that’s control and the up arrow) will cycle through all the statements which start with pl, so it will recall for example all the plot(... commands.

*** allow ess to run procceses in background

#+BEGIN_SRC emacs-lisp :results none
(setq ess-eval-visibly 'nowait)
#+END_SRC

* Ediff

#+BEGIN_SRC emacs-lisp :results none
(defmacro csetq (variable value)
  `(funcall (or (get ',variable 'custom-set)
                'set-default)
            ',variable ,value))

(csetq ediff-window-setup-function 'ediff-setup-windows-plain)

(csetq ediff-split-window-function 'split-window-horizontally)

(csetq ediff-diff-options "-w")

(defun ora-ediff-hook ()
  (ediff-setup-keymap)
  (define-key ediff-mode-map "j" 'ediff-next-difference)
  (define-key ediff-mode-map "k" 'ediff-previous-difference))

(add-hook 'ediff-mode-hook 'ora-ediff-hook)

(winner-mode)
(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC
* mu4e
  :PROPERTIES:
  :END:
*** base setup 
for ubuntu
#+BEGIN_SRC emacs-lisp :results none
(when (string= system-name "zuni")
(add-to-list 'load-path "~/mu/mu4e/")
)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
(require 'mu4e)
(require 'mu4e-contrib) 
;;;;$Note-this may screw up header updates$ 
;(mu4e-maildirs-extension)
;; list of my email addresses.
(setq mu4e-user-mail-address-list '("ikloog@gmail.com"
                                    "ikloog@bgu.ac.il"
                                    "ekloog@hsph.harvard.edu"))


#+END_SRC
*** fetching and indexing
#+BEGIN_SRC emacs-lisp :results none
(setq mu4e-update-interval 60)
(setq mu4e-headers-auto-update t)
(setq mu4e-index-update-error-warning  t)
(setq mu4e-index-update-error-continue   t)
#+END_SRC
OLD:
#+BEGIN_EXAMPLE
;;(setq mu4e-get-mail-command "offlineimap")
#+END_EXAMPLE
*** personal info
#+BEGIN_SRC emacs-lisp :results none
;; something about ourselves
(setq
   user-mail-address "ikloog@gmail.com"
   user-full-name  "itai kloog "
   mu4e-compose-signature
    (concat
      "itai kloog\n"
      "http://www.bgu.ac.il\n"))

(setq mu4e-compose-signature-auto-include 't)
#+END_SRC

*** mail folders 
#+BEGIN_SRC emacs-lisp :results none
  (require 'mu4e)

  ;; default
  ;; (setq mu4e-maildir "~/Maildir")

  (setq mu4e-drafts-folder "/[Gmail].Drafts")
  (setq mu4e-sent-folder   "/[Gmail].Sent Mail")
  (setq mu4e-trash-folder  "/[Gmail].Trash")

  ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
  (setq mu4e-sent-messages-behavior 'delete)

  ;; (See the documentation for `mu4e-sent-messages-behavior' if you have
  ;; additional non-Gmail addresses and want assign them different
  ;; behavior.)

  ;; setup some handy shortcuts
  ;; you can quickly switch to your Inbox -- press ``ji''
  ;; then, when you want archive some messages, move them to
  ;; the 'All Mail' folder by pressing ``ma''.

  (setq mu4e-maildir-shortcuts
      '( ("/INBOX"               . ?i)
         ("/[Gmail].Sent Mail"   . ?s)
         ("/[Gmail].Trash"       . ?t)
         ("/[Gmail].All Mail"    . ?a)))

  ;; allow for updating mail using 'U' in the main view:
  ;(setq mu4e-get-mail-command "offlineimap")

  ;; sending mail -- replace USERNAME with your gmail username
  ;; also, make sure the gnutls command line utils are installed
  ;; package 'gnutls-bin' in Debian/Ubuntu

  ;; don't keep message buffers around
  (setq message-kill-buffer-on-exit t)
#+END_SRC
*** Sending mail
#+BEGIN_SRC emacs-lisp :results none

(require 'smtpmail)
(setq message-send-mail-function 'smtpmail-send-it
   starttls-use-gnutls t
   smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
   smtpmail-auth-credentials
     '(("smtp.gmail.com" 587 "ikloog@gmail.com" nil))
   smtpmail-default-smtp-server "smtp.gmail.com"
   smtpmail-smtp-server "smtp.gmail.com"
   smtpmail-smtp-service 587)
#+END_SRC

*** keybinds
#+BEGIN_SRC emacs-lisp :results none
;; setup some handy shortcuts
;; you can quickly switch to your Inbox -- press ``ji''
;; then, when you want archive some messages, move them to
;; the 'All Mail' folder by pressing ``ma''.

(setq mu4e-maildir-shortcuts
    '( ("INBOX"               . ?i)
       ("Starred"   . ?r)
       ("/[Gmail].Sent Mail"   . ?s)
       ("/[Gmail].Trash"       . ?t)
       ("/[Gmail].All Mail"    . ?a)))
#+END_SRC
*** composing
#+BEGIN_SRC emacs-lisp :results none
mu4e-compose-dont-reply-to-self t                  ; don't reply to myself
#+END_SRC
*** orgmode integration
http://www.djcbsoftware.nl/code/mu/mu4e/Creating-org_002dmode-links.html
#+BEGIN_SRC emacs-lisp :results none
(require 'org-mu4e)
#+END_SRC
*** sending
#+BEGIN_SRC emacs-lisp :results none

;; don't save messages to Sent Messages, Gmail/IMAP takes care of this
(setq mu4e-sent-messages-behavior 'delete)

;; alternatively, for emacs-24 you can use:
;;(setq message-send-mail-function 'smtpmail-send-it
;;     smtpmail-stream-type 'starttls
;;     smtpmail-default-smtp-server "smtp.gmail.com"
;;     smtpmail-smtp-server "smtp.gmail.com"
;;     smtpmail-smtp-service 587)
#+END_SRC
*** view settings
#+BEGIN_SRC emacs-lisp :results none
(setq mu4e-date-format-long "%d/%m/%Y (%H:%M:%S)")
(setq mu4e-headers-date-format "%d/%m/%Y (%H:%M:%S)")

;can define a horizontal or vertical split 
(setq mu4e-split-view 'horizontal)

;; use 'fancy' non-ascii characters in various places in mu4e
(setq mu4e-use-fancy-chars t)
;; attempt to show images when viewing messages
(setq mu4e-view-show-images t)

(when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))
;preffer html  
(setq mu4e-view-prefer-html t)

;; Silly mu4e only shows names in From: by default. Of course we also  want the addresses.
(setq mu4e-view-show-addresses t)

;; mu4e-action-view-in-browser is built into mu4e
;; by adding it to these lists of custom actions
;; it can be invoked by first pressing a, then selecting
(add-to-list 'mu4e-headers-actions
             '("in browser" . mu4e-action-view-in-browser) t)
(add-to-list 'mu4e-view-actions
             '("in browser" . mu4e-action-view-in-browser) t)

;; the headers to show in the headers list -- a pair of a field
;; and its width, with `nil' meaning 'unlimited'
;; (better only use that for the last field.
;; These are the defaults:
(setq mu4e-headers-fields
    '( (:date          .  25)
       (:flags         .   6)
       (:from          .  22)
       (:subject       .  nil)))


;; don't keep message buffers around
(setq message-kill-buffer-on-exit t)

#+END_SRC
*** html 
#+BEGIN_SRC emacs-lisp :results none
(require 'mu4e-contrib) 
(setq mu4e-html2text-command 'mu4e-shr2text) 
;(setq mu4e-html2text-command "w3m -I utf8 -O utf8 -T text/html")
#+END_SRC

*** misc
#+BEGIN_SRC emacs-lisp :results none
;; don't keep message buffers around
(setq message-kill-buffer-on-exit t)

;; don't save message to Sent Messages, Gmail/IMAP takes care of this
(setq mu4e-sent-messages-behavior 'delete)
;; (See the documentation for `mu4e-sent-messages-behavior' if you have
;; additional non-Gmail addresses and want assign them different
;; behavior.)

#+END_SRC
*** attachments
#+BEGIN_SRC emacs-lisp :results none
(setq mu4e-attachment-dir
  (lambda (fname mtype)
    (cond
      ;; docfiles go to ~/Desktop
      ((and fname (string-match "\\.pdf$" fname))  "~/Downloads/")
      ((and fname (string-match "\\.doc$" fname))  "~/Uni/")
      ;; ... other cases  ...
      (t "~/Downloads")))) ;; everything else
#+END_SRC
*** Faces
#+BEGIN_SRC emacs-lisp :results none
(defgroup mu4e-faces nil 
  "Type faces (fonts) used in mu4e." 
  :group 'mu4e 
  :group 'faces) 

(defface mu4e-basic-face 
  '((t :inherit font-lock-keyword-face)) 
  "Basic Face." 
  :group 'mu4e-faces) 

(defface mu4e-list-default 
  '((t :inherit mu4e-basic-face)) 
  "Basic list Face." 
  :group 'mu4e-faces) 

(defface mu4e-rw-default 
  '((t :inherit mu4e-basic-face)) 
  "Basic rw Face." 
  :group 'mu4e-faces) 
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
;; basic face from where the rest inherits 
 '(mu4e-basic-face ((t :inherit font-lock-keyword-face :weight normal :foreground "Gray10"))) 

;; read-write group 
 '(mu4e-rw-default ((t :inherit mu4e-basic-face))) ;; face from where all the read/write faces inherits 
 '(mu4e-header-face ((t :inherit mu4e-rw-default))) 
 '(mu4e-header-marks-face ((t :inherit mu4e-rw-default))) 
 '(mu4e-header-title-face ((t :inherit mu4e-rw-default))) 
 '(mu4e-header-highlight-face ((t :inherit mu4e-rw-default :foreground "Black" :background "LightGray"))) 
 '(mu4e-compose-header-face ((t :inherit mu4e-rw-default))) 
 '(mu4e-compose-separator-face ((t :inherit mu4e-rw-default :foreground "Gray30" :weight bold))) 
 '(mu4e-footer-face ((t :inherit mu4e-rw-default))) 
 '(mu4e-contact-face ((t :inherit mu4e-rw-default :foreground "Black"))) 
 '(mu4e-cited-1-face ((t :inherit mu4e-rw-default :foreground "Gray10"))) 
 '(mu4e-cited-2-face  ((t :inherit mu4e-cited-1-face :foreground "Gray20"))) 
 '(mu4e-cited-3-face   ((t :inherit mu4e-cited-2-face :foreground "Gray30"))) 
 '(mu4e-cited-4-face    ((t :inherit mu4e-cited-3-face :foreground "Gray40"))) 
 '(mu4e-cited-5-face     ((t :inherit mu4e-cited-4-face :foreground "Gray50"))) 
 '(mu4e-cited-6-face      ((t :inherit mu4e-cited-5-face :foreground "Gray60"))) 
 '(mu4e-cited-7-face       ((t :inherit mu4e-cited-6-face :foreground "Gray70"))) 
 '(mu4e-link-face ((t :inherit mu4e-rw-default :foreground "Blue" :weight bold))) 
 '(mu4e-system-face ((t :inherit mu4e-rw-defaul :foreground "DarkOrchid"))) 
 '(mu4e-url-number-face ((t :inherit mu4e-rw-default :weight bold))) 
 '(mu4e-attach-number-face ((t :inherit mu4e-rw-default :weight bold :foreground "Blue"))) 

;; lists (headers) group 
 '(mu4e-list-default ((t :inherit mu4e-basic-face))) ;; basic list face from where lists inherits 
 '(mu4e-draft-face ((t :inherit mu4e-list-default))) 
 '(mu4e-flagged-face ((t :inherit mu4e-list-default :weight bold :foreground "Black"))) 
 '(mu4e-forwarded-face ((t :inherit mu4e-list-default))) 
 '(mu4e-list-default-face ((t :inherit mu4e-list-default))) 
 '(mu4e-title-face ((t :inherit mu4e-list-default))) 
 '(mu4e-trashed-face ((t :inherit mu4e-list-default))) 
 '(mu4e-warning-face ((t :inherit mu4e-list-default :foreground "OrangeRed1"))) 
 '(mu4e-modeline-face ((t :inherit mu4e-list-default))) 
 '(mu4e-moved-face ((t :inherit mu4e-list-default))) 
 '(mu4e-ok-face ((t :inherit mu4e-list-default :foreground "ForestGreen"))) 
 '(mu4e-read-face ((t :inherit mu4e-list-default :foreground "Gray80"))) 
 '(mu4e-region-code-face ((t :inherit mu4e-list-default :background "Gray25"))) 
 '(mu4e-replied-face ((t :inherit mu4e-list-default :foreground "Black"))) 
 '(mu4e-unread-face ((t :inherit mu4e-list-default :foreground "Blue"))) 
 '(mu4e-highlight-face ((t :inherit mu4e-unread-face))) 

 '(mu4e-special-header-value-face ((t :inherit mu4e-contact-face))) 
 '(mu4e-header-key-face ((t :inherit mu4e-contact-face :foreground "Gray50"))) 
 '(mu4e-header-value-face ((t :inherit mu4e-contact-face))) 
 '(message-cited-text ((t :inherit mu4e-rw-default :foreground "Gray10"))) 

#+END_SRC


