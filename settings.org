#+Title: settings.org
 

* 1info
  :PROPERTIES:
  :ID:       442b10d2-cd02-44c6-b180-e2ac32aa8c59
  :END:
when things break look at 
$Note-if you see starnge behivour this maybe a culprit$  
sections and turn them off first

* Emacs startup
  :PROPERTIES:
  :ID:       8193566d-2dd5-4368-8238-fac2fc9aa7e9
  :END:
** save custom configs in a seperate file
to save the custom configs in a seperate file from init.el

#+BEGIN_SRC emacs-lisp :results none
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

$Note The first function just reloads the Emacs configuration. The second function opens the configuration up for editing.$

** Check which OS your on
#+begin_src emacs-lisp results none
  ; Check if system is windows
  (defun system-type-is-win ()
  (interactive)
  "Return true if system is windows"
  (string-equal system-type "windows-nt")
  )

  ;; Check if system is GNU/Linux
  (defun system-type-is-gnu ()
  (interactive)
  "Return true if system is GNU/Linux-based"
  (string-equal system-type "gnu/linux")
  )
#+end_src
** set main theme

To edit the theme file:~/.emacs.d/themes/zprime-theme.el

#+BEGIN_SRC emacs-lisp :results none
  ;;;add custom themes to list
  (add-to-list 'custom-theme-load-path "/home/zeltak/.emacs.d/themes")
  ;to load a specifc theme 
  ;(load-file "~/.emacs.d/themes/zprime-theme.el")
  ;load the choosen theme at startup 
  (load-theme 'zprime t)
#+END_SRC

** custom org export options (must be on top of settings to work for reason still discovered)
 #+BEGIN_SRC emacs-lisp :results none
(setq org-export-backends (quote (ascii html icalendar latex org)))
 #+END_SRC
** add org contrib 
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/org-mode/contrib/lisp/")
#+END_SRC
** Fonts
   :PROPERTIES:
   :ID:       2094e9ab-4a0b-4d66-aec5-e08a2a0aa52f
   :END:
#+begin_src emacs-lisp results none
; fonts in linux
(if (string= system-name "zx1voics")
;(add-to-list 'default-frame-alist '(font . "Inconsolata-16"))
;(add-to-list 'default-frame-alist '(font . "Source Code Pro-14"))
;(add-to-list 'default-frame-alist '(font . "Pragmata Pro-19"))
;(add-to-list 'default-frame-alist '(font . "Fantasque Sans Mono 14"))
(add-to-list 'default-frame-alist '(font . "fira mono 19"))
)

;; fontso in Win
;(if (system-type-is-win)
;(add-to-list 'default-frame-alist '(font . "Consolas-14"))
;)

(if (string= system-name "zuni")
(add-to-list 'default-frame-alist '(font . "fira mono 23"))
)

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
;; UTF-8 as default encoding
(set-language-environment "UTF-8")

;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))
 
;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

#+RESULTS:
| UTF8_STRING | COMPOUND_TEXT | TEXT | STRING |


* Packages
@DON'T CHANGE ORDER SINCE SOME PACKAGES NEED TO ONLY LOAD AFTER OTHERS@

** hippie expand

$note its built into emacs no intsall needed$

#+BEGIN_SRC emacs-lisp :results none
  ;;  (setq dcsh-command-list '("all_registers"
  ;;                                "check_design" "check_test" "compile" "current_design"
  ;;                                "link" "uniquify"
  ;;                                "report_timing" "report_clocks" "report_constraint"
  ;;                                "get_unix_variable" "set_unix_variable"
  ;;                                "set_max_fanout"
  ;;                                "report_area" "all_clocks" "all_inputs" "all_outputs"))
  
  ;;      (defun he-dcsh-command-beg ()
  ;;        (let ((p))
  ;;          (save-excursion
  ;;            (backward-word 1)
  ;;            (setq p (point)))
  ;;          p))
  
  ;;      (defun try-expand-dcsh-command (old)
  ;;        (unless old
  ;;          (he-init-string (he-dcsh-command-beg) (point))
  ;;          (setq he-expand-list (sort
  ;;                                (all-completions he-search-string (mapcar 'list dcsh-command-list))
  ;;                                'string-lessp)))
  ;;        (while (and he-expand-list
  ;;                (he-string-member (car he-expand-list) he-tried-table))
  ;;          (setq he-expand-list (cdr he-expand-list)))
  ;;        (if (null he-expand-list)
  ;;            (progn
  ;;              (when old (he-reset-string))
  ;;              ())
  ;;          (he-substitute-string (car he-expand-list))
  ;;          (setq he-tried-table (cons (car he-expand-list) (cdr he-tried-table)))
  ;;          (setq he-expand-list (cdr he-expand-list))
  ;;          t))

  ;;  (setq hippie-expand-try-functions-list (cons 'yas/hippie-try-expand hippie-expand-try-functions-list))

  ;;  (defun my-hippie-expand-completions (&optional hippie-expand-function)
  ;;        "Return the full list of possible completions generated by `hippie-expand'.
  ;;      The optional argument can be generated with `make-hippie-expand-function'."
  ;;        (let ((this-command 'my-hippie-expand-completions)
  ;;              (last-command last-command)
  ;;              (buffer-modified (buffer-modified-p))
  ;;              (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
  ;;          (flet ((ding)) ; avoid the (ding) when hippie-expand exhausts its options.
  ;;            (while (progn
  ;;                     (funcall hippie-expand-function nil)
  ;;                     (setq last-command 'my-hippie-expand-completions)
  ;;                     (not (equal he-num -1)))))
  ;;          ;; Evaluating the completions modifies the buffer, however we will finish
  ;;          ;; up in the same state that we began, and (save-current-buffer) seems a
  ;;          ;; bit heavyweight in the circumstances.
  ;;          (set-buffer-modified-p buffer-modified)
  ;;          ;; Provide the options in the order in which they are normally generated.
  ;;          (delete he-search-string (reverse he-tried-table))))
   
  ;;      (defmacro my-ido-hippie-expand-with (hippie-expand-function)
  ;;        "Generate an interactively-callable function that offers ido-based completion
  ;;      using the specified hippie-expand function."
  ;;        `(call-interactively
  ;;          (lambda (&optional selection)
  ;;            (interactive
  ;;             (let ((options (my-hippie-expand-completions ,hippie-expand-function)))
  ;;               (if options
  ;;                   (list (ido-completing-read "Completions: " options)))))
  ;;            (if selection
  ;;                (he-substitute-string selection t)
  ;;              (message "No expansion found")))))
   
  ;;      (defun my-ido-hippie-expand ()
  ;;        "Offer ido-based completion for the word at point."
  ;;        (interactive)
  ;;        (my-ido-hippie-expand-with 'hippie-expand))
   
  ;; ;; (global-set-key (kbd "<f12>") 'my-ido-hippie-expand)
  ;; ;; (global-set-key [(meta f5)] (make-hippie-expand-function
  ;; ;;                                '(try-expand-dcsh-command
  ;; ;;                                  try-expand-dabbrev-visible
  ;; ;;                                  try-expand-dabbrev
  ;; ;;                                  try-expand-dabbrev-all-buffers) t))
  ;; (global-set-key (kbd "M-/") 'hippie-expand)
  ;; ;; (global-set-key (kbd "TAB") 'hippie-expand)

#+END_SRC
  
** ido

$note its built into emacs no intsall needed$

'flx-ido'- install it before ido through MELPA

#+BEGIN_SRC emacs-lisp :results none
  ;; (ido-mode 1)
  ;; (require 'flx-ido)
  ;; (ido-everywhere 1)
  ;; (flx-ido-mode 1)
  ;; ;; disable ido faces to see flx highlights.
  ;; (setq ido-use-faces nil)
  
  
  ;; (setq ido-max-directory-size 100000)
  ;; (ido-mode (quote both))
  ;; ; Use the current window when visiting files and buffers with ido
  ;; (setq ido-default-file-method 'selected-window)
  ;; (setq ido-default-buffer-method 'selected-window)
  
  
  
  ;; ;ignore case
  ;; (setq ido-case-fold t)
  ;; (setq ido-enable-flex-matching t) ; fuzzy matching is a must have
  
  ;; ;ido-ubiquitous
  
  ;; ;recents ido
  ;; (defun recentf-ido-find-file ()
  ;;   "Find a recent file using ido."
  ;;   (interactive)
  ;;   (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
  ;;     (when file
  ;;      (find-file file))))
  
  
  ;; ;this keybinding lets you even more quickly reach your home folder when in ido-find-file.
  
  ;; (add-hook 'ido-setup-hook
  ;;  (lambda ()
  ;;    ;; Go straight home
  ;;    (define-key ido-file-completion-map
  ;;      (kbd "~")
  ;;      (lambda ()
  ;;        (interactive)
  ;;        (if (looking-back "/")
  ;;            (insert "~/")
  ;;          (call-interactively 'self-insert-command))))))
#+END_SRC

** Ace window
   :PROPERTIES:
   :ID:       1429ffca-3d2e-4abc-8c26-851b62c3bd37
   :END:
https://github.com/abo-abo/ace-window
sets to only use homekeys 
#+BEGIN_SRC emacs-lisp :results none
(use-package ace-window
    :config
;set keys to only these 
;;    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
;;    (setq aw-keys '(?1 ?2 ?3 ?4 ?5 ))
;; set to work in frames not global! so that if only 2 windows in frames frame it would switch between them 
(setq aw-scope 'frame)
;; set to true if you want to darken the background during switch
(setq aw-background nil)
;; When non-nil, ace-window will issue a read-char even for one window- you want it nil!
(setq aw-dispatch-always nil)


)
#+END_SRC
arch
https://github.com/tam17aki/ace-isearch
*** start ace-isearch
#+BEGIN_SRC emacs-lisp :results none
;  (use-package ace-isearch
;  :ensure t
;  :config
;  (ace-isearch-mode +1)
;  (global-ace-isearch-mode +1)
; (setq ace-isearch-function 'avy-goto-word-1)
;  )
#+END_SRC
*** customize 
#+BEGIN_SRC emacs-lisp :results none
  ;;   (custom-set-variables
  ;;   '(ace-isearch-input-length 9)
  ;;   '(ace-isearch-input-idle-delay 0.4)
  ;;   '(ace-isearch-submode 'ace-jump-char-mode)
  ;;   '(ace-isearch-use-ace-jump 'printing-char)
  ;; )
#+END_SRC
** ace link
https://github.com/abo-abo/ace-link

#+BEGIN_SRC emacs-lisp :results none
(use-package ace-link
 :ensure t
 :config
(ace-link-setup-default)
 )
#+END_SRC
** TODO alert
https://github.com/jwiegley/alert
#+BEGIN_SRC emacs-lisp :results none
(use-package alert
 :ensure t
 :config
 
 )
#+END_SRC 


** anzu
https://github.com/syohex/emacs-anzu

#+BEGIN_SRC emacs-lisp :results none
(use-package anzu
 :ensure t
 :config
(require 'anzu)
(global-anzu-mode +1)

(set-face-attribute 'anzu-mode-line nil
                    :foreground "yellow" :weight 'bold)

(custom-set-variables
 '(anzu-mode-lighter "")
 '(anzu-deactivate-region t)
 '(anzu-search-threshold 1000)
 '(anzu-replace-to-string-separator " => "))
 
(global-set-key (kbd "M-%") 'anzu-query-replace)
(global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp)

 )
#+END_SRC 

** async

 $Note this is needed for org-download$
 #+BEGIN_SRC emacs-lisp :results none
(use-package async
:ensure t)
 #+END_SRC 

** auctex
#+BEGIN_SRC emacs-lisp :results none
;(require 'tex)
;(setq preview-scale-function 1.1)
#+END_SRC
** auto-complete

#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package auto-complete
  ;;  :ensure t
  ;;  :config
  ;; (ac-config-default)

  ;; ;start after 4 characters
  ;; (setq ac-auto-start 4)
  ;; ;fix linium issues
  ;; (ac-linum-workaround)

  ;; ;; Examples
  ;; (set-face-background 'ac-candidate-face "lightgray")
  ;; (set-face-underline 'ac-candidate-face "darkgray")
  ;; (set-face-background 'ac-selection-face "steelblue")

  ;; )
#+END_SRC

** Avy Jump
https://github.com/abo-abo/avy

#+BEGIN_SRC emacs-lisp :results none
(use-package avy
 :ensure t
 :config
 (defcustom avy-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?q ?w ?e ?r ?t ?y ?u ?i ?o ?p ?z ?x ?c ?v ?b ?n ?m )
 "Keys for jumping.") 
(setq avy-timeout-seconds 0.6)
 )
#+END_SRC 


** avy zap
   :PROPERTIES:
   :LAST-EDITED: [03-08-2015(19:57)]
   :END:
https://github.com/cute-jumper/avy-zap
#+BEGIN_SRC emacs-lisp :results none
(use-package avy-zap
 :ensure t
 :config
  )
#+END_SRC
** bm
https://github.com/joodland/bm
#+BEGIN_SRC emacs-lisp :results none
(use-package bm
 :ensure t
 :config
;;restore on load (even before you require bm)
(setq bm-restore-repository-on-load t)

(require 'bm)
;; Allow cross-buffer 'next'
(setq bm-cycle-all-buffers t)  
;;where to store persistant files
(setq bm-repository-file "~/.emacs.d/bm-repository")
;; save bookmarks
(setq-default bm-buffer-persistence t)

   ;; Loading the repository from file when on start up.
   (add-hook' after-init-hook 'bm-repository-load)

   ;; Restoring bookmarks when on file find.
   (add-hook 'find-file-hooks 'bm-buffer-restore)

   ;; Saving bookmark data on killing a buffer
   (add-hook 'kill-buffer-hook 'bm-buffer-save)

   ;; Saving the repository to file when on exit.
   ;; kill-buffer-hook is not called when Emacs is killed, so we
   ;; must save all bookmarks first.
   (add-hook 'kill-emacs-hook '(lambda nil
                                   (bm-buffer-save-all)
                                   (bm-repository-save)))

   ;; Update bookmark repository when saving the file.
   (add-hook 'after-save-hook 'bm-buffer-save)

   ;; Restore bookmarks when buffer is reverted.
   (add-hook 'after-revert-hook 'bm-buffer-restore)


 )
#+END_SRC
** helm-bm

#+BEGIN_SRC emacs-lisp :results none
(use-package helm-bm
 :ensure t
 :config
  )
#+END_SRC 


** BBDB
#+BEGIN_SRC emacs-lisp :results none
(use-package bbdb
 :ensure t
 :config
(setq bbdb-file "~/.emacs.d/bbdb")           ;; keep ~/ clean; set before loading
(require 'bbdb) 
(bbdb-initialize)

 )
#+END_SRC 
** bbdb-csv-import
https://gitlab.com/iankelling/bbdb-csv-import/
#+BEGIN_SRC emacs-lisp :results none
(use-package bbdb-csv-import
 :ensure t
 :config
  )
#+END_SRC
** TODO bind map
https://github.com/justbur/emacs-bind-map/tree/e3fa3cc383bd7d331caa89bc914a2a296abb98f1
#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package bind-map
  ;;  :ensure t
  ;;  :config

  ;; (bind-map z/base-leader-map
  ;;   :keys ("\\")
  ;; )

  ;; (bind-map-set-keys z/base-leader-map
  ;;   "c" 'z/org-export-revel-browse
  ;;   ;; ...
  ;;   )

  ;;  )
#+END_SRC

allows for an arbitrary number of “leader keys”. This is probably best explained with an example.

(bind-map my-base-leader-map
  :keys ("M-m")
  :evil-keys ("SPC")
  :evil-states (normal motion visual))
(bind-map my-elisp-map
  :keys ("M-m m" "M-RET")
  :evil-keys ("SPC m" ",")
  :major-modes (emacs-lisp-mode
                lisp-interaction-mode))

** beacon mode 

https://github.com/Malabarba/beacon

#+BEGIN_SRC emacs-lisp :results none
(use-package beacon
 :ensure t
 :config
(beacon-mode 1)
(setq beacon-push-mark 35)
(setq beacon-color "#21D6F4")
 )
#+END_SRC 


** Bookmark+
#+BEGIN_SRC emacs-lisp :results none
(use-package bookmark+
:ensure t
:config
(setq bookmark-version-control t
      bookmark-save-flag t)
;ask for tags when saving a bookmark move nil to t to ask each time
(setq bmkp-prompt-for-tags-flag nil)
)

#+END_SRC

** Browse kill ring
#+BEGIN_SRC emacs-lisp :results none
(use-package browse-kill-ring
:ensure t
:config
)
#+END_SRC 

** bug hunter
https://github.com/Malabarba/elisp-bug-hunter

#+BEGIN_SRC emacs-lisp :results none
(use-package bug-hunter
 :ensure t
 :config
  )
#+END_SRC
** calfw
https://github.com/kiwanami/emacs-calfw
#+BEGIN_SRC emacs-lisp :results none
(use-package calfw
 :ensure t
 :config
 (require 'calfw)
(require 'calfw-org)

(defun my-open-calendar ()
  (interactive)
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source "blue")  ; orgmode source
    (cfw:howm-create-source "magenta")  ; howm source
    (cfw:cal-create-source "Orange") ; diary source
   ))) 
 )
#+END_SRC 
** char-menu

#+BEGIN_SRC emacs-lisp :results none
(use-package char-menu
 :ensure t
 :config
 
(setq char-menu '("—" "‘’" "“”" "…" "«»" "–" "【】" "◀▶" "☚ ☛"
                            ("Typography" "•" "©" "†" "‡" "°" "·" "§" "№" "★")
                            ("Math"       "≈" "≡" "≠" "∞" "×" "±" "∓" "÷" "√")
                            ("Arrows"     "←" "→" "↑" "↓" "⇐" "⇒" "⇑" "⇓")
                            ("Greek"      "α" "β" "Y" "δ" "ε" "ζ" "η" "θ" "ι" "κ" "λ" "μ" "ν" "ξ" "ο" "π" "ρ" "σ" "τ" "υ" "φ" "χ" "ψ" "ω") 
))
 )
#+END_SRC 

** Counsel
#+BEGIN_SRC emacs-lisp :results none
(use-package counsel
 :ensure t
 :config
  )
#+END_SRC 
 
** color-theme-approximate
 If it doesn't work try to put the line lower in the .emacs file (it happened to me). If everything still look like shit check that you have the correct XTERM environment variable set 
$Note- is different inside screen or tmux$

#+BEGIN_SRC emacs-lisp :results none
(use-package color-theme-approximate
 :ensure t
 :config
(color-theme-approximate-on)
 )
#+END_SRC 

** company-statistics

#+BEGIN_SRC emacs-lisp :results none
(use-package company-statistics
 :ensure t
 :config
 )
#+END_SRC 


** company
#+BEGIN_SRC emacs-lisp :results none
  ;;   (use-package company
  ;;    :ensure t
  ;;    :config
  ;; ;; companymode
  ;;   (require 'company)

  ;; ; Company-mode backends
  ;; (eval-after-load "company"
  ;;   '(progn
  ;;      (add-to-list 'company-backends 'company-dabbrev)
  ;;      (add-to-list 'company-backends 'company-ispell)
  ;;      (add-to-list 'company-backends 'company-abbrev)
  ;;      (add-to-list 'company-backends 'company-files)

  ;; ;; @see https://github.com/company-mode/company-mode/issues/348
  ;;      (require 'company-statistics)
  ;;      (company-statistics-mode)

  ;; ;; yasnippet backend shadows other completions, see https://github.com/company-mode/company-mode/blob/master/company-yasnippet.el for solutions
  ;; ;;better to leave disabled and use the ido mode for yasnippets
  ;; ;;     (add-to-list 'company-backends 'company-yasnippet)
  ;; ;; using the delete command disables specific modes 
  ;;     (setq company-backends (delete 'company-capf company-backends))
  ;;     (setq company-backends (delete 'company-ropemacs company-backends))
  ;;     (setq company-backends (delete 'company-clang company-backends))
  ;;     (setq company-backends (delete 'company-cmake company-backends))
  ;;     (setq company-backends (delete 'company-css company-backends))
  ;;     (setq company-backends (delete 'company-eclim company-backends))
  ;;     (setq company-backends (delete 'company-elisp company-backends))
  ;;     (setq company-backends (delete 'company-etags company-backends))
  ;;     (setq company-backends (delete 'company-gtags company-backends))
  ;;     (setq company-backends (delete 'company-keywords company-backends))
  ;;     (setq company-backends (delete 'company-nxml company-backends))
  ;;     (setq company-backends (delete 'company-oddmuse company-backends))
  ;;     (setq company-backends (delete 'company-semantic company-backends))
  ;;     (setq company-backends (delete 'company-template company-backends))
  ;;     (setq company-backends (delete 'company-tempo company-backends))
  ;;     (setq company-backends (delete 'company-tests company-backends))
  ;;     (setq company-backends (delete 'company-xcode company-backends))
  ;;     (setq company-backends (delete 'company-tempo company-backends))
  ;;     (setq company-backends (delete 'company-yasnippet company-backends))
  ;; ;; capf is for all modes and all languges so its better to turn it off to not pollute completions.
  ;; ;;     (add-to-list 'company-backends 'company-capf)
  ;;      ))

  ;; ;;make it global
  ;; (add-hook 'after-init-hook 'global-company-mode)


  ;; ;; company delay until suggestions are shown
  ;; (setq company-idle-delay 0.2)
  ;; ;; whats the minimum to start completion 
  ;; (setq company-minimum-prefix-length 2)
  ;; (setq company-dabbrev-minimum-length 2)
  ;; ;; weight by frequency
  ;; (setq company-transformers '(company-sort-by-occurrence))
  ;; ;;dabbrev options 
  ;; (setq company-dabbrev-downcase nil)
  ;; (setq company-dabbrev-ignore-case nil)
  ;; (setq company-dabbrev-other-buffers t)
  ;;   ;; show numbers in popup?
  ;; (setq company-show-numbers t)
  ;; (setq company-require-match nil)
  ;; ;; company dabbrev config
  ;; ;; search all buffers 
  ;; (setq company-dabbrev-other-buffers t)


  ;; ;; Don't enable company-mode in below major modes, OPTIONAL
  ;; (setq company-global-modes '(not eshell-mode comint-mode erc-mode rcirc-mode))



  ;; (defun org-mode-hook-setup ()
  ;;   ;; make `company-backends' local is critcal
  ;;   ;; or else, you will have completion in every major mode, that's very annoying!
  ;;   (make-local-variable 'company-backends)

  ;;   ;; OPTIONAL, if `company-ispell-dictionary' is nil, `ispell-complete-word-dict' is used
  ;;   ;;  but I prefer hard code the dictionary path. That's more portable.
  ;;   (setq company-ispell-dictionary (file-truename "~/.emacs.d/abbrv/english-words.txt")))

  ;; (add-hook 'org-mode-hook 'org-mode-hook-setup)


  ;; ;;;keybinds
  ;; (global-set-key (kbd "M-.") 'company-complete)
  ;; (global-set-key (kbd "M-/") 'company-dabbrev)

  ;;    )
#+END_SRC 

** company-emoji
https://github.com/dunn/company-emoji

make sure to install ttf-ancient-fonts to get the fonts to show up


#+BEGIN_SRC emacs-lisp :results none
(use-package company-emoji
 :ensure t
 :config
(require 'company-emoji)
(add-to-list 'company-backends 'company-emoji)

(defun --set-emoji-font (frame)
  "Adjust the font settings of FRAME so Emacs can display emoji properly."
  (if (eq system-type 'darwin)
      ;; For NS/Cocoa
      (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
    ;; For Linux
    (set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))

;; For when Emacs is started in GUI mode:
(--set-emoji-font nil)

;; Hook for when a frame is created with emacsclient
;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
(add-hook 'after-make-frame-functions '--set-emoji-font)
 )
#+END_SRC 
You can add shortcode aliases by modifying company-emoji-aliases. Run M-x customize-variable [RET] company-emoji-aliases to bring up company-emoji’s customization pane, then add or remove aliases to your taste.
** company-org-headings
#+BEGIN_SRC emacs-lisp :results none
  ;; (add-to-list 'load-path "/home/zeltak/.emacs.g/company-org-headings")
  ;; (setq
  ;;  ;; align all annotations to the right tooltip border
  ;;  company-tooltip-align-annotations t
  ;;  company-org-headings/search-directory "~/notes"
  ;;  company-org-headings/case-sensitive nil)

  ;; ;; (add-hook 'org-mode-hook
  ;; ;;           (lambda ()
  ;; ;;             (set (make-local-variable 'company-backends)
  ;; ;;                  '((company-org-headings
  ;; ;;                     company-abbrev
  ;; ;;                     company-files
  ;; ;;                     )))))
#+END_SRC

** crux
https://github.com/bbatsov/crux

#+BEGIN_SRC emacs-lisp :results none
(use-package crux
 :ensure t
 :config
 
 )
#+END_SRC 


** `dired plugins`
*** dired hacks 
**** dired-avfs
    https://github.com/Fuco1/dired-hacks#dired-avfs

 This extension therefore depends on the presence of avfsd on your system
 on arch to get it working issue this (at startup in xinitrc or other startup scripts)

 grep -q "^avfsd $HOME/.avfs " /proc/mounts || avfsd ~/.avfs -o auto_cache     

 #+BEGIN_SRC emacs-lisp :results none
 (use-package dired-avfs
  :ensure t
  :config
  )
 #+END_SRC 
**** dired-filter
 https://github.com/Fuco1/dired-hacks

 Saved filters

 call ~dired-filter-save-filters~ You will be prompted for a name under which this stack will be saved.
 it will save the new value into your customize file.

 You can delete saved filters with ~dired-filter-delete-saved-filters~

 To use a saved filter, you can use either ~dired-filter-add-saved-filters~ or ~dired-filter-load-saved-filters  ~

 The first pushes the saved filter on top of the currently active stack, the second clears current filter stack before loading the saved filter configuration.

 #+BEGIN_SRC emacs-lisp :results none
 (use-package dired-filter
  :ensure t
  :config
  )
 #+END_SRC 
**** dired-rainbow (define colors by extensions)
https://github.com/Fuco1/dired-hacks#dired-rainbow

 #+BEGIN_SRC emacs-lisp :results none
 (use-package dired-rainbow
  :ensure t
  :config
  (require 'dired-rainbow)

 (defconst dired-audio-files-extensions
   '("mp3" "MP3" "ogg" "OGG" "flac" "FLAC" "wav" "WAV")
   "Dired Audio files extensions")
 (dired-rainbow-define audio "#329EE8" dired-audio-files-extensions)


 (defconst dired-docs-files-extensions
   '("docx" "doc" "odf" "odt" "xls" "xlsx" "ppt" "pptx" "ods" "odt")
   "Dired Docs files extensions")
 (dired-rainbow-define docs "#42D14A" dired-docs-files-extensions)

 (defconst dired-video-files-extensions
     '("vob" "VOB" "mkv" "MKV" "mpe" "mpg" "MPG" "mp4" "MP4" "ts" "TS" "m2ts"
       "M2TS" "avi" "AVI" "mov" "MOV" "wmv" "asf" "m2v" "m4v" "mpeg" "MPEG" "tp")
     "Dired Video files extensions")
 (dired-rainbow-define video "#006EFF" dired-video-files-extensions)

 (defconst dired-image-files-extensions
     '("jpeg" "jpg" "JPG" "JPEG" "png" "PNG" "bmp" "tif" "tiff" "xbm" "svg" )
     "Dired image files extensions")
 (dired-rainbow-define image "#E009CF" dired-image-files-extensions)


 (defconst dired-pdf-files-extensions
   '("pdf" "PDF")
   "Dired pdf files extensions")
 (dired-rainbow-define pdf "#FF0000" dired-pdf-files-extensions)


 (defconst dired-org-files-extensions
   '("org" "ORG")
   "Dired org files extensions")
 (dired-rainbow-define org "#FF00A2" dired-org-files-extensions)


 (defconst dired-compressed-files-extensions
   '("zip" "ZIP"  "tar.bz" "tar.gz" "7zip" "7ZIP" "tar" "TAR" "rar" "RAR")
   "Dired compressed files extensions")
 (dired-rainbow-define compressed "#B56A00" dired-compressed-files-extensions)


  )
 #+END_SRC 

**** dired-narrow
 https://github.com/Fuco1/dired-hacks
 #+BEGIN_SRC emacs-lisp :results none
 (use-package dired-narrow
  :ensure t
  :config
;;(setq dired-narrow-exit-action 'find-file)
(setq dired-narrow-exit-action 'dired-narrow-find-file)
  )
 #+END_SRC
**** dired-open
#+BEGIN_SRC emacs-lisp :results none


  ;; (use-package dired-open
  ;;  :ensure t
  ;;  :config
  ;;  (setq dired-open-extensions
  ;;       '(("pdf" . "okular")
  ;;         ("mkv" . "vlc")
  ;;         ("mp4" . "vlc")
  ;;         ("avi" . "vlc")
  ;;         ("html" . "firefox")
  ;;         ("mp3" . "vlc")
  ;;         ("doc" . "libreoffice")
  ;;         ("docx" . "libreoffice")
  ;;         ("odt" . "libreoffice")
  ;;         ("odf" . "libreoffice")
  ;;         ("xls" . "libreoffice")
  ;;         ("xlsx" . "libreoffice")
  ;;         ("ppt" . "libreoffice")
  ;;         ("pptx" . "libreoffice")
  ;; ))
  ;;  )
#+END_SRC
**** dired-subtree

#+BEGIN_SRC emacs-lisp :results none
(use-package dired-subtree
 :ensure t
 :config
 
 )
#+END_SRC
**** dired-ranger

#+BEGIN_SRC emacs-lisp :results none
(use-package dired-ranger
 :ensure t
 :config
 
 )
#+END_SRC 


*** dired-x

http://www.gnu.org/software/emacs/manual/html_node/dired-x/Shell-Command-Guessing.html

$Note-no need to install its a internal dired package$ 
#+BEGIN_SRC emacs-lisp :results none
(require 'dired-x)

(add-hook 'dired-load-hook
              (function (lambda () (load "dired-x"))))

(setq dired-guess-shell-alist-user
      '(("\\.e?ps$" "gv" "xloadimage" "lpr")
        ("\\.chm$" "xchm")
        ("\\.rar$" "unrar x")
        ("\\.e?ps\\.g?z$" "gunzip -qc * | gv -")
        ("\\.pdf$" "zathura")
        ("\\.mkv$" "mpv")
        ("\\.ogm$" "mpv")
        ("\\.avi$" "mpv")
        ("\\.png$" "feh")
        ("\\.jpg$" "feh")
        ("\\.JPG$" "feh")
        ("\\.doc$" "libreoffice")
        ("\\.docx$" "libreoffice")
        ("\\.xls$" "libreoffice")
        ("\\.xlsx$" "libreoffice")
        ("\\.ppt$" "libreoffice")
        ("\\.pptx$" "libreoffice")

))
#+END_SRC 

*** dired sort
#+BEGIN_SRC emacs-lisp :results none
(use-package dired-sort
 :ensure t
 :config
  )
#+END_SRC
*** dired-sort-menu

#+BEGIN_SRC emacs-lisp :results none
(use-package dired-sort-menu
 :ensure t
 :config
 
 )
#+END_SRC 

and the plus addon:

#+BEGIN_SRC emacs-lisp :results none
(use-package dired-sort-menu+
 :ensure t
 :config
 
 )
#+END_SRC 


*** TODO dired+
#+BEGIN_SRC emacs-lisp :results none
  (use-package dired+
   :ensure t
   :config
  ;;; don't create a buffer for every dir I visit (use 1 to not create and -1 to creare)
  (toggle-diredp-find-file-reuse-dir -1)
    )
#+END_SRC 
*** dired-efap (rename file at point)
https://github.com/juan-leon/dired-efap

See also variable dired-efap-initial-filename-selection, if you want to control what part of the filename will be initially selected.

Type M-x customize-group RET dired-efap if you want make changes to the default behavior.

#+BEGIN_SRC emacs-lisp :results none
(use-package dired-efap
 :ensure t
 :config
 
 )
#+END_SRC 

*** dired tmtxt-async-tasks 
https://truongtx.me/tmtxt-async-tasks.html
https://truongtx.me/tmtxt-dired-async.html

#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/tmtxt-async-tasks")
(add-to-list 'load-path "/home/zeltak/.emacs.g/tmtxt-dired-async")
(require 'tmtxt-async-tasks)
(require 'tmtxt-dired-async)

(setq-default tat/window-close-delay "2")
(setq-default tat/window-height 15)
#+END_SRC
*** dired-fdclone
https://github.com/knu/dired-fdclone.el
#+BEGIN_SRC emacs-lisp :results none
(use-package dired-fdclone
 :ensure t
 :config
 
 )
#+END_SRC 

good package for zip and unzip functions
*** TODO dired-toggle-sudo
https://github.com/renard/dired-toggle-sudo
#+BEGIN_SRC emacs-lisp :results none
(use-package dired-toggle-sudo
 :ensure t
 :config
(require 'dired-toggle-sudo)
 (define-key dired-mode-map (kbd "C-c C-s") 'dired-toggle-sudo)
 (eval-after-load 'tramp
  '(progn
     ;; Allow to use: /sudo:user@host:/path/to/file
     (add-to-list 'tramp-default-proxies-alist
		  '(".*" "\\`.+\\'" "/ssh:%h:"))))
 
 )
#+END_SRC
*** helm-dired-recent-dirs
https://github.com/akisute3/helm-dired-recent-dirs
#+BEGIN_SRC emacs-lisp :results none
(use-package helm-dired-recent-dirs
 :ensure t
 :config
 
 )
#+END_SRC 
*** image-dired+
https://github.com/mhayashi1120/Emacs-image-diredx
#+BEGIN_SRC emacs-lisp :results none
(use-package image-dired+
 :ensure t
 :config
     (eval-after-load 'image-dired+ '(image-diredx-async-mode 1))
    (eval-after-load 'image-dired+ '(image-diredx-adjust-mode 1))
 )
#+END_SRC
*** dired-atool
https://github.com/HKey/dired-atool

#+BEGIN_SRC emacs-lisp :results none
(use-package dired-atool
 :ensure t
 :config
 (dired-atool-setup)
 )
#+END_SRC
*** TODO make-it-so
https://github.com/abo-abo/make-it-so
#+BEGIN_SRC emacs-lisp :results none
(use-package  make-it-so 
 :ensure t
 :config
(require 'make-it-so)
(setq mis-recipes-directory "/home/zeltak/.emacs.d/mis")
(mis-config-default)
 )
#+END_SRC
*** peep dired
 https://github.com/asok/peep-dired
 #+BEGIN_SRC emacs-lisp  :results none
 ;;preview files in dired
 (use-package peep-dired
   :ensure t
   :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
   :bind (:map dired-mode-map
               ("P" . peep-dired))
   :config 
(setq peep-dired-ignored-extensions '("mkv" "iso" "mp4"))
)
 #+END_SRC
** TODO Deft
http://jblevins.org/projects/deft/

#+BEGIN_SRC emacs-lisp :results none
(use-package deft
 :ensure t
 :config
(require 'deft)
(setq deft-extension "org")
(setq deft-text-mode 'org-mode)
(setq deft-directory "~/org/files/agenda/")
(setq deft-use-filename-as-title t)
(setq deft-recursive t)
;;strip org mode stuff
(setq deft-strip-title-regexp "#\\+TITLE: ")
;;ignore these dirs
(setq deft-recursive-ignore-dir-regexp
          (concat "\\(?:"
                  "\\."
                  "\\|\\.\\."
                  "#\\mypapers"
                  "\\|code"
                  "\\|auto"
                  "\\|_minted.*"
                  "\\)$"))

 )
#+END_SRC 


** drag stuff
https://github.com/rejeep/drag-stuff.el

allows to drag text around via keyboard 

#+BEGIN_SRC emacs-lisp :results none
(use-package drag-stuff
 :ensure t
 :config
  )
#+END_SRC
** duplicate-thing
https://github.com/ongaeshi/duplicate-thing
#+BEGIN_SRC emacs-lisp :results none
(use-package  duplicate-thing 
 :ensure t
 :config
 )
#+END_SRC 

** ebib

#+BEGIN_SRC emacs-lisp :results none
(use-package ebib
 :ensure t
 :config
(setq ebib-preload-bib-files '("/home/zeltak/org/files/Uni/papers/kloog.2015.bib")) 

(setq ebib-common-optional-fields
      '(translator keywords origlanguage url file location
        partinfo subtitle edition abstract note annotator
        crossref urldate address subtitle language))

(setq ebib-file-associations '(("pdf" . "okular") ("djvu" . "okular")))
(setq ebib-uniquify-keys t)
(setq ebib-autogenerate-keys t)
(setq ebib-index-window-size 20)
(setq ebib-print-multiline t)

;index view
(setq ebib-index-display-fields (quote (year author)))
(setq ebib-sort-order (quote ((year) (author) )))

 )
#+END_SRC
** easy-kill
https://github.com/leoliu/easy-kill

#+BEGIN_SRC emacs-lisp :results none
(use-package easy-kill
   :ensure t
   :config
;; to replace Emacs native M-w
(global-set-key [remap kill-ring-save] 'easy-kill)
(global-set-key (kbd "M-3") 'easy-mark)
   )
#+END_SRC 
** edit-server (for chrome interaction)
 #+BEGIN_SRC emacs-lisp :results none
   ;; (require 'edit-server)
   ;;  (edit-server-start)
   ;; (autoload 'edit-server-maybe-dehtmlize-buffer "edit-server-htmlize" "edit-server-htmlize" t)
   ;; (autoload 'edit-server-maybe-htmlize-buffer   "edit-server-htmlize" "edit-server-htmlize" t)
   ;; (add-hook 'edit-server-start-hook 'edit-server-maybe-dehtmlize-buffer)
   ;; (add-hook 'edit-server-done-hook  'edit-server-maybe-htmlize-buffer)
 #+END_SRC
** elfeed
*** base 
#+BEGIN_SRC emacs-lisp :results none
(use-package elfeed
 :ensure t
 :config

;;;default search 
(setq-default elfeed-search-filter "@2-week-ago +unread ")

;;change date formay 
(setq elfeed-search-date-format '("%d %b %H:%M" 12 :left))

;;set sort order
(setq elfeed-sort-order 'ascending)

;;; add a star tag http://matt.hackinghistory.ca/2015/11/22/elfeed/

 (eval-after-load 'elfeed-search 
;;  '(define-key elfeed-search-mode-map (kbd "<tab>") 'mwp/elfeed-star))
  '(define-key elfeed-search-mode-map (kbd "t") 'mwp/elfeed-star))


(defun mwp/elfeed-star ()
  "add a star tag to marked"

  (interactive)
  (elfeed-search-tag-all (list starred))
  )

(defun mwp/elfeed-star ()
  "Apply TAG to all selected entries."
  (interactive )
  (let* ((entries (elfeed-search-selected))
         (tag (intern "starred")))

    (cl-loop for entry in entries do (elfeed-tag entry tag))
    (mapc #'elfeed-search-update-entry entries)
    (unless (use-region-p) (forward-line))))

;;; add visual cue
(defface elfeed-search-starred-title-face
 '((t :foreground "#f77"))
 "Marks a starred Elfeed entry.")

(push '(starred elfeed-search-starred-title-face) 
       elfeed-search-face-alist)


;;Avoiding tagging old entries as unread:

;; Entries older than 2 weeks are marked as read
(add-hook 'elfeed-new-entry-hook
          (elfeed-make-tagger :before "2 weeks ago"
                              :remove 'unread))

;;for "Queue timeout exceeded" errors
(setf url-queue-timeout 30)

(define-key elfeed-search-mode-map (kbd "j") 'next-line)
(define-key elfeed-show-mode-map    (kbd "j") 'elfeed-show-next)
(define-key elfeed-search-mode-map (kbd "k") 'previous-line)
(define-key elfeed-show-mode-map    (kbd "k") 'elfeed-show-prev)

 )
#+END_SRC 

next-line

Faces and Colors
All of the faces used in the display are declared for customization, so these can be changed to whatever you like.

elfeed-search-date-face
elfeed-search-title-face
elfeed-search-feed-face
elfeed-search-tag-face



*** feeds 
 #+BEGIN_SRC emacs-lisp :results none
(setq elfeed-feeds
   '(
;;comics
("http://phdcomics.com/gradfeed.php" comics)
("http://theoatmeal.com/feed/rss" comics)
("http://xkcd.com/rss.xml" comics)
("http://researchinprogress.tumblr.com/rss" comics)
;;food 
"http://feeds.feedburner.com/seriouseatsfeaturesvideos"
"http://feeds.feedburner.com/bazekalim" 
"http://feeds2.feedburner.com/thai-food-blog/main" 
"http://feeds2.feedburner.com/humus101rss" 
"http://feeds.feedburner.com/ptitim" 
"http://what-efrat.blogspot.com/feeds/posts/default" 
"http://feeds.feedburner.com/matkonation/BRUQ" 

;;Tech
"http://lifehacker.com/index.xml" 
"http://feeds.feedburner.com/Makeuseof" 
"http://xbmc.org/feed/" 
"http://googlecode.blogspot.com/atom.xml" 
"http://fulltextrssfeed.com/www.engadget.com/rss.xml"

;;geek stuff 
"http://www.geekologie.com/index.xml" 
;;personal blogs
"http://feeds.feedburner.com/AdventuresInOpenSource?format=xml"
"http://feeds.feedburner.com/yuval"

;;emacs
"http://oremacs.com/atom.xml" 
"http://emacshorrors.com/feed.atom" 
"http://emacsninja.com/feed.atom" 
"http://ericjmritz.name/feed/" 
"http://matt.hackinghistory.ca/feed/" 
"http://karl-voit.at/feeds/lazyblorg-all.atom_1.0.links-only.xml" 
"http://emacsmovies.org/atom.xml" 
"http://endlessparentheses.com/atom.xml" 
"http://planet.emacsen.org/atom.xml" 
"http://sachachua.com/blog/feed/" 
"http://kitchingroup.cheme.cmu.edu/blog/feed" 
"http://whattheemacsd.com/atom.xml" 
"http://www.masteringemacs.org/feed/" 
"http://emacsredux.com/atom.xml" 
"http://www.lunaryorn.com/feed.atom" 
"http://www.clarkdonley.com/atom.xml"

;;linux
"http://thelinuxrain.com/feed" 
"http://www.archlinux.org/feeds/news/" 
"http://www.freesoftwaremagazine.com/rss.xml" 
"http://www.kde.org/dotkdeorg.rdf" 
"http://www.linuxjournal.com/node/feed" 
"http://www.lunduke.com/?feed=rss2" 
"http://kmandla.wordpress.com/feed/" 
"http://www.phoronix.com/rss.php" 
"http://planet.linux.org.il/atom.xml" 
"http://planetkde.org/rss20.xml" 
"http://blog.sarine.nl/feed/" 
"http://rss.slashdot.org/Slashdot/slashdotLinux" 
"http://whatsup.org.il/backend.php" 
"http://igurublog.wordpress.com/feed/" 

;;mobile
"http://feeds.feedburner.com/xda-developers/ShsH" 
;;sports
"http://debuzzer.com/feed/" 
;;uni 
"http://rforpublichealth.blogspot.com/feeds/posts/default" 
;;music
"https://muspy.com/feed?id=f9qypqwxc658e6dbzwk8n9mqthsgv4" 

))
 #+END_SRC

*** orgmode integration
when I org-capture in elfeed-show-mode using a template that includes a link, I get a nicely formatted link to the online linked entry. I use this to capture stuff I want to read later

#+BEGIN_SRC emacs-lisp
(defun elfeed-entry-as-html-link ()
  "Store an http link to an elfeed entry"
  (when (equal major-mode 'elfeed-show-mode)
    (let ((description (elfeed-entry-title elfeed-show-entry))
      (link (elfeed-entry-link elfeed-show-entry)))
     (org-store-link-props
      :type "http"
      :link link
      :description description))))

(add-hook 'org-store-link-functions 'elfeed-entry-as-html-link)
#+END_SRC

** elfeed-goodies
https://github.com/algernon/elfeed-goodies

customise some aspects of the package with M-x customize-group elfeed-goodies
this is saved in file:/home/zeltak/.emacs.d/custom.el
#+BEGIN_SRC emacs-lisp :results none
(use-package elfeed-goodies
 :ensure t
 :config
(require 'elfeed-goodies)
(elfeed-goodies/setup) 
 )
#+END_SRC 
** eyebrowse

#+BEGIN_SRC emacs-lisp :results none
(use-package eyebrowse
 :ensure t
 :config
(eyebrowse-mode t) 
 )
#+END_SRC 



** engine-mode
   
#+BEGIN_SRC emacs-lisp :results none
(use-package engine-mode
 :ensure t
 :config 
 )
#+END_SRC
** ess 
#+BEGIN_SRC emacs-lisp :results none
(use-package ess 
 :ensure t
 :config
 )
#+END_SRC 

** ess-view
https://github.com/GioBo/ess-view

#+BEGIN_SRC emacs-lisp :results none
(use-package ess-view
 :ensure t
 :config
(require 'ess-view) 
 )
#+END_SRC 

** EVIL

#+BEGIN_SRC emacs-lisp :results none
(use-package evil
:ensure t
:config
)
#+END_SRC

 #+begin_src emacs-lisp results none
   ;; (require 'evil)
   ;; (evil-mode 1)

   ;; ;for normal undo
   ;; (setq evil-want-fine-undo t)

   ;; ;;; esc quits
   ;; (define-key evil-normal-state-map [escape] 'keyboard-quit)
   ;; (define-key evil-visual-state-map [escape] 'keyboard-quit)
   ;; (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
   ;; (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
   ;; (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
   ;; (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
   ;; (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)

   ;; ;searches
   ;; (global-set-key (kbd "C-*") 'evil-search-symbol-forward)
   ;; (global-set-key (kbd "C-#") 'evil-search-symbol-backward)



 #+end_src

** EVIL NERD Commenter
https://github.com/redguardtoo/evil-nerd-commenter

 #+BEGIN_SRC emacs-lisp :results none
(use-package evil-nerd-commenter
:ensure t
:config
)
;(evilnc-default-hotkeys)
;(setq evilnc-hotkey-comment-operator ",,")
 #+END_SRC


** expand region
https://github.com/magnars/expand-region.el


#+BEGIN_SRC emacs-lisp :results none
(use-package expand-region
 :ensure t
 :config
 )
#+END_SRC 

** find-file-in-project
https://github.com/technomancy/find-file-in-project

#+BEGIN_SRC emacs-lisp :results none
(use-package find-file-in-project
 :ensure t
 :config

 )
#+END_SRC 
** flx

#+BEGIN_SRC emacs-lisp :results none
(use-package flx
 :ensure t
 :config
 
 )
#+END_SRC 


** Fill colum mode
#+BEGIN_SRC emacs-lisp :results none
(use-package fill-column-indicator
:ensure t
:config
)
#+END_SRC
qq
** Gnus related
*** gnus-desktop-notify
http://www.thregr.org/~wavexx/software/gnus-desktop-notify.el/

#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package gnus-desktop-notify
  ;;  :ensure t
  ;;  :config
  ;;  (require 'gnus-desktop-notify)
  ;; (gnus-desktop-notify-mode)
  ;; (gnus-demon-add-scanmail)

  ;;  )
#+END_SRC 
** gscholar-bibtex
https://github.com/cute-jumper/gscholar-bibtex

#+BEGIN_SRC emacs-lisp :results none
(use-package gscholar-bibtex
 :ensure t
 :config
(setq gscholar-bibtex-default-source "Google Scholar")
(setq gscholar-bibtex-database-file "/home/zeltak/org/files/Uni/papers/library.2015.bib")

 )
#+END_SRC 


** google contacts

#+BEGIN_SRC emacs-lisp :results none
(use-package google-contacts
:ensure t
:config
)
#+END_SRC
** goto-chg

#+BEGIN_SRC emacs-lisp :results none
(use-package goto-chg
 :ensure t
 :config
 (require 'goto-chg)
 :bind (("C-." . goto-last-change)
         ("C-," . goto-last-change-reverse))
 )
#+END_SRC 


** gmail2bbdb
https://github.com/redguardtoo/gmail2bbdb

#+BEGIN_SRC emacs-lisp :results none
(use-package gmail2bbdb
 :ensure t
 :config

 )
#+END_SRC 

** gnorb

https://github.com/girzel/gnorb

examples:

- Whang attachments from Gnus messages onto Org headings, using org-attach.
- Automate the above as part of the org capture process
- Email contents of org subtree under point (prompt for export routine)
- Single-keystroke Org links or email citations of BBDB contacts
- Initiate search of emails from contacts in open BBDB buffer
- Initiate Org agenda tag search from BBDB buffer
- Inverse of the above: pop up a BBDB buffer alongside an Org tags search
- Treat headings as email-related TODOs, and handle them DWIM-style

  #+BEGIN_SRC emacs-lisp :results none
  (use-package gnorb
   :ensure t
   :config
      )
  #+END_SRC 
  
  
** grizzl
for projectile fuzzy match
#+BEGIN_SRC emacs-lisp :results none
(use-package grizzl
 :ensure t
 :config
  )
#+END_SRC 

** `Helm`
*** load Helm
#+BEGIN_SRC emacs-lisp :results none
(use-package helm
:ensure t
:config
(require 'helm-config)
(helm-mode 1)
;(global-set-key (kbd "M-x") 'helm-M-x)
(setq helm-M-x-fuzzy-match t) ;; optional fuzzy matching for helm-M-x
(global-set-key (kbd "C-c h") 'helm-command-prefix)
(global-unset-key (kbd "C-x c"))
;;Autoresize
(helm-autoresize-mode t)
;; sets min and max helm height
(setq helm-autoresize-max-height 60)
(setq helm-autoresize-min-height 40)
)
#+END_SRC
*** Helm configuration 
**** Helm viewing options config 

 #+BEGIN_SRC emacs-lisp :results none
(setq  helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
       helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
       helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
       helm-ff-file-name-history-use-recentf t
)
 #+END_SRC
**** helm mini
***** enable fuzzy matching
 #+BEGIN_SRC emacs-lisp :results none
 (setq helm-buffers-fuzzy-matching t
       helm-recentf-fuzzy-match    t)

(global-set-key (kbd "C-x b") 'helm-mini)
 #+END_SRC
**** helm buffers 
***** sort dired file at end of buffer
http://emacs.stackexchange.com/questions/17169/change-order-of-buffers-in-helm-buffers-list

#+BEGIN_SRC emacs-lisp  :results none
(defun sort-dired-buffers (buffers)
  "Sort BUFFERS by moving all Dired buffers to the end."
  (let (dired-buffers other-buffers)
    (dolist (buf buffers)
      (if (with-current-buffer buf
            (eq major-mode 'dired-mode))
          (push buf dired-buffers)
        (push buf other-buffers)))
    (nreverse (append dired-buffers other-buffers))))

(defun helm-buffers-sort-dired-buffers (orig-fun &rest args)
  (sort-dired-buffers (apply orig-fun args)))

(advice-add 'helm-buffers-sort-transformer :around #'helm-buffers-sort-dired-buffers)
#+END_SRC
**** search org folders
 #+BEGIN_SRC emacs-lisp :results none
 (use-package helm-cmd-t
 :ensure t
 :config
 (defvar my-org-folders (list  "~/org/files/")
   "my permanent folders for helm-mini")

 (defun helm-my-org (&optional arg)
   "Use C-u arg to work with repos."
   (interactive "P")
   (if (consp arg)
       (call-interactively 'helm-cmd-t-repos)
     (let ((helm-ff-transformer-show-only-basename nil))
       (helm :sources (mapcar (lambda (dir)
				(helm-cmd-t-get-create-source-dir dir))
                              my-org-folders)
             :candidate-number-limit 20
             :buffer "*helm-my-org:*"
             :input "org$ "))))
 )
 #+END_SRC

**** google suggest 
 #+BEGIN_SRC emacs-lisp :results none
 (when (executable-find "curl")
   (setq helm-google-suggest-use-curl-p t))
 #+END_SRC

**** helm man-woman (man doc reader)
 enable at point
 #+BEGIN_SRC emacs-lisp :results none
 (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
 #+END_SRC
**** helm locate
 enable fuzzy 
 #+BEGIN_SRC emacs-lisp :results none
 (setq helm-locate-fuzzy-match t)	    
 #+END_SRC
**** helm occur
no config needed$
*** helm-ag
 https://github.com/syohex/emacs-helm-ag
 #+BEGIN_SRC emacs-lisp :results none
 (use-package helm-ag
  :ensure t
  :config
 
  )
 #+END_SRC 


*** helm-grepint
 https://github.com/kopoli/helm-grepint

 #+BEGIN_SRC emacs-lisp :results none
 (use-package helm-grepint
  :ensure t
  :config
      (require 'helm-grepint)
     (helm-grepint-set-default-config)
     (global-set-key (kbd "C-c g") #'helm-grepint-grep)
     (global-set-key (kbd "C-c G") #'helm-grepint-grep-root)
  )
 #+END_SRC 
 Key bindings within helm:

 RET selects an item and closes the helm session.
 Right arrow selects the item, but does not close the helm session. This is similar as helm-occur.
*** helm-fuzzier
 https://github.com/EphramPerdition/helm-fuzzier

 better fuzzy matching for helm

 #+BEGIN_SRC emacs-lisp :results none
 (use-package helm-fuzzier
  :ensure t
  :config
  (require 'helm-fuzzier)
   (helm-fuzzier-mode 1)
  )
 #+END_SRC 

 helm-fuzzier will only enhance matching for sources that have fuzzy-matching enabled, so be sure to enable fuzzy-matching for the sources you're interested in by setting the appropriate variable (helm-M-x-fuzzy-match, helm-mode-fuzzy-match, helm-apropos-fuzzy-match, etc').

*** helm-swoop
 https://github.com/ShingoFukuyama/helm-swoop

 #+BEGIN_SRC emacs-lisp :results none
 (use-package helm-swoop
  :ensure t
  :config
 ;; Move up and down like isearch
 (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
 (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
 (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
 (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

 ;; From helm-swoop to helm-multi-swoop-all
 (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

 ;; Save buffer when helm-multi-swoop-edit complete
 (setq helm-multi-swoop-edit-save t)

 ;; If nil, you can slightly boost invoke speed in exchange for text color
 (setq helm-swoop-speed-or-color nil)


  )
 #+END_SRC 
 helm-multi-swoop

 Select any buffers by [C-SPC] or [M-SPC]
 Press [RET] to start helm-multi-swoop

 Edit mode

 While doing helm-swoop type C-c C-e to enter the edit mode. Before enter the edit mode, you can choose some lines marked by C-SPC or M-SPC to edit. Apply changes to original buffer type C-x C-s.

*** helm mu
 https://github.com/emacs-helm/helm-mu

 When you would like to read an email without finishing the helm session, you can select the email and press ~Ctrl-z~
 To search for contacts use `helm-mu-contacts`

 #+BEGIN_SRC emacs-lisp :results none
 (use-package helm-mu
  :ensure t
  :config
   )
 #+END_SRC
*** helm-projectile

 #+BEGIN_SRC emacs-lisp :results none
 (use-package helm-projectile
  :ensure t
  :config
 
  )
 #+END_SRC
*** helm-flyspell

#+BEGIN_SRC emacs-lisp :results none
(use-package helm-flyspell
 :ensure t
 :config
 
 )
#+END_SRC
*** helm-buffers-list
#+BEGIN_SRC emacs-lisp  :results none
 (defun z/helm-buffers-dired ()
   "show dired buffers"
   (interactive)
   (helm :sources '(helm-source-buffers-list)
         :full-frame t
         :input "*dired "
        ))

 (defun z/helm-buffers-org ()
   "show dired buffers"
   (interactive)
   (helm :sources '(helm-source-buffers-list)
         :full-frame t
         :input "*org "
        ))
#+END_SRC

** help-fns+
http://www.emacswiki.org/emacs/help-fns+.el

used also in dired
#+BEGIN_SRC emacs-lisp :results none
(use-package help-fns+
 :ensure t
 :config
 
 )
#+END_SRC 


** helm bibtex
https://github.com/tmalsburg/helm-bibtex
*** settings
Helm-bibtex assumes that the name of a PDF consists of the BibTeX key followed by the suffix .pdf. For example, if a BibTeX entry has the key Darwin1859, helm-bibtex searches for Darwin1859.pdf.

 #+BEGIN_SRC emacs-lisp :results none
 (use-package helm-bibtex
  :ensure t
  :config

 ;;;if not installing through MELPA
 ;;;(autoload 'helm-bibtex "helm-bibtex" "" t)

 ;;; telling helm-bibtex where your bibliographies can be found:
 (setq helm-bibtex-bibliography '("/home/zeltak/org/files/Uni/papers/kloog.papers.bib" "/home/zeltak/org/files/Uni/papers/library.bib" "/home/zeltak/org/files/Uni/papers/kloog.papers.misc.bib" ))

 ;;Specify where PDFs can be found:
 (setq helm-bibtex-library-path (list "/home/zeltak/Sync/Uni/pdf_lib/" "/home/zeltak/Sync/Uni/pdf_lib_gen/") ) 

 ;;;If the BibTeX entries have a field that specifies the full path to the PDFs, that field can also be used
 (setq helm-bibtex-pdf-field "File")

 ;;;; Note files
 (setq helm-bibtex-notes-path "/home/zeltak/org/files/Uni/papers/notes")
 (setq helm-bibtex-notes-extension ".org")

 (setq helm-bibtex-format-citation-functions
   '((org-mode      . helm-bibtex-format-citation-org-link-to-PDF)
     (latex-mode    . helm-bibtex-format-citation-cite)
     (markdown-mode . helm-bibtex-format-citation-pandoc-citeproc)
     (default       . helm-bibtex-format-citation-default)))

 ;;Fields used for searching
 (setq helm-bibtex-additional-search-fields '(tags))

 ;;;Symbols used for indicating the availability of notes and PDF files
 (setq helm-bibtex-pdf-symbol "𝍌")
 (setq helm-bibtex-notes-symbol "✎")

 ;;set default browser
 (setq helm-bibtex-browser-function
   (lambda (url _) (start-process "firefox" "*firefox*" "firefox" url)))
 ;;  (lambda (url _) (start-process "chromium" "*chromium*" "chromium" url)))


  )
 #+END_SRC 

*** my papers 
this example below also restricts to a specific bib file

#+BEGIN_SRC emacs-lisp :results none
 (defun helm-bibtex-ikloog-publications ()
   "Search BibTeX entries authored by me"
   (interactive)
(let ((helm-bibtex-bibliography "/home/zeltak/org/files/Uni/papers/kloog.papers.bib"))
   (helm :sources '(helm-source-bibtex)
         :full-frame t
         :input "kloog !kprep !ktalk !kconf !unpublished "
         :candidate-number-limit 500)))

#+END_SRC
*** papers RTODO (to read)
this example below also restricts to a specific bib file

#+BEGIN_SRC emacs-lisp :results none
 (defun helm-bibtex-papers-rtodo ()
   "Search BibTeX entries authored by me"
   (interactive)
(let ((helm-bibtex-bibliography "/home/zeltak/org/files/Uni/papers/library.bib"))
   (helm :sources '(helm-source-bibtex)
         :full-frame t
         :input "rtodo "
         :candidate-number-limit 500)))

#+END_SRC


*** my papers (all)
#+BEGIN_SRC emacs-lisp :results none

 ;; Define helm-search with predefined search expression:
 (defun helm-bibtex-ikloog-publications-all ()
   "Search BibTeX entries authored by me (ALL including prep)"
   (interactive)
   (helm :sources '(helm-source-bibtex)
         :full-frame t
         :input "kloog !unpublished "
         :candidate-number-limit 500))
#+END_SRC

*** my prepared maunscripts
#+BEGIN_SRC emacs-lisp :results none

 ;; Define helm-search with predefined search expression:
 (defun helm-bibtex-ikloog-prep         ()
   "Search BibTeX entries in preperation with me"
   (interactive)
   (helm :sources '(helm-source-bibtex)
         :full-frame t
         :input "kloog kprep !unpublished "
         :candidate-number-limit 500))

 #+END_SRC
** helm-org-rifle
https://github.com/alphapapa/helm-org-rifle

#+BEGIN_SRC emacs-lisp :results none
(use-package helm-org-rifle
 :ensure t
 :config
 )
#+END_SRC 


** mu4e-alert							
https://github.com/iqbalansari/mu4e-alert
#+BEGIN_SRC emacs-lisp :results none
(use-package mu4e-alert
 :ensure t
 :config
;; Choose the style you prefer for desktop notifications
(mu4e-alert-set-default-style 'libnotify)
(add-hook 'after-init-hook #'mu4e-alert-enable-notifications) 
(add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
;;below will color the fringe (left side of an Emacs window)..worked but couldn't see how to disable it
;;;(alert-add-rule :category "mu4e-alert" :style 'fringe :predicate (lambda (_) (string-match-p "^mu4e-" (symbol-name major-mode))) :continue t)
(mu4e-alert-enable-notifications)

 )
#+END_SRC 

*** to restore the fringe to to a bug
#+BEGIN_SRC emacs-lisp :results none
(defun alert-fringe-restore (info)
  (copy-face 'alert-saved-fringe-face 'fringe))
#+END_SRC

** Highlight symbol
https://github.com/nschum/highlight-symbol.el
highlight word at point and move forward next to other words
#+BEGIN_SRC emacs-lisp :results none
(use-package highlight-symbol
 :ensure t
 :config
 )
#+END_SRC 
** TODO iedit
https://github.com/victorhge/iedit

#+BEGIN_SRC emacs-lisp :results none
(use-package iedit
 :ensure t
 :config
 )
#+END_SRC 


** ivy (completion package by abo-abo)
http://oremacs.com/2015/04/16/ivy-mode/
*** enable fuzzy matching by default
#+BEGIN_SRC emacs-lisp :results none
(setq ivy-re-builders-alist
      '((t . ivy--regex-fuzzy)))
#+END_SRC
*** Enable fancy mode
#+BEGIN_SRC emacs-lisp :results none
(setq ivy-display-style 'fancy)

(custom-set-faces
 '(swiper-minibuffer-match-face-1
   ((t :background "#dddddd")))
 '(swiper-minibuffer-match-face-2
   ((t :background "#bbbbbb" :weight bold)))
 '(swiper-minibuffer-match-face-3
   ((t :background "#bbbbff" :weight bold)))
 '(swiper-minibuffer-match-face-4
   ((t :background "#ffbbff" :weight bold))))
#+END_SRC
*** show more verbose matching 
#+BEGIN_SRC emacs-lisp :results none
(setq ivy-count-format "(%d/%d) ")
#+END_SRC
The key bindings are:

RET will select the current candidate and finish.
C-j will try to continue the completion, i.e. if the current candidate is a directory, move to that directory. But if the current candidate is a file or ./, then finish.
/ will switch to completing the sub-directories of /, but if the candidate is a perfect match, it will act like C-j.
~ will switch to completing the sub-directories of ~/.
C-n and C-p naturally select the next and the previous candidate.
** ibuffer

#+BEGIN_SRC emacs-lisp  :results none
;; Use human readable Size column instead of original one
(define-ibuffer-column size-h
  (:name "Size" :inline t)
  (cond
   ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
   ((> (buffer-size) 100000) (format "%7.0fk" (/ (buffer-size) 1000.0)))
   ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
   (t (format "%8d" (buffer-size)))))

;; Modify the default ibuffer-formats
  (setq ibuffer-formats
	'((mark modified read-only " "
		(name 18 18 :left :elide)
		" "
		(size-h 9 -1 :right)
		" "
		(mode 16 16 :left :elide)
		" "
		filename-and-process)))
#+END_SRC
** org-grep
https://github.com/pinard/org-grep

#+BEGIN_SRC emacs-lisp :results none
(use-package org-grep
 :ensure t
 :config

 )
#+END_SRC 


** org highlight
#+BEGIN_SRC emacs-lisp :results none
;(require 'highlights)
;; make sure you have dash, helm, helm-bibtex, ebib, s, f, hydra and key-chord
;; in your load-path
;require 'highlights)
#+END_SRC

** hydra
 #+BEGIN_SRC emacs-lisp :results none
(use-package hydra
:ensure t 
:config
(require 'hydra-examples) ;;for window splits etc
)
 #+END_SRC
** indent guide
#+BEGIN_SRC emacs-lisp :results none
(use-package indent-guide
:ensure t
:config
)
#+END_SRC
** ispell
#+BEGIN_SRC emacs-lisp :results none
(setq ispell-personal-dictionary "~/.emacs.d/ispell-dico-personal")
;;below command skipps checking inside org mode code blocks 
(add-to-list 'ispell-skip-region-alist '("#\\+begin_src". "#\\+end_src"))
#+END_SRC
** key-chord
 #+BEGIN_SRC emacs-lisp :results none
(use-package key-chord 
  :ensure t
  :config
(key-chord-mode 1)
(setq key-chord-two-keys-delay 0.16)
(setq key-chord-one-key-delay 0.20)
)
#+END_SRC
** TODO keyfreq

#+BEGIN_SRC emacs-lisp :results none
(use-package keyfreq
 :ensure t
 :config
 (require 'keyfreq)
(setq keyfreq-excluded-commands
      '(self-insert-command
        abort-recursive-edit
        previous-line
        next-line))
(keyfreq-mode 1)
(keyfreq-autosave-mode 1)
 )
#+END_SRC 


** link hint
https://github.com/noctuid/link-hint.el
#+BEGIN_SRC emacs-lisp :results none
(use-package link-hint
 :ensure t
 :config
 ;; Use chromium to open urls
(setq browse-url-browser-function 'browse-url-chromium)
;; You can alternatively change this setting in the config

;;; mu4e
(defun my/mu4e-open-all-attachments ()
  "Open all visible mu4e attachments."
  (interactive)
  (let ((link-hint-ignore-types
         (remove 'mu4e-attachment link-hint-all-types-list))
        link-hint-act-on-all-ignore-types)
    (link-hint-open-all-links)))
 )
#+END_SRC 
** lentic mode
https://github.com/phillord/lentic

#+BEGIN_SRC emacs-lisp :results none
(use-package lentic
 :ensure t
 :config
 )
#+END_SRC
** magit
https://github.com/magit/magit
#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package magit
  ;;  :ensure t
  ;;  :config
  ;;   )
#+END_SRC 

** manage-minor-mode  

https://github.com/ShingoFukuyama/manage-minor-mode

Set minor-modes status for each major-mode in advance

#+BEGIN_SRC emacs-lisp :results none
(setq manage-minor-mode-default
      '((global
         (on   rainbow-mode)
         (off  line-number-mode))
         (emacs-lisp-mode
         (on   rainbow-delimiters-mode eldoc-mode show-paren-mode))
         (js2-mode
         (on   color-identifiers-mode)
         (off  flycheck-mode))))
#+END_SRC

** mic-parens
better parens match than bulit in Emacs one 
#+BEGIN_SRC emacs-lisp :results none
(use-package mic-paren
 :ensure t
 :config
  )
#+END_SRC
** mu4e-maildirs-extension
https://github.com/agpchil/mu4e-maildirs-extension
#+BEGIN_SRC emacs-lisp :results none
;(use-package mu4e-maildirs-extension
; :ensure t
; :config
;(setq mu4e-maildirs-extension-title "Mail")
;(setq mu4e-maildirs-extension-custom-list (quote ("INBOX" "Starred"  )))
; )
#+END_SRC

** multiple-cursors
https://github.com/magnars/multiple-cursors.el

#+BEGIN_SRC emacs-lisp :results none
(use-package multiple-cursors
 :ensure t
 :config
 (require 'multiple-cursors)
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)

 )
#+END_SRC 
When you want to add multiple cursors not based on continuous lines, but based on keywords in the buffer, use:

(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)

First mark the word, then add more cursors.
** TODO muli-term
https://www.emacswiki.org/emacs-test/MultiTerm
also: https://iloveemacs.wordpress.com/2014/09/10/emacs-as-an-advanced-terminal-multiplexer/

#+BEGIN_SRC emacs-lisp :results none
(use-package multi-term
 :ensure t
 :config
 
 )
#+END_SRC

** TODO mouse copy

#+BEGIN_SRC emacs-lisp  :results none
  ;; ;;; Mouse Copy
  ;; (use-package mouse-copy
  ;;  :ensure t
  ;;   :bind (:map modi-mode-map
  ;;          ;; Mouse drag secondary pasting
  ;;          ;; Put the point at one place, then click-drag using the below binding,
  ;;          ;; and the selected region will be COPIED at the point location.
  ;;          ("<s-down-mouse-1>" . mouse-drag-secondary-pasting)
  ;;          ;; Mouse drag secondary moving
  ;;          ;; Put the point at one place, then click-drag using the below binding,
  ;;          ;; and the selected region will be MOVED to the point location.
  ;;          ("<S-s-down-mouse-1>" . mouse-drag-secondary-moving)))
#+END_SRC


** nlinum

#+BEGIN_SRC emacs-lisp :results none
(use-package nlinum
 :ensure t
 :config

 )
#+END_SRC 

** org-ref
*** config 
#+BEGIN_SRC emacs-lisp  :results none
 (use-package org-ref 
   :ensure t
   :config
(require 'org-ref)
;; for pdf support  
(require 'org-ref-pdf)
(require 'org-ref-url-utils)

;;(setq reftex-default-bibliography '("/home/zeltak/org/files/Uni/papers/kloog.papers.bib"))

(setq reftex-default-bibliography
      (quote
       ("/home/zeltak/org/files/Uni/papers/library.bib" "/home/zeltak/org/files/Uni/papers/kloog.papers.bib")))

  ;; see org-ref for use of these variables
  (setq org-ref-bibliography-notes "/home/zeltak/org/files/Uni/papers/notes/"
        org-ref-default-bibliography '("/home/zeltak/org/files/Uni/papers/kloog.papers.bib" "/home/zeltak/org/files/Uni/papers/library.bib" )
        org-ref-pdf-directory "/home/zeltak/Sync/Uni/pdf_lib/")

  (setq bibtex-autokey-year-length 4
        bibtex-autokey-name-year-separator "-"
        bibtex-autokey-year-title-separator "-"
        bibtex-autokey-titleword-separator "-"
        bibtex-autokey-titlewords 2
        bibtex-autokey-titlewords-stretch 1
        bibtex-autokey-titleword-length 5)
   )
#+END_SRC

** org link edit
https://github.com/kyleam/org-link-edit
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/org-link-edit/")
(require 'org-link-edit)
#+END_SRC

** org-bullets
https://github.com/sabof/org-bullets

#+BEGIN_SRC emacs-lisp :results none
  (use-package org-bullets 
   :ensure t
   :config
(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
(setq  org-bullets-bullet-list '(
    "①"
    "②"
    "③ "
    "④"
    "⑤"
    "⑥"
    "⑦"
    "⑧"
    "⑨"
    "⑩"
    "⑪"
    "⑫"
    "⑬"
    "⑭"
    "⑮"
    ))
 )
#+END_SRC
** TODO org-bookmark-heading
http://stable.melpa.org/#/org-bookmark-heading
#+BEGIN_SRC emacs-lisp :results none
(use-package org-bookmark-heading
 :ensure t
 :config
(require 'org-bookmark-heading) 
 )
#+END_SRC 


** org-cliplink
https://github.com/rexim/org-cliplink

#+BEGIN_SRC emacs-lisp :results none
(use-package org-cliplink
 :ensure t
 :config
 
 )
#+END_SRC 
** org-Download
   :PROPERTIES:
   :ID:       54e01618-35eb-45c5-b0b7-6f830faef316
   :Attachments: screenshot_2015-04-05_08:15:22.png
   :END:
provides function to drag images from browser and link address
$Note$ this requires package async to be installed, @async must be loaded before this package@

#+BEGIN_SRC emacs-lisp :results none
  (use-package org-download 
   :ensure t
   :config
   (setq-default org-download-heading-lvl nil)
   (setq-default org-download-image-dir "/home/zeltak/Sync/attach/images_2015")
   ;;; to get rid of the #+DOWNLOADED part
;;(setq org-download-annotate-function (lambda (_) ""))
  )
 #+END_SRC

*** old configs 
#+BEGIN_SRC emacs-lisp :results none
  ;; (setq org-download-method 'attach
  ;;        org-download-screenshot-method "scrot -s %s"
  ;;        org-download-backend (if (executable-find "curl") "curl \"%s\" -o \"%s\"" t)))
#+END_SRC

 #+BEGIN_SRC emacs-lisp :results none
;(if (string= system-name "voices") (setq-default org-download-image-dir "/home/zeltak/org/attach/images_2014/") (setq-default org-download-image-dir "/media/NAS/Uni/org/attach/images_2013/"))                                                           
 #+END_SRC\N
** org-dp (wrap code blocks functions) 
https://github.com/tj64/org-dp


#+BEGIN_SRC emacs-lisp :results none
(use-package org-dp
 :ensure t
 :config
 (require 'org-dp-lib)
 )
#+END_SRC 
*** TODO my wrap functions

#+BEGIN_SRC emacs-lisp :results none
(when (require 'org-dp-lib nil t)

;;;;;;;;;; wrap in elisp
  (defun z/wrap-elisp ()
        (org-dp-wrap-in-block
         nil '(src-block nil nil nil (:language "emacs-lisp" :preserve-indent 1  :parameters ":results none" ))))

;for hydra create interactive new functions
(defun z/hydra-wrap-elisp () (interactive) (beginning-of-line) (z/wrap-elisp))

;;;;;;;;;; wrap in bash
  (defun z/wrap-bash ()
        (org-dp-wrap-in-block
         nil '(src-block nil nil nil (:language "sh" :preserve-indent 1  :parameters ":results none" ))))

;for hydra create interactive new functions
(defun z/hydra-wrap-bash () (interactive) (beginning-of-line) (z/wrap-bash))


;;;;;;;;;; wrap in bash
  (defun z/wrap-example ()
        (org-dp-wrap-in-block
         nil '(src-block nil nil nil (:language "example" :preserve-indent 1  :parameters ":results none" ))))

;for hydra create interactive new functions
(defun z/hydra-wrap-example () (interactive) (beginning-of-line) (z/wrap-example))



;;;;;;;;;; wrap in R
  (defun z/wrap-R ()
        (org-dp-wrap-in-block
         nil '(src-block nil nil nil (:language "R" :preserve-indent 1  :parameters ":results none" ))))

;for hydra create interactive new functions
(defun z/hydra-wrap-R () (interactive) (beginning-of-line) (z/wrap-R))

;;;;;;;;;; wrap in latex
  (defun z/wrap-latex ()
        (org-dp-wrap-in-block
         nil '(src-block nil nil nil (:language "latex" :preserve-indent 1  :parameters ":results none" ))))

;for hydra create interactive new functions
(defun z/hydra-wrap-latex () (interactive) (beginning-of-line) (z/wrap-latex))


;end paren
     )
#+END_SRC
** org-colored-text

** org-contacts
#+BEGIN_SRC emacs-lisp :results none
(require 'org-contacts)
#+END_SRC
** org-vcard
https://github.com/flexibeast/org-vcard

also explore how this relates to org-contacs
#+BEGIN_SRC emacs-lisp :results none
(use-package org-vcard
 :ensure t
 :config
 
 )
#+END_SRC 
** org-pandoc
https://github.com/kawabata/ox-pandoc

#+BEGIN_SRC emacs-lisp :results none
(use-package org-pandoc
 :ensure t
 :config
 )
#+END_SRC
** org-pdfview
only enable if pdf-tools is installed 
#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package org-pdfview
  ;;  :ensure t
  ;;  :config
  ;;  )
#+END_SRC 
** pass mode
for password store files : 
https://github.com/NicolasPetton/pass

#+BEGIN_SRC emacs-lisp :results none
(use-package pass
 :ensure t
 :config
  )
#+END_SRC 


** password-store
#+BEGIN_SRC emacs-lisp :results none
(use-package password-store
 :ensure t
 :config
(require 'password-store)
 )
#+END_SRC 

** pandoc-mode
http://joostkremers.github.io/pandoc-mode/
#+BEGIN_SRC emacs-lisp :results none
(use-package pandoc-mode
 :ensure t
 :config
  )
#+END_SRC 
** pabbrev

#+BEGIN_SRC emacs-lisp :results none
(use-package  pabbrev
 :ensure t
 :config
(require 'pabbrev)
;; to autoload
(global-pabbrev-mode)

 )
#+END_SRC 

** pdf-tools
https://github.com/politza/pdf-tools

@this currently seems to screwup many things in Emacs so its disabled@

#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package pdf-tools
  ;;  :ensure t
  ;;  :config
  ;; (pdf-tools-install)
  ;; (eval-after-load 'org '(require 'org-pdfview))
  ;; (add-to-list 'org-file-apps '("\\.pdf\\'" . org-pdfview-open))
  ;; (add-to-list 'org-file-apps '("\\.pdf::\\([[:digit:]]+\\)\\'" . org-pdfview-open))


  ;;   )
#+END_SRC 

** projectile

@Warning@: projectile global mode will kill ssh/sudo in tramp with hanging in:
#+BEGIN_EXAMPLE
Decrypting /home/chz/.authinfo.gpg...done
#+END_EXAMPLE
follow this : https://github.com/bbatsov/projectile/issues/835 for more details 

#+BEGIN_SRC emacs-lisp :results none
  (use-package projectile
   :ensure t
   :config
;;;disable global mode otherwise it kills tramp shh
;;(projectile-global-mode)
;; caching can significantly speedup file and directory listings, making it display instantly.
(setq projectile-enable-caching t)


;;(setq projectile-completion-system 'grizzl)
(setq projectile-completion-system 'helm)
(helm-projectile-on)
;;(setq projectile-switch-project-action 'helm-projectile-find-file)
(setq projectile-switch-project-action 'helm-projectile)

(setq projectile-globally-ignored-directories
      (append '(
        ".git"
        ".svn"
        "out"
        "repl"
        "target"
        "venv"
        )
          projectile-globally-ignored-directories))
(setq projectile-globally-ignored-files
      (append '(
        ".DS_Store"
        "*.gz"
        "*.pyc"
        "*.jar"
        "*.tar.gz"
        "*.tgz"
        "*.zip"
        )
          projectile-globally-ignored-files))

   )
#+END_SRC
** perspective

#+BEGIN_SRC emacs-lisp :results none
(use-package perspective
 :ensure t
 :config

 )
#+END_SRC 


** polymode
https://github.com/vspinu/polymode

#+BEGIN_SRC emacs-lisp :results none
(use-package polymode
 :ensure t
 :config
(require 'poly-R) 
(require 'poly-org)
(add-to-list 'auto-mode-alist '("\\.org" . poly-org-mode))
 )
#+END_SRC 
When point is inside a src-block the local mode prevails.
So:
C-c C-n inside an R src block sends the line point is on to the R process.
C-c C-c sends the region (or function or paragraph) to the process when point is in the body. 
To execute `org-ctrl-c-ctrl-c' on the src block with the C-c C-c keying, it is necessary to move point to before or after the body.
** TODO popup-imenu
https://github.com/ancane/popup-imenu
#+BEGIN_SRC emacs-lisp :results none
(use-package popup-imenu
 :ensure t
 :config
 
 )
#+END_SRC 


** Rainbow mode
http://julien.danjou.info/projects/emacs-packages#rainbow-mode

fix or update since it seems broken and colors are white

#+BEGIN_SRC emacs-lisp :results none
  (use-package rainbow-mode
  :ensure t
  :config
  )

  (dolist (hook '(css-mode-hook
                  html-mode-hook
                  js-mode-hook
                  emacs-lisp-mode-hook
                  org-mode-hook
                  text-mode-hook
                  ))
    (add-hook hook 'rainbow-mode))
#+END_SRC
** rainbow-delimiters
https://github.com/Fanael/rainbow-delimiters
#+BEGIN_SRC emacs-lisp :results none
(use-package rainbow-delimiters
 :ensure t
 :config
 (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
(require 'rainbow-delimiters)
(set-face-attribute 'rainbow-delimiters-unmatched-face nil
                    :foreground 'unspecified
                    :inherit 'error)
 )
#+END_SRC 
** Ranger
   :PROPERTIES:
   :ID:       326350a8-94ad-4a3c-bf9f-e9cbe6a68528
   :END:
https://github.com/ralesi/ranger/

#+BEGIN_SRC emacs-lisp :results none
(use-package ranger
 :ensure t
 :config
(setq ranger-cleanup-eagerly t)
(setq ranger-show-dotfiles t)
(setq ranger-parent-depth 1)
(setq ranger-ignored-extensions '("mkv" "iso" "mp4"))
(setq ranger-cleanup-on-disable t)
(setq ranger-show-literal t)
(setq ranger-width-preview 0.55)

 )
#+END_SRC 
【we】 to open in external app 

** scratch
Instant scratch buffer for current mode
http://pragmaticemacs.com/emacs/instant-scratch-buffer-for-current-mode/

#+BEGIN_SRC emacs-lisp :results none
(use-package scratch
 :ensure t
 :config
 (autoload 'scratch "scratch" nil t)
 )
#+END_SRC
** shrink-whitespace
#+BEGIN_SRC emacs-lisp :results none
(use-package shrink-whitespace
 :ensure t
 :config
 )
#+END_SRC 
** Shell-pop

https://github.com/kyagi/shell-pop-el

#+BEGIN_SRC emacs-lisp :results none
(use-package shell-pop
 :ensure t
 :config
 (custom-set-variables
 '(shell-pop-default-directory "/home/zeltak/")
 '(shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
 '(shell-pop-term-shell "/bin/zsh")
 '(shell-pop-universal-key "C-t")
 '(shell-pop-window-size 30)
 '(shell-pop-full-span t)
 '(shell-pop-window-position "bottom"))
 )
#+END_SRC 
** smart tab
https://github.com/genehack/smart-tab

#+BEGIN_SRC emacs-lisp :results none
(use-package  smart-tab 
 :ensure t
 :config
(require 'smart-tab)
(global-smart-tab-mode 1)

(setq smart-tab-disabled-major-modes
      (list 'term-mode
            'inferior-python-mode 'rcirc-mode  'mu4e-view-mode
            'mu4e-main-mode 'mu4e-headers-mode 
            'mu4e-about-mode))

(setq hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name
        try-complete-lisp-symbol))

(setq smart-tab-using-hippie-expand t)

 )
#+END_SRC 


** smart comment
https://github.com/paldepind/smart-comment

#+BEGIN_SRC emacs-lisp :results none
(use-package smart-comment
 :ensure t
 :config
 :bind ("M-;" . smart-comment) 
 )
#+END_SRC 


** smooth-scrolling
https://github.com/aspiers/smooth-scrolling

for "normal" scrolling

#+BEGIN_SRC emacs-lisp :results none
(use-package smooth-scrolling
 :ensure t
 :config
(require 'smooth-scrolling)
 )
#+END_SRC 


** smex
@needed for counsel ivy completions@
#+BEGIN_SRC emacs-lisp :results none
(use-package smex
:ensure t
:config
)
#+END_SRC
** sunrise-commander
*** main 
http://www.emacswiki.org/emacs/Sunrise_Commander_Tips
#+BEGIN_SRC emacs-lisp :results none
(use-package sunrise-commander
 :ensure t
 :config
;;what to shoe in list view
(setq sr-attributes-display-mask '(nil nil t t t t t))
;start with no attributes in view (if set to nil)
(setq sr-show-file-attributes nil)
;sorting
(setq sr-listing-switches "--time-style=locale --group-directories-first -AlDhgG")


;;disbale F keys
;(setq sr-use-commander-keys nil)


;Here’s how to disable “click to visit file” and “cursor follows mouse”.
(setq sr-cursor-follows-mouse nil)
(setq sr-toggle-attribute 1)
(define-key sr-mode-map [mouse-1]        nil)
(define-key sr-mode-map [mouse-movement] nil)

;;nicer icons in modline
(setq sr-modeline-use-utf8-marks t)
;;where is avfs root
(setq sr-avfs-root "~/.avfs")

 )
#+END_SRC 
*** plugins
**** sunrise-x-popviewer

 #+BEGIN_SRC emacs-lisp :results none
 (use-package sunrise-x-popviewer
  :ensure t
  :config
(require 'sunrise-x-popviewer)
(sr-popviewer-mode 1)
;; to open in next pane and not new window
(setq sr-popviewer-select-viewer-action
         (lambda nil (let ((sr-running nil)) (other-window 1))))
  )
 #+END_SRC 
**** sunrise-x-mirror

#+BEGIN_SRC emacs-lisp :results none
(use-package sunrise-x-mirror
 :ensure t
 :config
 (require 'sunrise-x-mirror)
(setq sr-mirror-unionfs-impl (quote unionfs-fuse))
 )
#+END_SRC 
**** sunrise-x-loop
when yo need to copy of move any big files, just prefix the appropriate command with C-u.

#+BEGIN_SRC emacs-lisp :results none
(use-package sunrise-x-loop
 :ensure t
 :config
(require 'sunrise-x-loop) 
 )
#+END_SRC 

**** sunrise-x-modeline
#+BEGIN_SRC emacs-lisp :results none
  (use-package  sunrise-x-modeline
   :ensure t
   :config
   )
#+END_SRC 

**** sunrise-x-tabs

#+BEGIN_SRC emacs-lisp :results none
(use-package sunrise-x-tabs
 :ensure t
 :config
;(require 'sunrise‐x‐tabs) 
 )
#+END_SRC 

**** sunrise-x-checkpoints

#+BEGIN_SRC emacs-lisp :results none
(use-package sunrise-x-checkpoints
 :ensure t
 :config
  )
#+END_SRC 
*** functions
**** open with external programs
#+BEGIN_SRC emacs-lisp :results none
;;; Adding files opened with external apps to the history of recent files.
(defadvice openwith-file-handler
  (around advice-openwith-file-handler (operation &rest args))
  (condition-case description
      ad-do-it
    (error (progn
             (recentf-add-file (car args))
             (error (cadr description))))))
(ad-activate 'openwith-file-handler)

(defun er/sunrise-flatten ()
 (interactive)
 (sr-find "-type f"))

; Kill all sunrise and dired buffers when closing Sunrise Commander
(defun er/kill-all-sunrise-buffers()
      "Kill all dired buffers."
      (interactive)
      (save-excursion
        (let((count 0))
          (dolist(buffer (buffer-list))
            (set-buffer buffer)
            (when (derived-mode-p 'dired-mode 'sr-virtual-mode 'sr-mode)
                (setq count (1+ count))
                (kill-buffer buffer)))
          (message "Killed %i sunrise buffer(s)." count ))))
(setq sr-quit-hook 'er/kill-all-sunrise-buffers)

#+END_SRC 
*** keys
**** main 
#+BEGIN_SRC emacs-lisp :results none
(define-key sr-mode-map (kbd "/") 'sr-fuzzy-narrow) 
(define-key sr-mode-map (kbd "") 'er/sunrise-flatten) 
(define-key sr-mode-map (kbd "\\") 'hydra-sr-chd/body ) 
(define-key sr-mode-map (kbd "`") 'hydra-sunrise-leader/body ) 
;lynx like
(define-key sr-mode-map (kbd "<left>") 'sr-dired-prev-subdir ) 
(define-key sr-mode-map (kbd "<right>") 'sr-advertised-find-file ) 
;move back/forward im history
(define-key sr-mode-map (kbd "M-<left>") 'sr-history-prev ) 
(define-key sr-mode-map (kbd "M-<right>") 'sr-history-next ) 
#+END_SRC
** sr-speedbar
SrSpeedbar is mode make SpeedBar show in Current Frame 
http://www.emacswiki.org/emacs/SrSpeedbar

#+BEGIN_SRC emacs-lisp :results none
(use-package sr-speedbar
 :ensure t
 :config
  )
#+END_SRC 
** Swiper
#+BEGIN_SRC emacs-lisp :results none
(use-package swiper 
 :ensure t
 :config
;(ivy-mode 1)
(setq ivy-use-virtual-buffers t)
(global-set-key "\C-s" 'swiper)
(global-set-key "\C-r" 'swiper-at-point)
(global-set-key (kbd "C-c C-r") 'ivy-resume)
 )
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
(defun swiper-at-point ()
  (interactive)
  (swiper (thing-at-point 'symbol)))
#+END_SRC

** swiper helm
#+BEGIN_SRC emacs-lisp :results none
(use-package swiper-helm
 :ensure t
 :config
  )
#+END_SRC
** twittering-mode
https://github.com/hayamiz/twittering-mode/
#+BEGIN_SRC emacs-lisp :results none
(use-package twittering-mode
 :ensure t
 :config
;; save encrypted password 
(setq twittering-use-master-password t)
;;To display icons
(setq twittering-icon-mode t)
;;save local icons
(setq twittering-use-icon-storage t)
;;start with older first
(setq twittering-reverse-mode t)


 )

#+END_SRC 


** tiny
*** config
https://github.com/abo-abo/tiny
#+BEGIN_SRC emacs-lisp :results none
(use-package tiny
  :config
;  (global-set-key (kbd "C-s-t") 'tiny-expand)
)
#+END_SRC
*** examples
General Format: m[range start][separator(s)][range end]
₆In example₆ 
;; mBSEO|F
;;  ||||||
;;  |||||+--> (optional) Format - %x | 0x%x | %c | %s | %(+ x x) | %014.2f | %03d | %(date "Jan 16" (* x 7))
;;  ||||+---> (optional) Pipe character to separate Format for reading clarity
;;  |||+----> (optional) Operator - *xx | (* x x) | (+ x ?A) | *2+3x | (* 2 (+ 3 x))
;;  ||+-----> End value
;;  |+------> (optional) Separator - Space | , | \n (default=Space)
;;  +-------> (optional) Begin value (default=0)
;; - No space allowed between 'm' and 'B'
;; - No space allowed between 'E' and 'O'
 
Fancier Formatting
Do you know how I generated that numbered list of four elements? I used m1\n\n4|%d., which Tiny expands into:

1.

2.

3.

4.
This demonstrates that you can have multiple separator characters; here I use two \n’s for the extra space. But there is that |%d. at the end. Tiny lets you use Emacs Lisp format strings, which you write at the end of your expression and delimit with a vertical bar. The formatting string %d. prints each number as a digit (%d) with a period after it. Used in conjunction with the newline separators it gives me exactly the output I want for a numbered list in Markdown.
** tabbar
https://www.emacswiki.org/emacs/TabBarMode

http://emacs.stackexchange.com/questions/10081/browser-style-tabs-for-Emacs

#+BEGIN_SRC emacs-lisp :results none
  ;; (use-package tabbar
  ;;  :ensure t
  ;;  :config
  ;; (require 'tabbar)
  ;; ; turn on the tabbar
  ;; (tabbar-mode t)
  ;; ; define all tabs to be one of 3 possible groups: “Emacs Buffer”, “Dired”,
  ;; ;“User Buffer”.

  ;; (defun tabbar-buffer-groups ()
  ;;   "Return the list of group names the current buffer belongs to.
  ;; This function is a custom function for tabbar-mode's tabbar-buffer-groups.
  ;; This function group all buffers into 3 groups:
  ;; Those Dired, those user buffer, and those emacs buffer.
  ;; Emacs buffer are those starting with “*”."
  ;;   (list
  ;;    (cond
  ;;     ((string-equal "*" (substring (buffer-name) 0 1))
  ;;      "Emacs Buffer"
  ;;      )
  ;;     ((eq major-mode 'dired-mode)
  ;;      "Dired"
  ;;      )
  ;; ((memq major-mode
  ;;        '(org-mode text-mode rst-mode))
  ;;  "org"
  ;;  )

  ;;    (t
  ;;      "General"
  ;;      )
  ;;     ))) 

  ;; (setq tabbar-buffer-groups-function 'tabbar-buffer-groups)

  ;; ;;Sort tabbar buffers by name

  ;; (defun tabbar-add-tab (tabset object &optional append_ignored)
  ;;   "Add to TABSET a tab with value OBJECT if there isn't one there yet.
  ;; If the tab is added, it is added at the beginning of the tab list,
  ;; unless the optional argument APPEND is non-nil, in which case it is
  ;; added at the end."
  ;;   (let ((tabs (tabbar-tabs tabset)))
  ;;     (if (tabbar-get-tab object tabset)
  ;;         tabs
  ;;       (let ((tab (tabbar-make-tab object tabset)))
  ;;         (tabbar-set-template tabset nil)
  ;;         (set tabset (sort (cons tab tabs)
  ;;                           (lambda (a b) (string< (buffer-name (car a)) (buffer-name (car b))))))))))

  ;;  )
#+END_SRC 
** transmission
need to install let-alist and seq packages from melpa
https://github.com/holomorph/transmission/issues/1

#+BEGIN_SRC emacs-lisp :results none
(use-package transmission
 :ensure t
 :config
(require 'transmission)
(setq transmission-host "10.0.0.2")
(setq transmission-rpc-auth '(:username "zeltak" :password "salar" ) )
 )
#+END_SRC 


#+BEGIN_SRC emacs-lisp :results none
;(add-to-list 'load-path "/home/zeltak/.emacs.g/transmission/")
;(setq transmission-host "10.0.0.2")
#+END_SRC

** Undo tree
#+BEGIN_SRC emacs-lisp :results none
(use-package undo-tree 
:ensure t
:config
(global-undo-tree-mode 1)
(setq undo-tree-auto-save-history t)
(setq undo-tree-history-directory-alist '((".*" . "~/.emacs.t/undo-files")))
(setq undo-tree-mode-lighter "")	 
)
#+END_SRC
** vimish-fold 

#+BEGIN_SRC emacs-lisp :results none
(use-package vimish-fold
 :ensure t
 :config
 (require 'vimish-fold)
;(global-set-key (kbd "<menu> v f") #'vimish-fold)
;(global-set-key (kbd "<menu> v v") #'vimish-fold-delete)
 )
#+END_SRC 


** unfill
https://github.com/purcell/unfill

makes or unmakes a marked section wider/shorter (look fill command)

#+BEGIN_SRC emacs-lisp :results none
(use-package unfill
:ensure t
:config
)
#+END_SRC
** volatile-highlights
https://github.com/k-talo/volatile-highlights.el
#+BEGIN_SRC emacs-lisp :results none
(use-package volatile-highlights
 :ensure t
 :config
(require 'volatile-highlights)
(volatile-highlights-mode t) 
 )
#+END_SRC 

** wanderlust
#+BEGIN_SRC emacs-lisp 1p:results none
(use-package wanderlust
 :ensure t
 :config
 
 )
#+END_SRC 

** worf
look here for more details on keybinds
https://github.com/abo-abo/worf/blob/master/worf.el
this package us

#+BEGIN_SRC emacs-lisp :results none
(use-package worf
 :ensure t
 :config
 )
#+END_SRC 

** weechat.el

#+BEGIN_SRC emacs-lisp :results none
  (use-package weechat
   :ensure t
   :config
  (require 'weechat)
(setq weechat-modules '(weechat-button
                        weechat-complete
                        weechat-spelling
                        weechat-corrector
                        weechat-tracking
                        weechat-notifications))
   )
#+END_SRC 

#+BEGIN_SRC emacs-lisp :results none
(eval-after-load 'weechat
  '(progn
     (setq weechat-host-default "karif.server-speed.net"
           weechat-port-default 9001
           weechat-color-list
           '(unspecified "black" "dark gray" "dark red" "red"
                         "dark green" "light green" "brown"
                         "yellow" "RoyalBlue3"
                         "light blue"
                         "dark magenta" "magenta" "dark cyan"
                         "light cyan" "gray" "white")
           weechat-prompt "> "
           weechat-notification-mode t
           weechat-auto-monitor-buffers t 
           weechat-complete-nick-ignore-self nil
           weechat-button-buttonize-nicks nil
           weechat-tracking-types '(:highlight (".+#weechat.el" . :message))
           weechat-sync-active-buffer t)
     (setq weechat-auto-monitor-buffers
      '("freenode.#gmpc"
        "bitlbee.rasi"))
     (set-face-background 'weechat-highlight-face "dark red")
     (set-face-foreground 'weechat-highlight-face "light grey")
     (add-hook 'weechat-mode-hook 'visual-line-mode)
     (tracking-mode)))
#+END_SRC

** winner-mode
#+BEGIN_SRC emacs-lisp :results none
(winner-mode 1)
#+END_SRC
** which key
https://github.com/justbur/emacs-which-key
#+BEGIN_SRC emacs-lisp :results none
(use-package which-key
 :ensure t
 :config
(which-key-mode)

;;Popup side window on right. For defaults use
;;(which-key-setup-side-window-right)

 )
#+END_SRC 


** Wrap region

https://github.com/rejeep/wrap-region.el

#+BEGIN_SRC emacs-lisp :results none
(use-package wrap-region
  :ensure t
  :config
  (wrap-region-add-wrappers
   '(("*" "*" nil org-mode)
     ("~" "~" nil org-mode)
     ("/" "/" nil org-mode)
     ("=" "=" nil org-mode)
     ("_" "_" nil org-mode)
     ("%" "%" nil org-mode)
     ("!" "!" nil org-mode)
     ("`" "`" nil org-mode)
     ("'" "'" nil org-mode)
     ("@" "@" nil org-mode)
     ("$" "$" nil (org-mode latex-mode))
))
  (add-hook 'org-mode-hook 'wrap-region-mode)
  (add-hook 'latex-mode-hook 'wrap-region-mode)
)
#+END_SRC 


** workgroup2
http://workgroups2.readthedocs.org/en/latest/guide/installation.html
#+BEGIN_SRC emacs-lisp :results none
;;  (use-package workgroups2
;;  :ensure t
;;  :config
;;  (workgroups-mode 1)        ; put this one at the bottom of .emacs (init.el)
;;  (require 'workgroups2)
 ;; Change workgroups session file
;;  (setq wg-session-file "~/.emacs.d/.emacs_workgroups") 
;;  )
#+END_SRC 

** TODO xah-find
http://ergoemacs.org/emacs/elisp-xah-find-text.html
This is the home page for “xah-find.el”.

This package provides emacs commands for find/replace in a directory, like {grep, rgrep, lgrep, unix sed}, but written entirely in emacs lisp.

This package provides these commands:

xah-find-text
xah-find-text-regex
xah-find-count
xah-find-replace-text
xah-find-replace-text-regex

Press Enter ↵ on a link to jump to the file location. (or mouse clic)k
Press 【Tab ↹】 to jump to next occurence. (【⇧ Shift+Tab ↹】 for previous)
Press 【Alt+p】 or 【Alt+n】 to move cursor to previous/next file name.

#+BEGIN_SRC emacs-lisp :results none
(use-package xah-find
 :ensure t
 :config
  )
#+END_SRC 

** org-reveal (ox-reveal)

#+BEGIN_SRC emacs-lisp :results none
(use-package ox-reveal
 :ensure t
 :config
;;where the root reveal folder is
(setq org-reveal-root  "file:///home/zeltak/apps/reveal.js") 
 )
#+END_SRC 

** org-velocity
#+BEGIN_SRC emacs-lisp
(require 'org-velocity)
#+END_SRC
** Yasnippet
*** load yasnippet

#+BEGIN_SRC emacs-lisp :results none
(use-package yasnippet
:ensure t
 :config 
(require 'yasnippet)
(yas-global-mode 1)
;; Use custom snippets.
(yas-reload-all)
(setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
;for orgmode properties fix 
(setq yas-indent-line 'fixed)
;set insert at point prompt type- here ido
(setq yas/prompt-functions '(yas/ido-prompt
                            yas/completing-prompt))
)
#+END_SRC
*** function helm 
#+BEGIN_SRC emacs-lisp :results none
(defun shk-yas/helm-prompt (prompt choices &optional display-fn)
  "Use helm to select a snippet. Put this into `yas/prompt-functions.'"
  (interactive)
  (setq display-fn (or display-fn 'identity))
  (if (require 'helm-config)
      (let (tmpsource cands result rmap)
        (setq cands (mapcar (lambda (x) (funcall display-fn x)) choices))
        (setq rmap (mapcar (lambda (x) (cons (funcall display-fn x) x)) choices))
        (setq tmpsource
              (list
	       (cons 'name prompt)
	       (cons 'candidates cands)
	       '(action . (("Expand" . (lambda (selection) selection))))
	       ))
        (setq result (helm-other-buffer '(tmpsource) "*helm-select-yasnippet"))
        (if (null result)
            (signal 'quit "user quit!")
          (cdr (assoc result rmap))))
    nil))
#+END_SRC
** TODO quickrun
https://github.com/syohex/emacs-quickrun/
#+BEGIN_SRC emacs-lisp :results none
(use-package quickrun
 :ensure t
 :config

(quickrun-add-command "html"
                      '((:command . "firefox")
                        (:exec    . "%c %s"))
                      :mode 'html-mode) 

 )
#+END_SRC 


* Functions
$Note-all my (zeltak) functions should follow the following base syntax$
#+BEGIN_EXAMPLE
Z/MODENAME-HEADER-SUBHEADER-NAME
#+END_EXAMPLE
** Encoding
*** fix unicode characters
#+BEGIN_SRC emacs-lisp :results none
(defun z-fix-characters 
(start end) 
(interactive "r") 
(let ((buffer-invisibility-spec)) (query-replace-regexp "[^\t\n\r\f -~]" ""))
)

(defun z-fix2-characters ()
  (interactive)
  (let ()
    (query-replace-regexp "[^\t\n\r\f -~]" "")
    ))
#+END_SRC
** Editing
*** Increment years

#+BEGIN_SRC emacs-lisp
(defun z-year-increment  (buffer max-year)
  (interactive "b\nsMax year (yy): ")
  (setq max-year (string-to-number max-year))
  (let ((year 2003)
        (newbuf (get-buffer-create "increment-year")))
    (let ((s (with-current-buffer buffer
               (buffer-substring (point-min) (point-max)))))
      (dotimes (n (1+ max-year))
        (with-current-buffer newbuf
          (goto-char (point-max))
          (insert "\n")
          (insert (replace-regexp-in-string (int-to-string year)
                                            (int-to-string (+ year n))
                                            s)))))
    (switch-to-buffer newbuf)))
#+END_SRC

#+RESULTS:
: z-year-increment

*** Get rid of blank lines
#+BEGIN_SRC emacs-lisp :results none
(defun flush-blank-lines ()
    "Removes all blank lines from buffer or region"
     (interactive)
     (save-excursion
       (let (min max)
         (if (equal (region-active-p) nil)
             (mark-whole-buffer))
         (setq min (region-beginning) max (region-end))
         (flush-lines "^ *$" min max t))))
#+END_SRC 
*** Join lines

#+BEGIN_SRC emacs-lisp :results none
(global-set-key (kbd "M-j")
            (lambda ()
                  (interactive)
                  (join-line -1)))
#+END_SRC
*** Fill/unfill paragraph
#+BEGIN_SRC emacs-lisp :results none
(defun unfill-paragraph ()
  "Replace newline chars in current paragraph by single spaces.
This command does the inverse of `fill-paragraph'."
  (interactive)
  (let ((fill-column 90002000)) ; 90002000 is just random. you can use `most-positive-fixnum'
    (fill-paragraph nil)))

(defun unfill-region (start end)
  "Replace newline chars in region by single spaces.
This command does the inverse of `fill-region'."
  (interactive "r")
  (let ((fill-column 90002000))
    (fill-region start end)))

#+END_SRC
*** count sentences
#+BEGIN_SRC emacs-lisp
(defun count-sentences (begin end &optional print-message)
  "Count the number of sentences from BEGIN to END."
  (interactive (if (use-region-p)
		   (list (region-beginning)
			 (region-end)
			 t)
		 (list nil nil t)))
  (save-excursion
    (save-restriction
      (narrow-to-region (or begin (point-min))
			(progn
			  (goto-char (or end (point-max)))
			  (skip-chars-backward " \t\n")
			  (point)))
      (goto-char (point-min))
      (let ((sentences 0))
	(while (not (looking-at-p "[ \t\n]*\\'"))
	  (forward-sentence 1)
	  (setq sentences (1+ sentences)))
	(if print-message
	    (message
	     "%s sentences in %s."
	     sentences
	     (if (use-region-p)
		 "region"
	       "buffer"))
	  sentences)))))
#+END_SRC

*** Count words in region
#+BEGIN_SRC emacs-lisp :results none

(defun z-count-words-region (posBegin posEnd)
  "Print number of words and chars in region."
  (interactive "r")
  (message "Counting …")
  (save-excursion
    (let (wordCount charCount)
      (setq wordCount 0)
      (setq charCount (- posEnd posBegin))
      (goto-char posBegin)
      (while (and (< (point) posEnd)
                  (re-search-forward "\\w+\\W*" posEnd t))
        (setq wordCount (1+ wordCount)))

      (message "Words: %d. Chars: %d." wordCount charCount)
      )))

#+END_SRC
*** Copy and comment
#+BEGIN_SRC emacs-lisp :results none
(defun z/copy-comment-paste ()
  "copy active region/current line, comment, and then paste"
  (interactive)
  (unless (use-region-p)
    (progn
      (beginning-of-line 2)
      (push-mark (line-beginning-position 0))))
  (kill-ring-save (region-beginning) (region-end))
  (comment-region (region-beginning) (region-end))
  (yank)
  (exchange-point-and-mark)
  (indent-according-to-mode))
#+END_SRC
*** comment/uncomment line
#+BEGIN_SRC emacs-lisp :results none
(defun z/comment-line (n)
  "Comment or uncomment current line and leave point after it.
With positive prefix, apply to N lines including current one.
With negative prefix, apply to -N lines above.
If region is active, apply to active region instead."
  (interactive "p")
  (if (use-region-p)
      (comment-or-uncomment-region
       (region-beginning) (region-end))
    (let ((range
           (list (line-beginning-position)
                 (goto-char (line-end-position n)))))
      (comment-or-uncomment-region
       (apply #'min range)
       (apply #'max range)))
    (forward-line 1)
    (back-to-indentation)))

#+END_SRC

*** move line up/down
    #+BEGIN_SRC emacs-lisp :results none
(defun move-line-up ()
  "Move up the current line."
  (interactive)
  (transpose-lines 1)
  (forward-line -2)
  (indent-according-to-mode))

(defun move-line-down ()
  "Move down the current line."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1)
  (indent-according-to-mode))

#+END_SRC
*** insert date
#+BEGIN_SRC emacs-lisp :results none
(defun z-insert-date (&optional addTimeStamp-p)
  "Insert current date and or time. In this format yyyy-mm-dd.
 When called with `universal-argument', insert date and time, e.g. 2012-05-28T07:06:23-07:00
 Replaces text selection.See also `current-date-time-string'."
  (interactive "P")
  (when (region-active-p) (delete-region (region-beginning) (region-end) ) )
  (cond
   ((equal addTimeStamp-p nil ) (insert (format-time-string "%Y-%m-%d")))
   (t (insert (current-date-time-string))) ) )
#+END_SRC
*** copy/paste to/from x clip

#+BEGIN_SRC emacs-lisp :results none
(defun copy-to-x-clipboard ()
  (interactive)
  (if (region-active-p)
      (progn
        (cond
         ((and (display-graphic-p) x-select-enable-clipboard)
          (x-set-selection 'CLIPBOARD (buffer-substring (region-beginning) (region-end))))
         (t (shell-command-on-region (region-beginning) (region-end)
                                     (cond
                                      (*cygwin* "putclip")
                                      (*is-a-mac* "pbcopy")
                                      (*linux* "xsel -ib")))
            ))
        (message "Yanked region to clipboard!")
        (deactivate-mark))
        (message "No region active; can't yank to clipboard!")))

(defun paste-from-x-clipboard()
  (interactive)
  (cond
   ((and (display-graphic-p) x-select-enable-clipboard)
    (insert (x-selection 'CLIPBOARD)))
   (t (shell-command
       (cond
        (*cygwin* "getclip")
        (*is-a-mac* "pbpaste")
        (t "xsel -ob"))
       1))
   ))
#+END_SRC

*** copy and indent lines

#+BEGIN_SRC emacs-lisp :results none
(defun prelude-indent-rigidly-and-copy-to-clipboard (begin end indent)
  "Copy the selected code region to the clipboard, indented according
to Markdown blockquote rules."
  (let ((buffer (current-buffer)))
    (with-temp-buffer
      (insert-buffer-substring-no-properties buffer begin end)
      (indent-rigidly (point-min) (point-max) indent)
      (clipboard-kill-ring-save (point-min) (point-max)))))

(defun prelude-indent-blockquote-and-copy-to-clipboard (begin end)
  "Copy the selected code region to the clipboard, indented according
to markdown blockquote rules (useful to copy snippets to StackOverflow, Assembla, Github."
  (interactive "r")
  (prelude-indent-rigidly-and-copy-to-clipboard begin end 4))

(defun prelude-indent-nested-blockquote-and-copy-to-clipboard (begin end)
  "Copy the selected code region to the clipboard, indented according
to markdown blockquote rules. Useful to add snippets under bullet points."
  (interactive "r")
  (prelude-indent-rigidly-and-copy-to-clipboard begin end 6))

#+END_SRC
*** search replace all document
@currently below code broken@

#+BEGIN_SRC emacs-lisp :results none
;(defun  z/search-replace-file ()
;(interactive)
;(goto-char (point-min))
;(query-replace-regexp ))

#+END_SRC
*** duplicate line/region 
#+BEGIN_SRC emacs-lisp :results none
(defun duplicate-current-line-or-region (arg)
  "Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated. However, if
there's a region, all lines that region covers will be duplicated."
  (interactive "p")
  (let (beg end (origin (point)))
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (let ((region (buffer-substring-no-properties beg end)))
      (dotimes (i arg)
        (goto-char end)
        (newline)
        (insert region)
        (setq end (point)))
      (goto-char (+ origin (* (length region) arg) arg)))))
#+END_SRC

**** old method for line only 
#+BEGIN_SRC emacs-lisp :results none
(defun duplicate-line()
  (interactive)
  (move-beginning-of-line 1)
  (kill-line)
  (yank)
  (open-line 1)
  (next-line 1)
  (yank)
)
#+END_SRC

*** copy current line
#+BEGIN_SRC emacs-lisp :results none
(defun z/copy-line (arg)
    "Copy lines (as many as prefix argument) in the kill ring.
      Ease of use features:
      - Move to start of next line.
      - Appends the copy on sequential calls.
      - Use newline as last char even on the last line of the buffer.
      - If region is active, copy its lines."
    (interactive "p")
    (let ((beg (line-beginning-position))
          (end (line-end-position arg)))
      (when mark-active
        (if (> (point) (mark))
            (setq beg (save-excursion (goto-char (mark)) (line-beginning-position)))
          (setq end (save-excursion (goto-char (mark)) (line-end-position)))))
      (if (eq last-command 'copy-line)
          (kill-append (buffer-substring beg end) (< end beg))
        (kill-ring-save beg end)))
    (kill-append "\n" nil)
    (beginning-of-line (or (and arg (1+ arg)) 2))
    (if (and arg (not (= 1 arg))) (message "%d lines copied" arg)))
#+END_SRC
*** auto spell correction function
From: itai kloog  <zeltak@gmail.com>
http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html

this will store the abbrevs here: 
file:/home/zeltak/.emacs.d/abbrv/personal_abbrv.txt

#+BEGIN_SRC emacs-lisp  :results none
(defun endless/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global."
  (interactive "P")
  (let (bef aft)
    (save-excursion
      (while (progn
               (backward-word)
               (and (setq bef (thing-at-point 'word))
                    (not (ispell-word nil 'quiet)))))
      (setq aft (thing-at-point 'word)))
    (when (and aft bef (not (equal aft bef)))
      (setq aft (downcase aft))
      (setq bef (downcase bef))
      (define-abbrev
        (if p local-abbrev-table global-abbrev-table)
        bef aft)
      (message "\"%s\" now expands to \"%s\" %sally"
               bef aft (if p "loc" "glob")))))

#+END_SRC

*** common used regex
**** delete all numeric characters
#+BEGIN_SRC emacs-lisp :results none
(defun z/regex-delete-numeric  ()
  "delete all numeric characters"
  (interactive)
  (goto-char (point-min))
  (replace-regexp "[0-9]" "")
)
#+END_SRC

*** Code box
#+BEGIN_SRC emacs-lisp :results none
(defun z/comment-box (b e)
  "Draw a box comment around the region but arrange for the region
to extend to at least the fill column. Place the point after the
comment box."
  (interactive "r")
  (let ((e (copy-marker e t)))
    (goto-char b)
    (end-of-line)
    (insert-char ?  (- fill-column (current-column)))
    (comment-box b e 1)
    (goto-char e)
    (set-marker e nil)))

#+END_SRC
*** insert quick snippets/Unicode texts

#+BEGIN_SRC emacs-lisp :results none
(defun z/insert-keyleft ()
  " insert 【   "
  (interactive)
  (insert "【")
  )

(defun z/insert-keyright ()
  " insert 】   "
  (interactive)
  (insert "】")
  )


(defun z/insert-EOL ()
  " insert EOL"
  (interactive)
  (insert "\\\\")
(backward-char 2)  
)

(defun z/insert-bashscript ()
  " insert #!/bin/sh  "
  (interactive)
  (insert "#!/bin/sh")

(defun z/insert-play ()
  " insert   ‣  "
  (interactive)
  (insert "‣")
)


(defun z/insert-white-arrow ()
  " insert   ▻  "
  (interactive)
  (insert "▻")
)



(defun z/insert-reveal-split ()
  "insert REVEAL split  "
  (interactive)
  (insert "#+REVEAL: split")
)

)


#+END_SRC

*** kill line backwars 
#+BEGIN_SRC emacs-lisp :results none
(defun backward-kill-line (arg)
  "Kill ARG lines backward."
  (interactive "p")
  (kill-line (- 1 arg)))
#+END_SRC
*** copy whole buffer
http://ergoemacs.org/emacs/emacs_copy_cut_all_or_region.html

#+BEGIN_SRC emacs-lisp :results none
(defun z/edit-copy-all-or-region ()
  "Put the whole buffer content to `kill-ring', or text selection if there's one.
Respects `narrow-to-region'.
URL `http://ergoemacs.org/emacs/emacs_copy_cut_all_or_region.html'
Version 2015-08-22"
  (interactive)
  (if (use-region-p)
      (progn
        (kill-new (buffer-substring (region-beginning) (region-end)))
        (message "Text selection copied."))
    (progn
      (kill-new (buffer-string))
      (message "Buffer content copied."))))
#+END_SRC
*** replace underscore
#+BEGIN_SRC emacs-lisp :results none
(defun xah-cycle-hyphen-underscore-space ()
  "Cycle {underscore, space, hypen} chars of current word or text selection.
When called repeatedly, this command cycles the {“_”, “-”, “ ”} characters, in that order.

URL `http://ergoemacs.org/emacs/elisp_change_space-hyphen_underscore.html'
Version 2015-08-17"
  (interactive)
  ;; this function sets a property 「'state」. Possible values are 0 to length of ξcharArray.
  (let (ξp1 ξp2)
    (if (use-region-p)
        (progn
          (setq ξp1 (region-beginning))
          (setq ξp2 (region-end)))
      (let ((ξbounds (bounds-of-thing-at-point 'symbol)))
        (progn
          (setq ξp1 (car ξbounds))
          (setq ξp2 (cdr ξbounds)))))

    (let* ((ξinputText (buffer-substring-no-properties ξp1 ξp2))
           (ξcharArray ["_" "-" " "])
           (ξlength (length ξcharArray))
           (ξregionWasActive-p (region-active-p))
           (ξnowState
            (if (equal last-command this-command )
                (get 'xah-cycle-hyphen-underscore-space 'state)
              0 ))
           (ξchangeTo (elt ξcharArray ξnowState)))
      (save-excursion
        (save-restriction
          (narrow-to-region ξp1 ξp2)
          (goto-char (point-min))
          (while
              (search-forward-regexp
               (concat
                (elt ξcharArray (% (+ ξnowState 1) ξlength))
                "\\|"
                (elt ξcharArray (% (+ ξnowState 2) ξlength)))
               (point-max)
               'NOERROR)
            (replace-match ξchangeTo 'FIXEDCASE 'LITERAL))))
      (when (or (string= ξchangeTo " ") ξregionWasActive-p)
        (goto-char ξp2)
        (set-mark ξp1)
        (setq deactivate-mark nil))
      (put 'xah-cycle-hyphen-underscore-space 'state (% (+ ξnowState 1) ξlength)))))
#+END_SRC
*** Bracket Pair Insertion Commands
#+BEGIN_SRC emacs-lisp :results none
(defun xah-insert-bracket-pair (φleft-bracket φright-bracket)
  "Wrap or Insert a matching bracket and place cursor in between.

If there's a text selection, wrap brackets around it. Else, smartly decide wrap or insert. (basically, if there's no char after cursor, just insert bracket pair.)

φleft-bracket ＆ φright-bracket are strings.

URL `http://ergoemacs.org/emacs/elisp_insert_brackets_by_pair.html'
Version 2015-04-19"
  (if (use-region-p)
      (progn
        (let (
              (ξp1 (region-beginning))
              (ξp2 (region-end)))
          (goto-char ξp2)
          (insert φright-bracket)
          (goto-char ξp1)
          (insert φleft-bracket)
          (goto-char (+ ξp2 2))))
    (progn ; no text selection
      (if
          (or
           (looking-at "[^-_[:alnum:]]")
           (eq (point) (point-max)))
          (progn
            (insert φleft-bracket φright-bracket)
            (search-backward φright-bracket ))
        (progn
          (let (ξp1 ξp2)
            ;; basically, want all alphanumeric, plus hyphen and underscore, but don't want space or punctuations. Also want chinese.
            ;; 我有一帘幽梦，不知与谁能共。多少秘密在其中，欲诉无人能懂。
            (skip-chars-backward "-_[:alnum:]")
            (setq ξp1 (point))
            (skip-chars-forward "-_[:alnum:]")
            (setq ξp2 (point))
            (goto-char ξp2)
            (insert φright-bracket)
            (goto-char ξp1)
            (insert φleft-bracket)
            (goto-char (+ ξp2 (length φleft-bracket)))))))))

#+END_SRC
*** specific paren types enter
#+BEGIN_SRC emacs-lisp :results none
(defun z/insert-black-lenticular-bracket () (interactive) (xah-insert-bracket-pair "【" "】") )
(defun z/insert-black-lenticular-bracket-white () (interactive) (xah-insert-bracket-pair "〖" "〗") )
(defun z/insert-black-lenticular-angle   () (interactive) (xah-insert-bracket-pair "«" "»") )
(defun z/insert-black-lenticular-angle-bold   () (interactive) (xah-insert-bracket-pair "❰" "❱") )
(defun z/insert-black-arrows   () (interactive) (xah-insert-bracket-pair "◀" "▶") )
(defun z/insert-black-hands   () (interactive) (xah-insert-bracket-pair "☚" "☛") )
#+END_SRC
(defun xah-insert-corner-bracket「」 () (interactive) (xah-insert-bracket-pair "「" "」") )
(defun xah-insert-white-corner-bracket『』 () (interactive) (xah-insert-bracket-pair "『" "』") )
(defun xah-insert-angle-bracket〈〉 () (interactive) (xah-insert-bracket-pair "《" "》") )
(defun xah-insert-double-angle-bracket《》 () (interactive) (xah-insert-bracket-pair "《" "》") )


*** open line above and below
#+BEGIN_SRC emacs-lisp :results none
(defun z/insert-line-below ()
  "Insert and auto-indent line below cursor, like in vim."
  (interactive)
  (move-end-of-line 1)
  (open-line 1)
  (next-line)
  (indent-for-tab-command))

(defun z/insert-line-above ()
  "Insert and auto-indent line above cursor, like in vim."
  (interactive)
  (previous-line)
  (move-end-of-line 1)
  (stag-insert-line-below))

(global-set-key (kbd "C-o")       ' z/insert-line-below)
(global-set-key (kbd "C-S-o")     ' z/insert-line-above)
#+END_SRC


*** flyspell jump to last correction
#+BEGIN_SRC emacs-lisp :results none
;; move point to previous error
;; based on code by hatschipuh at
;; http://emacs.stackexchange.com/a/14912/2017
(defun z/flyspell-goto-previous-error (arg)
  "Go to arg previous spelling error."
  (interactive "p")
  (while (not (= 0 arg))
    (let ((pos (point))
          (min (point-min)))
      (if (and (eq (current-buffer) flyspell-old-buffer-error)
               (eq pos flyspell-old-pos-error))
          (progn
            (if (= flyspell-old-pos-error min)
                ;; goto beginning of buffer
                (progn
                  (message "Restarting from end of buffer")
                  (goto-char (point-max)))
              (backward-word 1))
            (setq pos (point))))
      ;; seek the next error
      (while (and (> pos min)
                  (let ((ovs (overlays-at pos))
                        (r '()))
                    (while (and (not r) (consp ovs))
                      (if (flyspell-overlay-p (car ovs))
                          (setq r t)
                        (setq ovs (cdr ovs))))
                    (not r)))
        (backward-word 1)
        (setq pos (point)))
      ;; save the current location for next invocation
      (setq arg (1- arg))
      (setq flyspell-old-pos-error pos)
      (setq flyspell-old-buffer-error (current-buffer))
      (goto-char pos)
      (if (= pos min)
          (progn
            (message "No more miss-spelled word!")
            (setq arg 0))
        (forward-word)))))
#+END_SRC
*** TODO mark all characters under point
https://www.reddit.com/r/emacs/comments/3vz6lx/command_to_rectangle_select_a_column_of_text/
#+BEGIN_SRC emacs-lisp :results none
(defun z/activate-word-column-region ()
  "Look at the symbol at point, search backward and place the point before a
symbol, and search forward and place the mark after a symbol such that all
lines have identical symbols at identical goal columns as the symbol at point."
  (interactive)
  (let (upper-pt lower-pt (next-line-add-newlines t))
    (save-excursion
      (let ((target (format "%s" (symbol-at-point))))
        (while (looking-back "\\(\\sw\\|\\s_\\)" 1)
          (backward-char 1))
        (with-no-warnings
            (save-excursion
              (next-line 1)
              (while (looking-at target)
                (setf lower-pt (point))
                (next-line 1)))
            (save-excursion
              (next-line -1)
              (while (looking-at target)
                (setf upper-pt (point))
                (next-line -1))))))
    (when (or upper-pt lower-pt)
      (let ((upper-pt (or upper-pt (point)))
            (lower-pt (or lower-pt (point))))    
        (goto-char lower-pt)
        (while (looking-at "\\(\\sw\\|\\s_\\)")
          (forward-char 1))
        (push-mark nil nil t)
        (goto-char upper-pt)
        (while (looking-back "\\(\\sw\\|\\s_\\)" 1)
          (backward-char 1)))))
  (rectangle-mark-mode))
#+END_SRC
*** insert Unicode characters with helm

#+BEGIN_SRC emacs-lisp  :results none
(defun z/helm-insert-org-entity ()
  "Helm interface to insert an entity from `org-entities'.
F1 inserts utf-8 character
F2 inserts entity code
F3 inserts LaTeX code (does not wrap in math-mode)
F4 inserts HTML code"
  (interactive)
  (helm :sources (reverse
                  (let ((sources '())
                        toplevel
                        secondlevel)
                    (dolist (element (append
                                      '("* User" "** User entities")
                                      org-entities-user org-entities))
                      (when (and (stringp element)
                                 (s-starts-with? "* " element))
                        (setq toplevel element))
                      (when (and (stringp element)
                                 (s-starts-with? "** " element))
                        (setq secondlevel element)
                        (add-to-list
                         'sources
                         `((name . ,(concat
                                     toplevel
                                     (replace-regexp-in-string
                                      "\\*\\*" " - " secondlevel)))
                           (candidates . nil)
                           (action . (("insert utf-8 char" . (lambda (candidate)
                                                               (insert (nth 6 candidate))))
                                      ("insert org entity" . (lambda (candidate)
                                                           (insert (concat "\\" (car candidate)))))
                                      ("insert latex" . (lambda (candidate)
                                                          (insert (nth 1 candidate))))
                                      ("insert html" . (lambda (candidate)
                                                         (insert (nth 3 candidate)))))))))
                      (when (and element (listp element))
                        (setf (cdr (assoc 'candidates (car sources)))
                              (append
                               (cdr (assoc 'candidates (car sources)))
                               (list (cons
                                      (format "%10s %s" (nth 6 element) element)
                                      element))))))
                    sources))))
#+END_SRC

** hydra related
*** slash \
#+BEGIN_SRC emacs-lisp :results none
(defun z/insert-slsh ()
  " insert     "
  (interactive)
  (insert "\\")
)
#+END_SRC
** Root actions
*** edit file as root
#+BEGIN_SRC emacs-lisp :results none
(defun z-edit-file-as-root ()
  "Edit the file that is associated with the current buffer as root"
  (interactive)
  (if (buffer-file-name)
      (progn
        (setq file (concat "/sudo:root@localhost:" (buffer-file-name)))
        (find-file file))
    (message "Current buffer does not have an associated file.")))


#+END_SRC
** Buffers
*** kill other buffers
#+BEGIN_SRC emacs-lisp :results none
(defun z-kill-other-buffers ()
      "Kill all other buffers."
      (interactive)
      (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

#+END_SRC

*** movment in buffer
#+BEGIN_SRC emacs-lisp :results none
(defun next-user-buffer ()
  "Switch to the next user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun previous-user-buffer ()
  "Switch to the previous user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

(defun next-emacs-buffer ()
  "Switch to the next emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun previous-emacs-buffer ()
  "Switch to the previous emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))


(defun switch-to-previous-buffer ()
  "Switch to previously open buffer.
Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))


#+END_SRC
*** save current file and close window
#+BEGIN_SRC emacs-lisp :results none
(defun z-save-buffer-close-window ()
  "DOCSTRING"
  (interactive)
    (save-buffer)
    (kill-this-buffer)
  )
#+END_SRC
*** move to other window and close current
#+BEGIN_SRC emacs-lisp :results none
(defun z/buffer-close-andmove-other   ()
     (interactive)    
     (save-buffer)        
      (delete-window)
)
#+END_SRC
*** pre defined buffers (workspaces)
**** refernces
#+BEGIN_SRC emacs-lisp  :results none
(defun z/buffers-restore-refwork   ()
     (interactive)    
     (find-file "/home/zeltak/org/files/Uni/papers/paper.meta.org")
     (split-window-right)
     (find-file "/home/zeltak/org/files/Uni/papers/kloog.papers.bib")
     )
#+END_SRC
*** toggle window splits
#+BEGIN_SRC emacs-lisp  :results none
(defun z/toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC
*** Delete current file
mainly used when viewing images in dired image
#+BEGIN_SRC emacs-lisp  :results none
(defun z/delete-current-file ()
  "Delete the file associated with the current buffer and close the buffer.
Also push file content to `kill-ring'.
If buffer is not file, just close it, and push file content to `kill-ring'.

URL `http://ergoemacs.org/emacs/elisp_delete-current-file.html'
Version 2015-08-12"
  (interactive)
  (progn
    (kill-new (buffer-string))
    (when (buffer-file-name)
      (when (file-exists-p (buffer-file-name))
        (progn
          (delete-file (buffer-file-name))
          (message "Deleted: 「%s」." (buffer-file-name)))))
    (let ((buffer-offer-save nil))
      (set-buffer-modified-p nil)
      (kill-buffer (current-buffer)))))
#+END_SRC
*** transpose-buffers
#+BEGIN_SRC emacs-lisp  :results none
(defun z/transpose-buffers (arg)
  "Transpose the buffers shown in two windows."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      (setq arg (if (plusp arg) (1- arg) (1+ arg))))))
#+END_SRC
** open a specific dir
   :PROPERTIES:
   :ID:       aef2baea-ba6e-460a-a4e6-1c4f0a457551
   :END:
#+BEGIN_SRC emacs-lisp :results none
(defun ood () (interactive) (dired "/home/zeltak/org"))
#+END_SRC
** General emacs
*** create scratch buffer
#+BEGIN_SRC emacs-lisp :results none
(defun create-scratch-buffer nil
   "create a scratch buffer"
   (interactive)
   (switch-to-buffer (get-buffer-create "*scratch*"))
   (lisp-interaction-mode))  
#+END_SRC
*** describe last comman
http://stackoverflow.com/questions/275842/is-there-a-repeat-last-command-in-emacsd
#+BEGIN_SRC emacs-lisp :results none
(defun describe-last-function() 
  (interactive) 
  (describe-function last-command))
#+END_SRC
*** Launch ansi-term
#+BEGIN_SRC emacs-lisp :results none
;; taken from here: http://www.enigmacurry.com/2008/12/26/emacs-ansi-term-tricks/
(defun z/launch--ansi-term ()
  "If the current buffer is:
     1) a running ansi-term named *ansi-term*, rename it.
     2) a stopped ansi-term, kill it and create a new one.
     3) a non ansi-term, go to an already running ansi-term
        or start a new one while killing a defunt one"
  (interactive)
  (let ((is-term (string= "term-mode" major-mode))
        (is-running (term-check-proc (buffer-name)))
        (term-cmd "/bin/zsh")
        (anon-term (get-buffer "*ansi-term*")))
    (if is-term
        (if is-running
            (if (string= "*ansi-term*" (buffer-name))
                ;; (call-interactively 'rename-buffer)
                (ansi-term term-cmd)
              (if anon-term
                  (switch-to-buffer "*ansi-term*")
                (ansi-term term-cmd)))
          (kill-buffer (buffer-name))
          (ansi-term term-cmd))
      (if anon-term
          (if (term-check-proc "*ansi-term*")
              (switch-to-buffer "*ansi-term*")
            (kill-buffer "*ansi-term*")
            (ansi-term term-cmd))
        (ansi-term term-cmd)))))
#+END_SRC
** toggles 
*** auto narrow/widen

#+BEGIN_SRC emacs-lisp :results none
(defun z/narrow-or-widen-dwim ()
"If the buffer is narrowed, it widens. Otherwise, it narrows to region, or Org subtree."
(interactive)
(cond ((buffer-narrowed-p) (widen))
((region-active-p) (narrow-to-region (region-beginning) (region-end)))
((equal major-mode 'org-mode) (org-narrow-to-subtree))
(t (error "Please select a region to narrow to"))))
#+END_SRC

** outside Emacs
*** search google
#+BEGIN_SRC emacs-lisp :results none
(require 'thingatpt)

(defun google-search ()
 "If selected region, or thing at point, is a url, go there. Otherwise,
use region/thing as a keyword for a google search."
  (interactive)
  (let ((target
         (if (use-region-p)
             (buffer-substring (region-beginning) (region-end))
           (thing-at-point 'symbol))))
    (if (ffap-url-p target)
        (browse-url target)
      (browse-url (concat "http://www.google.com/search?q="
                          (url-hexify-string target))))))
#+END_SRC

** helm 
*** swish-e

#+BEGIN_SRC emacs-lisp :results none
(defun helm-swish-e-candidates (query)
  "Generate a list of cons cells (swish-e result . path)."
  (let* ((result (shell-command-to-string
		  (format "swish-e -f ~/.swish-e/index.swish-e -x \"%%r\t%%p\n\" -w %s"
			  (shell-quote-argument query))))
	 (lines (s-split "\n" result t))
	 (candidates '()))
    (loop for line in lines
	  unless (or  (s-starts-with? "#" line)
		      (s-starts-with? "." line))
	  collect (cons line (cdr (s-split "\t" line))))))


(defun helm-swish-e (query)
  "Run a swish-e query and provide helm selection buffer of the results."
  (interactive "sQuery: ")
  (helm :sources `(((name . ,(format "swish-e: %s" query))
		    (candidates . ,(helm-swish-e-candidates query))
		    (action . (("open" . (lambda (f)
					   (find-file (car f)))))))
		   ((name . "New search")
		    (dummy)
		    (action . (("search" . (lambda (f)
					     (helm-swish-e helm-pattern)))))))))
#+END_SRC

*** TODO helm hotspot menu
#+BEGIN_SRC emacs-lisp :results none
(defun hotspots ()
  "helm interface to my hotspots, which includes my locations,
org-files and bookmarks"
  (interactive)
  (helm :sources `(((name . "Mail and News")
                    (candidates . (("Mail" . (lambda ()
                                               (if (get-buffer "*mu4e-headers*")
                                                   (progn
                                                     (switch-to-buffer "*mu4e-headers*")
                                                     (delete-other-windows))

                                                 (mu4e))))
                                   ("Calendar" . (lambda ()  (browse-url "https://www.google.com/calendar/render")))
                                   ("RSS" . elfeed)
                                   ("Agenda" . (lambda () (org-agenda "" "w")))))
                    (action . (("Open" . (lambda (x) (funcall x))))))
                   ((name . "My Locations")
                    (candidates . (("master" . "~/org/files/")
                                   (".emacs.d" . "~/.emacs.d/" )
                                   ("todo" . "~/org/files/agenda/todo.org")))
                    (action . (("Open" . (lambda (x) (find-file x))))))

                   ((name . "My org files")
                    (candidates . ,(f-entries "~/org/files/"))
                    (action . (("Open" . (lambda (x) (find-file x))))))
                   helm-source-recentf
                   helm-source-bookmarks
                   helm-source-bookmark-set)))
#+END_SRC
*** helm-ag-prefix
#+BEGIN_SRC emacs-lisp :results none
(defun z/helm-mg-prefix  ()
                     (interactive)                                
                     (let ((current-prefix-arg '(4)))             
                       (call-interactively #'helm-ag)))
#+END_SRC

** isearch
*** delete non matching 
#+BEGIN_SRC emacs-lisp :results none
(defun isearch-delete-something ()
  "Delete non-matching text or the last character."
  ;; Mostly copied from `isearch-del-char' and Drew's answer on the page above
  (interactive)
  (if (= 0 (length isearch-string))
      (ding)
    (setq isearch-string
          (substring isearch-string
                     0
                     (or (isearch-fail-pos) (1- (length isearch-string)))))
    (setq isearch-message
          (mapconcat #'isearch-text-char-description isearch-string "")))
  (if isearch-other-end (goto-char isearch-other-end))
  (isearch-search)
  (isearch-push-state)
  (isearch-update))

(define-key isearch-mode-map (kbd "<backspace>") 
  #'isearch-delete-something)
#+END_SRC
*** isearch occurrence at point 

http://endlessparentheses.com/quickly-search-for-occurrences-of-the-symbol-at-point.html

#+BEGIN_SRC emacs-lisp  :results none
(defun endless/isearch-symbol-with-prefix (p)
  "Like isearch, unless prefix argument is provided.
With a prefix argument P, isearch for the symbol at point."
  (interactive "P")
  (let ((current-prefix-arg nil))
    (call-interactively
     (if p #'isearch-forward-symbol-at-point
       #'isearch-forward))))

(global-set-key [remap isearch-forward]
                #'endless/isearch-symbol-with-prefix)
#+END_SRC
** mu4e
*** open mu4e inbox
#+BEGIN_SRC emacs-lisp :results none
(defun z/mu4e-inbox ()
"Display the inbox."
(interactive)
(mu4e)
(mu4e-headers-search "maildir:/INBOX"))
#+END_SRC
*** open mu4e flagged
#+BEGIN_SRC emacs-lisp :results none
(defun z/mu4e-flagged ()
"Display the inbox."
(interactive)
(mu4e)
(mu4e-headers-search "maildir:/INBOX AND flag:flagged "))
#+END_SRC
** Terms
*** visit ansi term 
#+BEGIN_SRC emacs-lisp  :results none
;; taken from here: http://www.enigmacurry.com/2008/12/26/emacs-ansi-term-tricks/
(defun z/visit-ansi-term ()
  "If the current buffer is:
     1) a running ansi-term named *ansi-term*, rename it.
     2) a stopped ansi-term, kill it and create a new one.
     3) a non ansi-term, go to an already running ansi-term
        or start a new one while killing a defunt one"
  (interactive)
  (let ((is-term (string= "term-mode" major-mode))
        (is-running (term-check-proc (buffer-name)))
        (term-cmd "/bin/zsh")
        (anon-term (get-buffer "*ansi-term*")))
    (if is-term
        (if is-running
            (if (string= "*ansi-term*" (buffer-name))
                ;; (call-interactively 'rename-buffer)
                (ansi-term term-cmd)
              (if anon-term
                  (switch-to-buffer "*ansi-term*")
                (ansi-term term-cmd)))
          (kill-buffer (buffer-name))
          (ansi-term term-cmd))
      (if anon-term
          (if (term-check-proc "*ansi-term*")
              (switch-to-buffer "*ansi-term*")
            (kill-buffer "*ansi-term*")
            (ansi-term term-cmd))
        (ansi-term term-cmd)))))
#+END_SRC
** mail
*** yas mail functions
#+BEGIN_SRC emacs-lisp :results none
(defun my-yas-get-first-name-from-to-field ()
  (let ((rlt "AGENT_NAME") str)
    (save-excursion
      (goto-char (point-min))
      ;; first line in email could be some hidden line containing NO to field
      (setq str (buffer-substring-no-properties (point-min) (point-max))))
    (if (string-match "^To: \"\\([^ ,]+\\)" str)
        (setq rlt (match-string 1 str)))
    (message "rlt=%s" rlt)
    rlt))
#+END_SRC
** Shell
*** TODO search bash history
can be edited and converted to zsh
#+BEGIN_SRC emacs-lisp  :results none
(defun counsel-yank-bash-history ()
  "Yank the bash history"
  (interactive)
  (let (hist-cmd collection val)
    (shell-command "history -r") ; reload history
    (setq collection
          (nreverse
           (split-string (with-temp-buffer (insert-file-contents (file-truename "~/.bash_history"))
                                           (buffer-string))
                         "\n"
                         t)))
    (when (and collection (> (length collection) 0)
               (setq val (if (= 1 (length collection)) (car collection)
                           (ivy-read (format "Bash history:") collection))))
        (kill-new val)
        (message "%s => kill-ring" val))))
#+END_SRC
** projectile
   :PROPERTIES:
   :ID:       a8d31985-4c01-4ce2-8986-945af198ee4a
   :END:
#+BEGIN_SRC emacs-lisp  :results none
(defun projectile-find-file-in-project-org ()
(interactive)                                
(let ((default-directory "/home/zeltak/org/files/"))
(projectile-find-file)))

;;(global-set-key (kbd "M-C-w") 'projectile-find-file-in-project-org)

#+END_SRC
* Key binds
  :PROPERTIES:
  :ID:       d4e38ca1-43ac-4fb5-a31f-5b432a4c0418
  :END:
** 1-unbind keys
#+BEGIN_SRC emacs-lisp :results none
(global-unset-key (kbd "<f1>"))
(global-unset-key (kbd "<f2>"))
(global-unset-key (kbd "<f3>"))
(global-unset-key (kbd "<f4>"))
(global-unset-key (kbd "<f5>"))
(global-unset-key (kbd "<f6>"))
(global-unset-key (kbd "<f7>"))
(global-unset-key (kbd "<f8>"))
(global-unset-key (kbd "<f9>"))
(global-unset-key (kbd "<f10>"))
(global-unset-key (kbd "<f11>"))
(global-unset-key (kbd "<f12>"))
(global-unset-key (kbd "C-v"))
(global-unset-key (kbd "C-M-p"))
(global-unset-key (kbd "C-M-e"))
(global-unset-key (kbd "C-M-b"))
(global-unset-key (kbd "C-M-b"))
(global-unset-key (kbd "C-M-t"))
(global-unset-key (kbd "\\"))
#+END_SRC
** global
NOTE: Starting helm-find-files with C-u will show you a little history of the last visited directories.
#+BEGIN_SRC emacs-lisp :results none
(global-set-key (kbd "M-x") 'counsel-M-x)
(global-set-key (kbd "C-x C-f") 'helm-find-files)
#+END_SRC
*** switch keybind between transpose char and lines
#+BEGIN_SRC emacs-lisp :results none
(global-set-key "\C-t" #'transpose-lines)
(define-key ctl-x-map "\C-t" #'transpose-chars)
#+END_SRC
** editing 
#+BEGIN_SRC emacs-lisp :results none
(global-set-key (kbd "C-+") 'z/copy-line)
(key-chord-define-global "jj"     'avy-goto-word-or-subword-1)
(global-set-key (kbd "C-0") 'backward-kill-line)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
;;(global-set-key (kbd "C-<tab>") 'dabbrev-expand)
;;(define-key minibuffer-local-map (kbd "C-<tab>") 'dabbrev-expand)
#+END_SRC
** movment
#+BEGIN_SRC emacs-lisp :results none
(global-unset-key (kbd "M-`"))
;(global-set-key (kbd "M-`") 'avy-goto-line)
(global-set-key (kbd "C-<up>") 'windmove-up)
(global-set-key (kbd "C-<down>") 'windmove-down)
(global-set-key (kbd "C-<right>") 'windmove-right)
(global-set-key (kbd "C-<left>") 'windmove-left)
#+END_SRC

quick switch other windw 
#+BEGIN_SRC emacs-lisp :results none
;;(global-set-key (kbd "M-1") 'other-window)
(global-set-key (kbd "M-1") 'ace-window)
#+END_SRC


** org
*** base binds 
#+BEGIN_SRC emacs-lisp :results none
;Create an ID for the entry at point if it does not yet have one.
(global-set-key "\C-ca" 'org-agenda)
(global-set-key (kbd "C-c c") 'org-capture)
(global-set-key "\C-cs" 'org-babel-execute-subtree)
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-cb" 'org-iswitchb)

#+END_SRC
*** swap C and M RETURN
#+BEGIN_SRC emacs-lisp :results none
(with-eval-after-load "org" 
(define-key org-mode-map (kbd "<C-return>") 'org-insert-heading)
(define-key org-mode-map (kbd "<M-return>")  'org-insert-heading-respect-content)
) 
#+END_SRC

** isearch
#+BEGIN_SRC emacs-lisp :results none
(progn
  ;; set arrow keys in isearch. left/right is backward/forward, up/down is history. press Return to exit
  (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat )
  (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance )
  (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward) ; single key, useful
  (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward) ; single key, useful
 )
#+END_SRC
** key-chord

#+BEGIN_SRC emacs-lisp :results none
  ;; (key-chord-define-global "3e" 'hydra-editing/body)
  ;; (key-chord-define-global "9o" 'hydra-org-edit/body)
  ;; (key-chord-define-global "8yy"     'z/copy-line)
  ;; (key-chord-define-global "8dd"     'kill-whole-line)
  ;; (key-chord-define-global "8pp"     'yank)

#+END_SRC
** Ess/org tangle
#+BEGIN_SRC emacs-lisp :results none
(global-set-key (kbd "C-c x") 'org-babel-execute-subtree)
#+END_SRC
* hydras
  :PROPERTIES:
  :ID:       e240cc34-4260-4f99-9dce-e34a77c7fa8a
  :END:
*** hydra faces
#+BEGIN_SRC emacs-lisp :results none
(defface hydra-face-orange
    '((t (:foreground "orange" :bold t)))
  "Orange face. For fun.")

(defface hydra-face-brown
    '((t (:foreground "brown" :bold t)))
  "brown.")

(defface hydra-face-cyan
    '((t (:foreground "#42B7DE" :bold t :underline t)))
  "cyan")

(defface hydra-face-red
    '((t (:foreground "red" :bold t)))
  "red")

(defface hydra-face-green
    '((t (:foreground "green" :bold t)))
  "green")


(defface hydra-face-brown
    '((t (:foreground "#C15F0D" :bold t)))
  "brown")


(defface hydra-face-purple
    '((t (:foreground "#D52BFF" :bold t)))
  "purple")


#+END_SRC

*** hydra leader
    :PROPERTIES:
    :ID:       b1bd78ae-83b5-4cb4-a4b5-6db5287f3956
    :END:
 #+BEGIN_SRC emacs-lisp :results none
(global-set-key
    (kbd "\\")
 (defhydra hydra-leader  (:color blue :hint nil :columns 5)
 "
LEADER:【C-A-W】-append to killring helm-projectile-recentf 【C-c p e】
 "
("\]" helm-buffers-list "helm buffer")
("\[" z/insert-slsh "insert \\")
("<backspace>" helm-all-mark-rings "all mark rings")
;;("\\"  avy-goto-char-timer  "avy jump")
("\\"  avy-goto-char-timer  "avy jump")
("|"   hydra-goto/body "goto" )
("RET" avy-goto-line "goto line" )
("1"   hydra-org-tags/body "tags")
("8"   helm-mark-ring "HELM mark ")


(";"   comment-or-uncomment-region )
("5"   duplicate-current-line-or-region  "duplicate" :color red)
("6"   z/copy-comment-paste  "duplicate-comment")
("="  org-capture "org-capture" )
("-"  z/org-capture-meeting  "org-capture-meeting" )
("<f3>"  repeat "repeat last command" )
("/"  (dired "~/") "dired" )

("<up>" drag-stuff-up  "marked up" :color red)
("<down>" drag-stuff-down  "marked down" :color red)

("a"  z/org-agenda-calendar "org agenda" )

;;; bgu/work related quick access
("bb"  (find-file "/home/zeltak/org/files/agenda/bgu.org") "bgu"  :face 'hydra-face-cyan )
("bg"  (find-file "/home/zeltak/org/files/agenda/grants.org") "grants"  :face 'hydra-face-cyan )
("br"  (find-file "/home/zeltak/org/files/agenda/Research.org") "reserach"  :face 'hydra-face-cyan )
("bs"   z/buffers-restore-refwork  "refwork" :face 'hydra-face-cyan)
("bm"  (find-file "/home/zeltak/org/files/agenda/meetings.org") "meetings" :face 'hydra-face-cyan )
("bp"  (find-file "/home/zeltak/org/files/Uni/papers/paper.meta.org") "papers" :face 'hydra-face-cyan )
("bw"  (find-file "/home/zeltak/org/files/help/workflows.org") "work workflows" :face 'hydra-face-cyan )

("c"  z/org-move-top-collapse "collapse headers" )

("d"  nil )

;;; tech related quick access
("ee"  (find-file "/home/zeltak/org/files/Tech/Emacs.org") "Emacs" :face 'hydra-face-cyan)
("el"  (find-file "/home/zeltak/org/files/Tech/linux.org") "linux"  :face 'hydra-face-cyan)

("g"  nil )
("f"  helm-org-rifle "org-search (rifle) )")

;;; home related quick access
("hd"  (find-file "/home/zeltak/org/files/agenda/dl.org")    "Downloads"  :face 'hydra-face-cyan)
("hf"  (find-file "/home/zeltak/org/files/agenda/food.org") "food" :face 'hydra-face-cyan)
("hh"  (find-file "/home/zeltak/org/files/agenda/home.org") "home"  :face 'hydra-face-cyan)
("hs"  (find-file "/home/zeltak/.emacs.d/settings.org") "research"  :face 'hydra-face-cyan )
("ht"  (find-file "/home/zeltak/org/files/agenda/TODO.org") "TODO"   :face 'hydra-face-cyan )
("hu"  (find-file "/home/zeltak/org/files/agenda/travel.org") "travel"  :face 'hydra-face-cyan )

("I"  char-menu "insert symbol" )
("i"  hydra-editing-insert/body "insert symbol" )
("j"  nil )
("k"  helm-show-kill-ring "kill ring")
("l"  hydra-org-links/body  "org links")
("m"  nil )
("n"  nil )
("o"  nil )
("p"  nil )
("q" nil "cancel")
("r"  iedit-mode  "iedit" )
("s"  nil )
("t"   z/visit-ansi-term "ansi term")
("T"   helm-top "top")
("v"  helm-bm "helm-bm" )
("V"  bm-toggle "add bm")
("u"  nil )
("w"  (find-file "/home/zeltak/org/files/web/wbookmarks.org")  "bookmarks" )
("x"  z/buffer-close-andmove-other  "close window")
("y"  nil )
("z"  nil )
))
 #+END_SRC
*** Emacs//toggles (f1)
**** main toggles 
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f1>")
(defhydra hydra-toggles (:color blue  :columns 6)
"Toggles:   【M-g M-g】 goto line 【C-x SPACE】 start mark rectangle 
easy-kill: 【M-w w】 select word // w, +- , 1..9 to increment (0 to reset)//【C-space】 turn selection to region// 【M-3】easy-mark
Term: 【C-c C-j】-activate Emacs mode 【C-c C-k】 back to normal term mode 
*calc* use 【C-enter】to copy results to clip and 【=】to print answer
"
("8" calculator "calc"  )
("a" pandoc-mode "pandoc"  )
("b" bug-hunter-file "bug hunter" :face 'hydra-face-orange )
("c" cua-mode "cua" :face 'hydra-face-red )
("d" tool-bar-mode "toggle toolbar"   )
("e" evil-mode "evil")
("f" fci-mode "fci" )
("g" google-search "google")
("h" hydra-toggles-help/body "help" )
("i"  nil )
("j"  helm-colors "color pallete" )
("k" key-chord-mode "key-chord"  )
("l" nlinum-mode  "line num")
("L" linum-mode  "linium")
("t" lentic-mode  "lentic")
("m" hydra-toggles-macro/body "macro menu")
("n" start-kbd-macro "start macro" :face 'hydra-face-green)
("o" end-kbd-macro "end macro" :face 'hydra-face-red)
("O" org-mode "org-mode" )
("p" list-packages "elpa"  )
("r" read-only-mode "read-only")
("R" helm-regexp "regex builder")
("s" scratch "scratch")
("S" create-scratch-buffer "New scratch" )
("u" electric-pair-mode "electric-pair")
("v" view-mode "view-mode")
("w" whitespace-mode "whitespace")
("x" eval-buffer "eval buffer")
("X" eval-region "eval-region")
("y" nil )
("z" nil )
("=" text-scale-increase :color red )
("-" text-scale-decrease :color red)
("G"  indent-guide-mode "guide-mode")
("q" nil "cancel")
))
#+END_SRC

**** extra macro commaqnds

 #+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-toggles-macro  (:color blue :hint nil )
      "macro commands
      "
      ("s" start-kbd-macro  "start macro" ) 
      ("e"   "end macro" ) 
      ("e" kmacro-end-and-call-macro  "use C-x e" ) 
      ("n" name-last-kbd-macro  "name macro" ) 
      ("i" insert-kbd-macro  "insert macro" ) 
      ("q" nil "cancel" nil)
 )
 #+END_SRC

**** help menu commands
#+BEGIN_SRC emacs-lisp :results none

(global-set-key
   (kbd "")
(defhydra hydra-toggles-help (:color blue :hint nil)

"
_k_ :describe key  _v_ describe variable _f_ describe functiom  
M-1- change windows
M-2 expand region (select gradualy regions)
~movment~ >> 【C-e//C-a】  (end/start of line)
~editing~ >>  【C-BKSP//A-BKSP】 (kill word start/end of line)



_q_: 
"

("a" nil )
("b"  nil  )
("c"  nil )
("d"  describe-last-function "describe last command used" )
("e"  nil )
("f"  describe-function )
("g"  nil )
("h"  nil )
("i"  nil )
("j"  nil )
("k"  describe-key )
("l"  nil )
("m"  nil )
("n"  nil )
("o"  nil )
("p"  nil )
("r"  nil )
("s"  nil )
("t"  nil )
("u"  nil )
("v"  describe-variable)
("w"  nil )
("x"  nil )
("y"  nil )
("z"  nil )
("q"  nil )

))
#+END_SRC

*** dired main (f2)
#+BEGIN_SRC emacs-lisp :results none

(global-set-key
   (kbd "<f2>")
(defhydra hydra-dired-main (:color blue :hint nil :columns 5)

"
【s】sort 【+】 add dir 【&/!】 open with 【M-n】 cycle diredx guesses 
【(】 toggle dired details 
【C/R/D/S】 copy/move(rename)/delete/symlink
【S-5-m】 mark by string // ^test(start with) txtDOLLAR (end with) 
【*s】 mark all 【*t】 invert mark 【*d】 mark for deletion 【k】 hide marked 【g】unhide mark 【*.】 mark by extension 【g】 refresh
【Q】query replace marked files 【o】open file new window 【V】open file read only 【i】open dir-view below
【b】preview file 【v】 viewer 【P】 peep-dir (image view)
"
("<f2>" dired "dired")
("<f1>" sunrise "sunrise")
("<f3>" dired-jump "dired jump")
("a" nil )
("b"  nil  )
("c"  hydra-dired-configs/body "dir configs")
("d"  nil )
("e"  nil )
("ff"  find-dired "find")
("fl"  find-lisp-find-dired "lisp find")
("fd"  find-lisp-find-dired-subdirectories "lisp find dirs" )
("g"  nil )
("h"  nil )
("i"  nil )
("j"  dired-jump "jump")
("k"  nil )
("l"  nil )
("m"  diredp-mark/unmark-extension "unmark extension")
("n"  dired-narrow-regexp "narrow")
("o"  hydra-dired-operation/body "dired operations")
("p"  peep-dired "peep-dired")
("r"  wdired-change-to-wdired-mode "wdired (bath rename)" )
("s"  z/dired-get-size "size" )
("t"  nil )
("u"  nil )
("v"  nil)
("w"  z/dired-copy-buffer-file-path "buffer path to clip" )
("x"  nil )
("y"  nil )
("z"   hydra-dired-filter/body  "filter" )
("q"  nil )

))
#+END_SRC


*** search/spelling/editing  (F3)

#+BEGIN_SRC emacs-lisp :results none
  (global-set-key
  (kbd "<f3>")
  (defhydra hydra-spell  (:color blue :hint nil :columns 4)
  "
【C-SPACE】 recntangle select // 【C-;】 ispell cycle // 【C-x z】 repeat last command- keep press 【z】to repeat
 "
  ("<f3>" endless/ispell-word-then-abbrev "check and add" )
  ("<f2>" flyspell-auto-correct-previous-word "correct last word" )
  ("<f4>" z/flyspell-goto-previous-error "goto prev error" )
  ("c"  cycle-spacing "cycle spacing")
  ("e"  hydra-editing/body "editing menu" 'hydra-face-green)
  ("g"  rgrep "Rgrep")
  ("h"  highlight-symbol "HS symbol")
  ("H"  highlight-symbol-remove-all "HS remove")
  ("f"  helm-flyspell-correct "helm-flyspell")
  ("i"  ispell "ispell")
  ("j"  highlight-symbol-next  :color red  "HS Next")
  ("k"  highlight-symbol-prev  :color red  "HS Prev")
  ("m"  flyspell-check-next-highlighted-word "check next error")
  ("n"  flyspell-goto-next-error "check next error" )
  ("p"  forward-whitespace "next whitespace"  )
  ("r"  hydra-rectangle/body "rectangle menu (part of hydra)")
  ("t"  z/activate-word-column-region "mark current char" )
  ("u"  imenu "imenu")
  ("v"  z/helm-insert-org-entity "insert Unicode")
  ("w"  ispell-word "ispeel word" )
  ("x"  xah-cycle-hyphen-underscore-space "cycle-underscore" )
  ("y"  nil )
  ("q"  nil )

  ))
#+END_SRC

*** code (f4)
 #+BEGIN_SRC emacs-lisp :results none
   (global-set-key
    (kbd "<f4>")
    (defhydra hydra-org-blocks (:color blue :hint nil :columns 4)
    "
to wrap by symbol mark region and then issue symbol, like: 【*】
"
    ("<f4>" z/org-cblock-iwrap-emacs-lisp "WRAP-Elisp" )
    ("<f3>" z/org-cblock-iwrap-sh  "Bash" )
    ("r" z/org-cblock-iwrap-emacs-R "WRAP-R" )
    ("a" z/org-cblock-iwrap-ASK  "Ask" )
    ("l" z/org-cblock-iwrap-ASK-LINE "Ask line" )
    ("m" z/org-cblock-iwrap-menu "Ask line" )
    ("pl" z/org-cblock-paste-lisp "paste lisp" )
    ("pb" z/org-cblock-paste-sh "paste bash" )
    ("pr" z/org-cblock-paste-R "paste R" )
    ("ps" z/org-cblock-paste-SAS  "paste SAS" )
    ("pe" z/org-cblock-paste-example  "paste Example" )
    ("pq" z/org-cblock-paste-QUOTE "paste QUOTE" )
    ("e" z/org-cblock-nowrap-example "insert Example block" )
    ("q" nil "cancel")))

 #+END_SRC
   
*** latex/bib (F6)

#+BEGIN_SRC emacs-lisp :results none

(global-set-key
   (kbd "<f6>")
(defhydra hydra-bib  (:color blue :hint nil :columns 4)

"
Reference management
"
("<f6>" helm-bibtex "helm-bibtex")

("a" nil )
("b" (find-file "/home/zeltak/org/files/Uni/papers/kloog.papers.bib") "ikloog-bitex file"   :face 'hydra-face-purple )
("c"  org-ref-clean-bibtex-entry "clean bib"  :face 'hydra-face-red )
("d"  doi-utils-add-bibtex-entry-from-doi "add by doi"  :face 'hydra-face-brown)
("e"  ebib )
("f"  nil )
("g"  nil )
("h"  nil )
("i"  nil )
("j"  nil )
("k"  helm-bibtex-ikloog-publications "kloog papers"  :face 'hydra-face-green )
("K"  helm-bibtex-ikloog-publications-all "kloog ALL"  :face 'hydra-face-green )
("l"  nil )
("m" (find-file "/home/zeltak/org/files/Uni/papers/paper.meta.org") "ikloog-meta file"  :face 'hydra-face-purple )
("n"  org-bibtex-create "new bib entry")
("o"  nil )
("p"  helm-bibtex-ikloog-prep "kloog prep"  :face 'hydra-face-green )
("r"  helm-resume "helm resume")
("s"  bibtex-sort-buffer "sort buffer"  :face 'hydra-face-red)
("t"  helm-bibtex-papers-rtodo  "toread papers"  :face 'hydra-face-green )
("u"  nil )
("v"  bibtex-validate "validtae"  :face 'hydra-face-red )
("V"  bibtex-validate-globally "validate-check for dups"  :face 'hydra-face-red)
("w"  nil )
("x"  crossref-add-bibtex-entry "search crossref" )
("y"  org-bibtex-yank "yank bibtex")
("z"  nil )
("q"  nil )

))


#+END_SRC

*** N/A (F7)

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f7>")
(defhydra hydra-f7 (:color blue  :columns 2 :hints nil)
  "
"
  ("<f7>"     company-complete            "complete")
  ("<f6>"     company-dabbrev            "dabbrev comp")
  ("y"   company-yasnippet  "yasnippet comp")
  ("m"   company-manual-begin  "manual comp")
  ("c"   company-complete-common  "commom comp")
  ("n"   company-select-next  "next comp")
    ("q"     nil                          "cancel" )
))
#+END_SRC



*** bookmark hydra (F8)

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f8>")
(defhydra  hydra-open  (:color blue :hint nil :columns 4)
"
【C-c h】helm-prefix 【*】to select mode 【@】to select regex 【,】to select multiple (modes,regex) 【!】exclude 
【C-z】persistant select 【C-l】up dir 【C-r】back dir 
【~/】add to go back to home 【./】 default-directory  【C-c h】history (C-u before to auto go to history)
【C-s】grep Helm  【C-u】recursively grep Helm 【C-c h b】 helm res
【C-f/b】 helm frwd/back 1 char
"
("<f8>" helm-bookmarks "BKMK's")
("<f7>" helm-mini "helm-mini")
("<f9>" projectile-find-file  "projectile ff")
("7" org-iswitchb "org buffers")
("a" nil )
("b"  bmkp-bookmark-set-confirm-overwrite "add BKMK" )
("c"  helm-chrome-bookmarks "Chorme BKMK")
("d"  z/helm-buffers-dired "dired buffers" )
("e"  nil )
("f"  bmkp-bmenu-filter-tags-incrementally "BKMK menu filter")
("g"  nil )
("h"  nil )
("i"  helm-projectile "Helm Projectile")
("j"  helm-projectile-switch-to-buffer "Helm projectile switch" )
("k"  nil )
("l"  nil )
("m"  bookmark-bmenu-list "BKMK menu")
("n"  nil )
("o"  z/helm-buffers-org "org buffers")
("p"  projectile-find-file "projectile find file")
("r"  helm-recentf "Helm Recents" )
("s"  bookmark-save "BKMK Save" )
("t"  z/launch--ansi-term "ansi-term" )
("u"  nil )
("v"  nil)
("w"  nil )
("x"  nil )
("y"  nil )
("z"  nil )
("q"  nil )

))

#+END_SRC

*** org (F9)
**** org main
     :PROPERTIES:
     :ID:       5d5567f8-9f16-4b76-adb6-8600ce16e2ec
     :END:

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f9>")
(defhydra hydra-org (:color blue :hint nil :columns 4)

"ORG editing
【C-c -】 convert to dashed lines  【C-M-l  org table menu
【C-u C-u C-c c】 go to where capture was filled
"

("<f9>" worf-goto "worf org headers")
("<f10 w>" helm-org-headlines "helm org headers")
("<f10> v" org-velocity-read  "org valocity")
("<f8>" z/org-insert-heading-link "link/refile")
("RET"  org-insert-todo-heading "org todo header//check list")
("<f10> RET"  org-insert-subheading "org sub header")
("<f10> t"  org-insert-todo-subheading "org sub header")
("."  org-do-demote "<" :color red)
(","  org-do-promote ">" :color red)
("<"  org-promote-subtree "T<" :color red)
(">"  org-demote-subtree "T>" :color red)

("a"  org-sort "sort")
("b"  worf-mode "worf"  )
("c"  org-columns "Columns" )
("C"  org-columns-quit "quit Columns" )
("d"  org-download-screenshot "screenshot")
("D"  org-download-delete "del screenshot")
("E"  org-export-dispatch "export")
("ep" org-latex-export-to-pdf "export latex")
("er" z/org-export-revel-browse "export reveal browse")
("et" z/org-export-revel-subtree "export reveal subtree")
("ey" z/org-export-revel-html  "export reveal html ")
("f"  hydra-org-food/body "food menu"  :face 'hydra-face-orange )
("g"  org-set-tags "tags dialog")
("h"  org-search-view "org search")
("i"  org-toggle-inline-images "toggle images")
("j"  nil )
("k"  nil )
("l"  hydra-org-links/body "link menu" :face 'hydra-face-green)
("m"  org-mark-subtree "mark subtree" )
("p"  org-insert-drawer "insert drawer" )
("r"  org-refile "refile")
("R"  z/prefix-org-refile "jump to header using refile")
("s"  hydra-org-time/body "time menu" :face 'hydra-face-orange )
("t"  org-todo "todo dialog")
("u"  nil )
("v"  org-babel-execute-subtree "exe block")
("w"  z/narrow-or-widen-dwim "Toggle narrow//widen" )
("x"  org-archive-subtree "Archive" )
("-"  org-toggle-heading "Header lower" )
("="  z/org-convert-header-samelevel "Header same")
("0"  org-ctrl-c-star "convert lines to headers")
("\\"  hydra-org-table/body "table menu"  :face 'hydra-face-orange )
(";"  z/comment-org-in-src-block "comment block" )
("y"  nil )
("z"  nil )
("<home>" outline-up-heading  "up main header" :color red)
("<down>" org-forward-heading-same-level  "up header" :color red)
("<up>" org-backward-heading-same-level  "down header" :color red)
("q"  nil )

))
#+END_SRC
   
**** extra org links commands
 #+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-org-links (:color blue  :hint nil :columns 3)
      "
link menus 
      "
     ("u" org-link-edit-forward-slurp  "forward slurp")
     ("y" org-link-edit-backward-slurp  "back  slurp")
     ("j" org-link-edit-forward-barf  "forward edit")
     ("k" org-link-edit-backward-barf  "backward edit")
     ("i" org-insert-link   "insert (or edit if on link)//also 【C-c C-l】" ) 
     ("d" org-id-create "just create Id")
     ("w"  z/org-link-paste-file-path "paste file link")
     ("p" org-cliplink "org-cliplink")
     ("o"  link-hint-open-link "open link" )
     ("c" org-id-copy  "copy(and create) to killring" ) 
     ("s" org-id-store-link  "store org-id" ) 
     ("f" z/org-link-file  "link to file (via helm)" ) 
     ("k" worf-copy-heading-id  "worf copy id of killring" ) 
     ("q" nil "cancel" nil)
 )
 #+END_SRC

org-link-edit-forward-barf
;; - org-link-edit-backward-barf

**** org cooking 
#+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-org-food ()
   "org-food "
   ("b" cooking-sparse-tree-breakfeast "breakfeast_view" :color blue)
   ("m" cooking-sparse-tree-main "main_view" :color blue)
   ("r" recipe-template "recipe-template" :color blue)
   ("t" travel-template  "travel-template" :color blue)
   ("q" nil "cancel")
)
#+END_SRC

**** org bable

#+BEGIN_SRC emacs-lisp :results none

(global-set-key
   (kbd "C-M-v")
(defhydra hydra-org-tangle  (:color blue :hint nil)

"
_a_:         _b_:         _c_:        _d_:        _e_:           _f_:         _g_:  
_h_:         _i_:         _j_:       _k_:       _l_:          _m_:        _n_:      
_o_:        _p_: tang-atpoint        _r_:       _s_:       _t_: tangle file           _u_:       
_v_:        _w_:        _x_:       _y_:       _z_: 
_q_: quit 

"

("a" nil )
("b"  nil  )
("c"  nil )
("d"  nil )
("e"  nil )
("f"  nil )
("g"  nil )
("h"  nil )
("i"  nil )
("j"  nil )
("k"  nil )
("l"  nil )
("m"  nil )
("n"  nil )
("o"  nil )
("p"  z/org-tangle-atpoint )
("r"  nil )
("s"  nil )
("t"  org-babel-tangle )
("u"  nil )
("v"  nil)
("w"  nil )
("x"  nil )
("y"  nil )
("z"  nil )
("q"  nil )

))


#+END_SRC


**** orgmode time functions 

 #+BEGIN_SRC emacs-lisp :results none
  (defhydra hydra-org-time  (:color blue :hint nil :columns 4)
"
☚+1w☛ implies that this event will repeat every week at the same time & date  ☚--☛ multi day
【.】 Go to today 【r】rebuild agenda 
【Ctrl+c .】 fri 【Return】// If you want an inactive date use 【Ctrl+c !】 fri 【Return】
"
    ("s"  org-time-stamp "agenda date")
    ("X" org-time-stamp-inactive  "stamp date" )
    ("Y" z-insert-date "insert current data")  
    ("d" org-deadline  "set deadline")  
    ("f" org-schedule  "set schedule")  
    ("w" org-clone-subtree-with-time-shift   "clone and time shift")  
    ("q" nil "cancel")
 )
 #+END_SRC



*** org editing (C-M-o)						     

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "C-M-o")
 (defhydra hydra-org-edit (:color blue :hint nil :columns 4)
   "orgmode editing "
   ("t" org-insert-todo-heading-respect-content "insert TODO" )
   ("d" org-cut-subtree  "org cut" )
   ("y" org-copy-subtree "org copy" )
   ("p" org-paste-subtree  "org paste" )
   ("e" z/org-email-heading  "email header" )
   ("z" z/org-email-heading-me  "email header ikloog" )
   ("r" org-copy  "copy via refile" )
   ("m" org-teleport  "teleport header " )
   ("h" org-set-line-headline "line to headline" )
   ("c" org-set-line-checkbox  "line to checkbox" )
   (";" z/org-cblock-comment  "line to checkbox" )
   ("s" org-clone-subtree-with-time-shift  "add a time series for headers" )
   ("w" worf-mode "Worf mode" )
   ("<up>" org-move-subtree-up "header up" :color red )
   ("<down>" org-move-subtree-down "header down" :color red)
   ("q" nil "cancel")))

#+END_SRC

(define-key evil-normal-state-map (kbd "]h") 'org-metaright)
(define-key evil-normal-state-map (kbd "[h") 'org-metaleft)
(define-key evil-normal-state-map (kbd "]j") 'org-metadown)
(define-key evil-normal-state-map (kbd "[j") 'org-metaup)
(define-key evil-normal-state-map (kbd "]k") 'outline-demote)
(define-key evil-normal-state-map (kbd "[k") 'outline-promote)
(define-key evil-normal-state-map (kbd "]o") 'outline-next-visible-heading)
(define-key evil-normal-state-map (kbd "[o") 'outline-previous-visible-heading)
(define-key evil-normal-state-map (kbd "]t") 'outline-forward-same-level)
(define-key evil-normal-state-map (kbd "[t") 'outline-backward-same-level)
(define-key evil-normal-state-map (kbd "]b") 'org-next-block)
(define-key evil-normal-state-map (kbd "[b") 'org-previous-block)
(define-key evil-normal-state-map (kbd "]r") 'org-table-move-row-down)
(define-key evil-normal-state-map (kbd "[r") 'org-table-move-row-up)
(define-key evil-normal-state-map (kbd "]c") 'org-table-move-column-right)
(define-key evil-normal-state-map (kbd "[c") 'org-table-move-column-left)
(define-key evil-normal-state-map (kbd "]f") 'org-table-next-field)
(define-key evil-normal-state-map (kbd "[f") 'org-table-previous-field)
(define-key evil-normal-state-map (kbd "]l") 'org-next-link)
(define-key evil-normal-state-map (kbd "[l") 'org-previous-link)
(define-key evil-normal-state-map (kbd "]u") 'org-down-element)
(define-key evil-normal-state-map (kbd "[u") 'org-up-element)


*** org  tags
    :PROPERTIES:
    :ID:       b1bd78ae-83b5-4cb4-a4b5-6db5287f3956
    :END:
 #+BEGIN_SRC emacs-lisp :results none
(global-set-key
    (kbd "")
 (defhydra hydra-org-tags  (:color blue :hint nil :columns 4)
 "
 "

("1" (org-set-tags-command) "set tags"  :face 'hydra-face-green)
("a" (org-set-tags-to "allan") "Allan" )
("b" (org-set-tags-to "boris") "Boris" )
;("c" (org-set-tags-to "") "tags" )
("d" (org-set-tags-to "david") "David" )
;("e" (org-set-tags-to "allan") "tags" )
;("f" (org-set-tags-to "allan") "tags" )
;("g" (org-set-tags-to "allan") "tags" )
("h" (org-set-tags-to "hila") "Hila" )
;("i" (org-set-tags-to "allan") "tags" )
("j" (org-set-tags-to "joel") "Joel" )
;("k" (org-set-tags-to "allan") "tags" )
("l" (org-set-tags-to "lara") "Lara" )
("m" (org-set-tags-to "meytar") "Meytar" )
;("n" (org-set-tags-to "allan") "tags" )
("o" (org-set-tags-to "omer") "Omer" )
;("p" (org-set-tags-to "allan") "tags" )
;("q" (org-set-tags-to "allan") "tags" )
("r" (org-set-tags-to "adar") "Adar" )
("s" (org-set-tags-to "massimo") "Massimo" )
("S" (org-set-tags-to "francesca") "Francesca" )
;("t" (org-set-tags-to "allan") "tags" )
;("u" (org-set-tags-to "allan") "tags" )
("v" (org-set-tags-to "adi") "Adi" )
;("w" (org-set-tags-to "allan") "tags" )
("x" (org-set-tags-to "alex") "Alex" )
("y" (org-set-tags-to "maayan") "Maayan" )
("z" (org-set-tags-to "bob") "Bob" )
("q" nil "cancel")

))
 #+END_SRC


*** agenda (F10)

**** org agenda main
     :PROPERTIES:
     :ID:       5d5567f8-9f16-4b76-adb6-8600ce16e2ec
     :END:
#+BEGIN_SRC emacs-lisp :results none
  (global-set-key
     (kbd "<f10>")
  (defhydra hydra-org-agenda (:color blue :hint nil :columns 4)
"AGENDA:
【g】- Refresh agenda 
【SPACE//TAB】open//open-go item in side view 【F】will toggle follow mode for space/tab view
【A】Append another view 【/】 filter tag 【=】 filter regex 【|】 clean all filters
【v】Choose view 【f】forward in time 【b】back in time 【.】goto today 【j】 jump to date
【S-left//right】 change deadline 【k】 launch capture with date/task
【:】 set tags 【,】set priority (then choose) 【S-U/D/L/R】 change todo/pri 
【m,u,U...】 dired marking 【M-m】toggle marking 【B】 execute on marks via dispatcher 【v】 view mode                             
mark items +【B s】-Reschedule multiple items

"
      ("<f10>" z/org-agenda-calendar  "org agenda"  )
      ("<f9>" cfw:open-org-calendarz  "month calendar"  )
      ("c"  org-agenda-columns  "agenda columns" )
      ("t"    org-agenda-todo      "change todo")
      ("k"    org-agenda-kill      "delete C-k")
      ("m"    org-agenda-bulk-toggle  "bulk mark"  :color red ) 
      ("x"    org-agenda-bulk-action  "bulk exe")
      ("x"   org-agenda-archive      "archive ")
      ("w"   org-agenda-refile      "refile ")
      (":"   org-agenda-set-tags      "set tags ")
      (","   org-agenda-priority      "priority (S-UP/S-Dn to change as well ")
      ("s"   org-agenda-schedule      "schedule task ")
      ("d"   org-agenda-deadline      "deadline task ")
      ("p"   org-agenda-date-prompt      "prompt date ")
      ("M"   cfw:org-open-agenda-day      "month view ")
      ("z"  cfw:open-org-calendar "month calander" )
       ("q"     nil                          "cancel" )
  ))
#+END_SRC

*** TODOS  (F11)
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "<f11>")
   (defhydra hydra-buffer  (:color blue :hint nil :columns 4)
     "TODO commands "
     ("<f11>" org-agenda "org-agnda" )
     ("l" z/org-agenda-allan "Allan" )
     ("j" z/org-agenda-joel  "Joel"  )
     ("s"   z/org-agenda-search     "regex search")
     ("t"   z/org-agenda-search-todo     "regex search TODO")
      ("c"   z/org-agenda-cook      "cook")
     ("fa" (org-tags-view nil "Cuisine=\"American\"") "food-american" )
     ("fa" (org-tags-view nil "Cuisine=\"American\"") "food-american" )
     ("d" "")
     ("i" "" )
     ("c" ""  )
     ("k"  "" )
     ("n" "" )
     ("p" (org-agenda nil "w") "work+home"  )
     ("w" z/org-agenda-work  "Work"  )
     ("q" nil "cancel")))

#+END_SRC


*** hydra spliter
 #+BEGIN_SRC emacs-lisp :results none
; (require 'hydra-examples)
; (hydra-create "C-M-o" hydra-example-move-window-splitter)

; (hydra-create "C-M-o"
;   '(("h" hydra-move-splitter-left)
;     ("j" hydra-move-splitter-down)
;     ("k" hydra-move-splitter-up)
;     ("l" hydra-move-splitter-right)))
 #+END_SRC

*** yas (C-M-y)
*** rectangle 
#+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-rectangle (:color blue  :columns 6 :hint nil)
   "rectangle commands "
   ("1" rectangle-number-lines "rectangle lines" :color blue)
   ("q" nil "cancel"))
#+END_SRC
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "C-M-y")
 (defhydra hydra-yas ()
   "yas command "
   ("a" yas-activate-extra-mode "enable Emacs mode for yas" :color blue)
   ("n" yas-new-snippet "add new snippet" :color blue)
   ("v" yas-visit-snippet-file "visit" :color blue)
   ("i" yas-insert-snippet "insert_point" :color blue)
   ("r" yas-reload-all  "reload" :color blue)
   ("t" yas-tryout-snippet  "try snipet" :color blue)
   ("q" nil "cancel")))
#+END_SRC
*** org tables (C-M-t)

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "C-M-l")

(defhydra hydra-org-table (:color blue  :columns 6)
"【C-c +】 will sum a column and move to clip  【C-space】 blank field 【M-left/right】move column left/right  【M-S-left/right】kill/add column 
【M-up/down】 move row up/down 【M-S-down】 insert row  【M-S-up】 kill row
【|-】 will start a dashed line 【C-c +】 org sum 【C-c ?/}】 find/show out field info 
【@row$column】>>  @2$3 will mean 2nd row, 3rd column 
 $1..$3f  firtst three fields in the current row // @2$1..@4$3  6 fields between these two fields
FORUMLAS: 【C-c =】 insert formula 【C-c *】 recalculate formula  vmean/vsum 
【:=】insert formula directly >> :=vsum(@2$3..@32$3)
"
     ("i" org-table-insert-row  "insert row" :color blue) 
     ("y" org-table-copy-region  "copy" :color blue) 
     ("d" org-table-cut-region  "cut" :color blue) 
     ("p" org-table-paste-rectangle  "paste" :color blue) 
     ("s" org-table-sort-lines  "sort" :color blue) 
     ("c" org-table-create-or-convert-from-region  "convert" ) 
     ("w" quick-calc  "quick calc" ) 
   ("q" nil "cancel")))
#+END_SRC
*** Editing (C-M-e)
**** main editing command 
 #+BEGIN_SRC emacs-lisp :results none
   (global-set-key                         
    (kbd "C-M-e")
    (defhydra hydra-editing (:color blue :hint nil :columns 4)
      "editing command"
      ("e" hydra-edit-extra/body  "Extra editing commands")
      ("<up>" drag-stuff-up  "marked up" :color red)
      ("<down>" drag-stuff-down  "marked down" :color red)
      ;("<left>" drag-stuff-left  "marked left" :color red)
      ;("<right>" drag-stuff-right "marked right" :color red)
      ("p" duplicate-current-line-or-region  "duplicate" :color red)
       ("o"
 	crux-smart-open-line  "open line" )
      (";"  hydra-commenting/body  "comment!" )
      ("i"  hydra-editing-insert/body  "insert" )   
      ("f" flush-blank-line  "flush blank" )
      ("u" z-fix-characters "fix unicode" )
      ("g" google-search "google searh selected" )
      ("c" z/comment-box "comment box" )
      ("u" upcase-region  "upcase " )
      ("d" downcase-region  "downcase " )
      ("h" z/edit-copy-all-or-region  "copy buffer" )
      ("w" shrink-whitespace  "shrink-whitespace" )
      ("R" revert-buffer  "revert buffer before changes" ) 
      ("q" nil "cancel")))

 #+END_SRC
**** extra editing commands

 #+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-edit-extra (:color blue :hint nil )
      "
 fix _u_nicode issue  // u_p_case region // _d_owncase region 
      "
      ("u" z-fix-characters  "fix unicode" ) 
      ("p" upcase-region  "upcase region" ) 
      ("d" downcase-region  "downcase region" ) 
      ("f" toggle-fill-unfill  "fill/unfill")
      ("r" z-edit-file-as-root  "edit as root")
      ("q" nil "cancel" nil)
      ("1" z/regex-delete-numeric "delete numbers")
 )

 #+END_SRC

**** commenting sub hydra 

#+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-commenting (:color blue  )
     "
comment  _;_ // comment _t_o line // comment para_g_raph // co_p_y-paste-comment 
comment _e_macs function  // copy-paste-comment-function _r_  

     "
     (";" evilnc-comment-or-uncomment-lines  "comment" ) 
     ("t" evilnc-quick-comment-or-uncomment-to-the-line   "c 2 line"  nil ) 
     ("g" evilnc-comment-or-uncomment-paragraphs  "c paragraph"  nil ) 
     ("p" evilnc-copy-and-comment-lines  "c,c,p"  nil ) 
     ("e" z/comment-line  "comment-line-emacsfun" :color blue)
     ("r" z/copy-comment-paste  "c,c,p-fun " :color blue)
     ("q" nil "cancel" nil)
)

#+END_SRC

**** hydra-editing-insert (insert Unicode)
add the org faces macros here (%Tip%, $Note$ etc)


#+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-editing-insert  (:color blue  :columns 4 :hints nil)
  "unicode"
  ("k"     z/insert-black-lenticular-bracket  "【】") 
  ("g"     z/insert-black-lenticular-bracket-white  "〖") 
  ("c"     z/insert-black-lenticular-angle  "»") 
  ("d"     z/insert-black-lenticular-angle-bold  "❱") 
  ("e"     z/insert-black-arrows  "◀ ▶") 
  ("f"     z/insert-black-hands  "☚ ☛") 
  ("j"     z/insert-black-lenticular-angle  "«»") 
  ("b"     z/insert-bashscript  "insert basg #!") 
  ("p"     z/insert-play  " ‣") 
  ("w"     z/insert-white-arrow  "▻") 
  ("o"     z/insert-EOL  " \\") 
  ("r"    z/insert-reveal-split  "reveal-split") 
  ("q" nil "cancel" nil)
)
#+END_SRC
*** password-store (C-M-p)
**** main editing command 
 #+BEGIN_SRC emacs-lisp :results none
   (global-set-key                         
    (kbd "C-M-p")
    (defhydra hydra-password-store (:color blue :columns 4 :hint nil)
      "password store command"
      ("e" password-store-edit   "edit pass" )
      ("d" password-store-remove   "delete pass" )
      ("q" nil "cancel")))

 #+END_SRC
*** ace (C-M;)
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "C-M-;")
 (defhydra hydra-avi ()
   "yas command "
   ("g" avi-goto-char-2 "avi-goto-char-2" :color blue)
   ("c" avi-goto-char "avi-goto-char" :color blue)
   ("l" avi-goto-line "avi-goto-line" :color blue)
   ("4" avi-copy-line  "avi-copy-line" :color blue)
   ("3" avi-move-line  "avi-move-line" :color blue)
   ("r" avi-copy-region  "avi-copy-region" :color blue)
   ("a" avi-goto-word-1  "avi-goto-word-1" :color blue)
   ("v" avi-goto-word-0  "avi-goto-word-0" :color blue)
   ("z" ace-jump-zap  "zap text" :color blue)
   ("q" nil "cancel")))
#+END_SRC

*** windows (F12)

#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "<f12>")
 (defhydra hydra-window (:color blue :hint nil :columns 5)
 "Window and buffer Operations"
   ("<f12>" switch-to-previous-buffer  "last buffer"  )
   ("<f11>" ace-delete-window "delete window")
   ("<home>" ace-window "ace-window//also M-1" :exit t)   
   ("0" z/toggle-window-split "toggle splits")   
   ("=" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right))
        "Split Vertical (|)")
   ("-" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down))
        "Split horzizontal (-)")
   ("<left>" hydra-move-splitter-left "resize left"  :color red)
   ("<right>" hydra-move-splitter-right "resize right"  :color red)
   ("<up>" hydra-move-splitter-up "resize up"  :color red)
   ("<down>" hydra-move-splitter-down "resize down"  :color red)
   ("t" ace-swap-window  "transpose (ace-swap)")
   ("i" ace-maximize-window "ace-one" )
   ("r" resize-window "resize menu" )
   ;;Note winer mode must be enabled
   ("u" winner-undo "winner undo")
   ("s" save-buffer "save buffer"  )
   ("a" write-file  "save as.."  )
   ("x" kill-this-buffer "kill buffer"  )
   ("c" z-save-buffer-close-window "save and close"  )
   ("n" next-user-buffer  "next buffer" )
   ("p" previous-user-buffer "prev buffer"  )
   ("N" next-emacs-buffer "next Emacs  buffer"  )
   ("P" previous-emacs-buffer "prev emacs buffer"  )
   ("da" ace-delete-window)
   ("db" kill-this-buffer)
   ("df" delete-frame "delete frame")
   ("kw" delete-window "delete window")
   ("ka" delete-other-windows "delete all other  windows")
   ("kh" kill-buffer "helm kill buffer" )
   ("kb" z-kill-other-buffers "kill all but current" )
   ("q" nil "cancel")))

#+END_SRC
*** hydra goto
pop-global-mark this will move you to prev position 

#+BEGIN_SRC emacs-lisp :results none
(defhydra hydra-goto  (:color blue :hint nil :columns 5)
  "goto"
  ("g" goto-line "line")
  ("c" goto-char "char")
  ("o" ace-link-org "goto org link")
  ("2" er/expand-region "expand")
  ("z"  avy-zap-to-cha "avy zap")
  ("q" nil "quit"))
#+END_SRC
(global-set-key (kbd "<f3> o") 'back-button-global)

*** TODO vim

#+BEGIN_SRC emacs-lisp :results none
  (defhydra hydra-vi (:body-pre hydra-vi/pre
                      :color    amaranth)
    "vi"
    ;; basic navigation
    ("l"        forward-char                  nil)
    ("h"        backward-char                 nil)
    ("j"        next-line                     nil)
    ("k"        previous-line                 nil)
    ;; mark
    ("m"        set-mark-command              "mark")
    ("C-o"      (set-mark-command 4)          "jump to prev location")
    ;; beginning/end of line
    ("a"        back-to-indentation-or-beginning-of-line "beg of line/indentation")
    ("^"        back-to-indentation-or-beginning-of-line "beg of line/indentation")
    ("$"        move-end-of-line              "end of line")
    ;; word navigation
    ("e"        forward-word                  "end of word")
    ("w"        modi/forward-word-begin       "beg of next word")
    ("b"        backward-word                 "beg of word")
    ;; page scrolling
    ("<prior>"  scroll-down-command           "page up")
    ("<next>"   scroll-up-command             "page down")
    ;; delete/cut/copy/paste
    ("x"        delete-forward-char           "del char")
    ("d"        my/iregister-cut              "cut/del")
    ("D"                 "cut/del line")
    ("y"        my/iregister-copy             "copy")
    ("p"        yank                          "paste")
    ;; beginning/end of buffer and go to line
    ("g"        hydra-vi/beginning-of-buffer  "beg of buffer/goto line")
    ("G"        hydra-vi/end-of-buffer        "end of buffer/goto line")
    ("<return>" goto-line                     "goto line")
    ;; undo/redo
    ("u"        undo-tree-undo                "undo")
    ("C-r"      undo-tree-redo                "redo")
    ;; misc
    ("<SPC>"    ace-jump-mode                 "ace jump")
    ;; exit points
    ("q"        hydra-vi/post                 "cancel" :color blue))

#+END_SRC
*** TODO hydra mark

#+BEGIN_SRC emacs-lisp  :results none
(global-set-key
 (kbd "M-2")
(defhydra hydra-mark-er (:body-pre (call-interactively 'set-mark-command) :hint nil :columns 4
                               :exit t )
  "hydra for mark commands"
  ("2" er/expand-region "expand region")
  ("P" er/mark-inside-pairs)
  ("Q" er/mark-inside-quotes)
  ("p" er/mark-outside-pairs)
  ("q" er/mark-outside-quotes)
  ("d" er/mark-defun)
  ("c" er/mark-comment)
  ("." er/mark-text-sentence)
  ("h" er/mark-text-paragraph)
  ("w" er/mark-word)
  ("u" er/mark-url)
  ("m" er/mark-email)
  ("s" er/mark-symbol)
  ("j" (funcall 'set-mark-command t) :exit nil)))

#+END_SRC

*** search (C-S-s)
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
 (kbd "C-S-s")
 (defhydra hydra-search  (:color blue :hint nil :columns 4) 
   " "
  ("1" helm-swoop "find word@point in document")
  ("2" helm-multi-swoop  "find word@point in selected documents")
  ("3" helm-multi-swoop-org "find word@point in org agenda")
  ("a" helm-ag "Helm-ag")
  ("d" z/helm-mg-prefix "helm-ag-recursive" )
  ("D" helm-do-ag-project-root "helm-ag in porject" )
  ("g" helm-do-grep "helm-grep" )
  ("f"  helm-find-files "Helm FF" )
  ("l" helm-locate "helm-locate")
  ("L" counsel-locate "council-locate")
  ("o" helm-occur "helm Occur")
  ("O"  org-occur "org-occur" )
  ("P" helm-apropos "Helm-Apropos")
  ("n"  helm-swish-e "swish")
  ("r" rgrep "rgrep")
  ("R" anzu-query-replace-at-cursor "Replace@cursor")
  ("s" isearch-forward "isearch" )
  ("S" isearch-forward-symbol-at-point "isearch@point" )
  ("z" counsel-recoll "recoll" )
  ("9" goto-last-change "goto last change" )
  ("0" goto-last-change-revrese "goto prev change" )  


   ("q" nil "cancel")))
#+END_SRC


* Macros
** Editing
*** lines not paragraphs
#+BEGIN_SRC emacs-lisp :results none
;;;; Saved macros
;; Saved macro - adds latex end-lines to verse passages
(fset 'versify
      [?\C-a ?\C-e ?\\ ?\\ down])

;(global-set-key (kbd "") 'versify)
#+END_SRC

** prefix macro
#+BEGIN_SRC emacs-lisp :results none
(defmacro C-u (&rest args)
  (let ((prefix (list 4)))
    (while (cdr args)
      (cond
       ((eq (car args) 'C-u)
        (setf (car prefix) (* 4 (car prefix))))
       ((eq (car args) 'M-x)
        ;; ignore
        t)
       (t
        (error "Unknown arg %S" (car args))))
      (setq args (cdr args)))
    (unless (functionp (car args))
      (error "%S is not a function" (car args)))
    `(lambda ()
       (interactive)
       (let ((current-prefix-arg ',prefix))
         (call-interactively ',(car args))))))
#+END_SRC
* Settings
  :PROPERTIES:
  :ID:       0991546e-92b4-42d3-9b99-d3c639d2d5f8
  :END:
** XDG/open with 
*** set emacs browser
#+BEGIN_SRC emacs-lisp :results none
(setq browse-url-browser-function (quote browse-url-generic))
(setq browse-url-generic-program "firefox")
;;(setq browse-url-generic-program "chromium")
#+END_SRC
** Backup
Auto-backup is triggered when you save a file - it will keep the old version of the file around, adding a ~ to its name. 
auto-save-mode auto-saves a file every few seconds 
here we put these files in the /tmp dir

#+BEGIN_SRC emacs-lisp :results none
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+END_SRC

** Save and sessions
#+BEGIN_SRC emacs-lisp :results none
;If I reopen a file, I want to start at the line at which I was when I closed it.
; save the place in files
(require 'saveplace)
(setq-default save-place t)

; save minibuffer history
(require 'savehist)

(setq savehist-additional-variables '(search-ring
                                      regexp-search-ring
                                      file-name-history
                                      extended-command-history
                                      kill-ring
                                      sr-history-registry
                                        ))

;;autosave
;(setq auto-save-visited-file-name t)
;(setq auto-save-interval 20) ; twenty keystrokes
(setq auto-save-timeout 60) ; ten idle seconds

(savehist-mode t)

#+END_SRC

** history

#+BEGIN_SRC emacs-lisp :results none
(setq savehist-file "/home/zeltak/.emacs.t/hist.txt")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC

** recentf

$note its built into emacs no intsall needed$

#+BEGIN_SRC emacs-lisp :results none
 (setq recentf-save-file "/home/zeltak/.emacs.t/recentf")  ;; (setq recentf-auto-cleanup 'never) ;; disable before we start recentf!
(require 'recentf)
(recentf-mode 1)
(setq recentf-max-menu-items 50)
;(setq recentf-auto-cleanup 'never) ;; disable before we start recentf!
#+END_SRC

** Remote
*** ssh
#+BEGIN_SRC emacs-lisp :results none
(require 'tramp) ; Remote file editing via ssh
(setq tramp-default-method "ssh")
#+END_SRC
** TERM
*** set default term zshrc
#+BEGIN_SRC emacs-lisp :results none
(setq explicit-shell-file-name "/bin/zsh")
#+END_SRC
** performance improvement
#+BEGIN_SRC emacs-lisp :results none
(setq cache-long-scans nil)
#+END_SRC
** file completion

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
(setq read-buffer-completion-ignore-case t)
(mapc (lambda (x)
        (add-to-list 'completion-ignored-extensions x))
      '(".aux" ".bbl" ".blg" ".exe"
        ".log" ".meta" ".out" ".synctex.gz" ".tdo" ".toc"
        "-pkg.el" "-autoloads.el"
        "Notes.bib" "auto/"))
#+END_SRC
** TRAMP
*** set temp directory
#+BEGIN_SRC emacs-lisp  :results none
(setq temporary-file-directory "/tmp")
#+END_SRC
*** cache password
don't let passwords expire
#+BEGIN_SRC emacs-lisp  :results none
(setq password-cache-expiry nil)
#+END_SRC
*** tramp defaults and use .ssh settings 
#+BEGIN_SRC emacs-lisp  :results none
(setq tramp-default-method "ssh"
        tramp-default-user-alist '(("\\`su\\(do\\)?\\'" nil "root"))
        tramp-adb-program "adb"
        ;; use the settings in ~/.ssh/config instead of Tramp's
        tramp-use-ssh-controlmaster-options nil
        backup-enable-predicate
        (lambda (name)
          (and (normal-backup-enable-predicate name)
               (not (let ((method (file-remote-p name 'method)))
                      (when (stringp method)
                        (member method '("su" "sudo"))))))))
#+END_SRC
*** use sudo with ssh
http://mollermara.com/tags/productivity/

It’s even possible to remotely edit files as root using /sudo:server:/path/to/file, although this doesn’t work out of the box. You’ll need to add this to your .emacs

#+BEGIN_SRC emacs-lisp  :results none
(add-to-list 'tramp-default-proxies-alist 
     '((and (string-match system-name 
                  (tramp-file-name-host (car target-alist)))
            "THISSHOULDNEVERMATCH")
       "\\`root\\'" "/ssh:%h:"))
#+END_SRC

This allows you to sudo into remote servers, but also prevents it from interfering with sudoing locally.

** Editing
*** spelling
#+begin_src emacs-lisp results none
;Spelling
(autoload 'flyspell-mode "flyspell" "On-the-fly spelling checker." t)
(autoload 'flyspell-delay-command "flyspell" "Delay on command." t)
(autoload 'tex-mode-flyspell-verify "flyspell" "" t) 


(defun flyspell-check-next-highlighted-word ()
  "custom function to spell check next highlighted word"
  (interactive)
  (flyspell-goto-next-error)
  (ispell-word)
  )

#+end_src
*** warn on large files
set currently to 100mb
#+BEGIN_SRC emacs-lisp :results none
;; warn when opening files bigger than 100MB
(setq large-file-warning-threshold 100000000)
#+END_SRC
** suppress specific windows from popping up

#+BEGIN_SRC emacs-lisp  :results none
(add-to-list 'display-buffer-alist '("*Async Shell Command*"  display-buffer-no-window))
#+END_SRC

* Org
** org faces
*** general
#+BEGIN_SRC emacs-lisp :results none
(fset 'orgstyle-tnote
   [?! home ?!])
(define-key org-mode-map (kbd "C-1") 'orgstyle-tnote)


(fset 'orgstyle-warning
   "@\341@WARNING:")
(define-key org-mode-map (kbd "C-2") 'orgstyle-warning)

(fset 'orgstyle-warning2
   [?@ home ?@])
(define-key org-mode-map (kbd "C-S-2") 'orgstyle-warning2)



(fset 'orgstyle-com1
   [?~ home ?~])
(define-key org-mode-map (kbd "C-3") 'orgstyle-com1)

(fset 'orgstyle-note
   "$\341$NOTE:")
(define-key org-mode-map (kbd "C-4") 'orgstyle-note)

(fset 'orgstyle-note2
   [?$ home ?$])
(define-key org-mode-map (kbd "C-S-4") 'orgstyle-note2)

(fset 'orgstyle-tip
   "%\341%TIP:")
(define-key org-mode-map (kbd "C-5") 'orgstyle-tip)


(fset 'orgstyle-tip2
   [?% home ?%])
(define-key org-mode-map (kbd "C-S-5") 'orgstyle-tip2)


(fset 'orgstyle-code
   [?^ home ?^])
(define-key org-mode-map (kbd "C-6") 'orgstyle-code)

(fset 'orgstyle-header
   [?& home ?&])
(define-key org-mode-map (kbd "C-7") 'orgstyle-header)

(fset 'orgstyle-bold
   [?* home ?*])
(define-key org-mode-map (kbd "C-7") 'orgstyle-bold)

(fset 'orgstyle-highlight-green
   [?' home ?'])
(define-key org-mode-map (kbd "C-9") 'orgstyle-highlight-green)

(fset 'orgstyle-com2
   [?` home ?`])
(define-key org-mode-map (kbd "C-0") 'orgstyle-com2)

(fset 'underline_net_delete
   [?\M-% ?\  return return ?!])

#+END_SRC


** Base
*** org base configs
**** define org mode locations for all operations
#+BEGIN_SRC emacs-lisp :results none
(setq org-directory "~/org/files/")
(setq org-default-notes-file "~/org/files/refile.org")
#+END_SRC 
**** main configs
#+BEGIN_SRC emacs-lisp :results none
;associate these files with org

(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))

;make new headings appear after the content for the current one
(setq org-insert-heading-respect-content t)

;allow RETURN to open links
(setq org-return-follows-link nil)
;going to the beginning and end of the heading instead of the current line
(setq org-special-ctrl-a/e t)
;rebind certain one-letter keybindings when the cursor is at the beginning of the row - most notably ‘t’ for org-todo instead of ‘C-c C-t’
(setq org-startup-align-all-tables t)
(setq org-archive-location (concat org-directory "archive/%s_archive::"))
(setq org-attach-store-link-p)
;to make ido mode work in org mode as wel
(setq org-completion-use-ido t)
;allow speedkeys
(setq org-use-speed-commands t)
(setq org-speed-commands-user nil)
 #+END_SRC
*** add time stamp on every org header
    :PROPERTIES:
    :LAST-EDITED: [03-08-2015(20:57)]
    :END:
this will update when the header text will change

#+BEGIN_SRC emacs-lisp
  ;;   (defun update-last-edited (beg end length)
  ;;     (when
  ;;         (and
  ;;          (not (org-before-first-heading-p))
  ;;          (org-get-heading))
  ;;       (org-entry-put nil "LAST-EDITED" (format-time-string "[%d-%m-%Y(%H:%M)]"))))

  ;; (add-hook 'org-mode-hook (lambda ()
  ;; (add-to-list 'after-change-functions 'update-last-edited))) 
#+END_SRC

*** Save all org buffers every hour
    :PROPERTIES:
    :LAST-EDITED: [02-08-2015(21:32)]
    :END:

#+BEGIN_SRC emacs-lisp :results none
(run-at-time "00:59" 3600 'org-save-all-org-buffers)
#+END_SRC 

*** flyspell
#+begin_src emacs-lisp
;enable flyspelll
(add-hook 'org-mode-hook  
          (lambda ()      
            (flyspell-mode)))

;; 2. ignore message flags which can slow org 
(setq flyspell-issue-message-flag nil)

;; ignore tex commands in org 
(add-hook 'org-mode-hook (lambda () (setq ispell-parser 'tex)))
(defun flyspell-ignore-tex ()
  (interactive)
  (set (make-variable-buffer-local 'ispell-parser) 'tex))
(add-hook 'org-mode-hook 'flyspell-ignore-tex)

#+end_src
*** LateX support
CDLaTeX is “is a minor mode that is normally used in combination with a major LaTeX mode like AUCTeX in order to speed-up insertion of environments and math templates”.
the Org manual gives a very easy way to enable it:
#+BEGIN_SRC emacs-lisp :results none
;; enable cdlatex 
;;(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+END_SRC
*** disable linium mode 
#+BEGIN_SRC emacs-lisp :results none
;;disable linemode on org
(defun my-org-mode-hook () 
  (linum-mode 0)) 
(add-hook 'org-mode-hook 'my-org-mode-hook)
#+END_SRC
*** make default notes read-only
#+BEGIN_SRC emacs-lisp :results none
;(add-hook 'org-mode-hook (lambda () (view-mode 1)))
#+END_SRC
*** make org mode read-only after 5 minutes @may cause wierd issues@

@Warning- this may cause strange behviour@

#+begin_src emacs-lisp :results none
  ;; (defvar tj/last-buffer-tick nil)
  ;; (make-variable-buffer-local 'tj/last-buffer-tick)
  
  ;; (defun tj/new-buffer-ticks-p ()
  ;;   (let ((curr-tick (buffer-modified-tick))
  ;;         (last-tick tj/last-buffer-tick))
  ;;     (setq tj/last-buffer-tick curr-tick)
  ;;     (and last-tick (= last-tick curr-tick))))
  
  ;; (defun tj/reset-view-mode ()
  ;;   (run-with-timer 0 (* 5 60)
  ;;                   (lambda ()
  ;;                     (when (tj/new-buffer-ticks-p)
  ;;                       (view-mode t)))))
  
  ;; (add-hook 'org-mode-hook 'tj/reset-view-mode)
#+end_src

*** enable shift selection 

use setq org-support-shift-select:

'always- to always use it
'nil- to disable on org mode
't- for When outside special context

#+BEGIN_SRC emacs-lisp :results none
(setq org-support-shift-select 't)
#+END_SRC

*** Header behavior
#+BEGIN_SRC emacs-lisp :results none
;; when creating new headers make sure there isn't a space
(setq org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))
;;;this will make sure there are no empty lines betwwn headers after collapsing headers 
(setq org-cycle-separator-lines 0) 
#+END_SRC
*** don't let edit invisible areas
#+BEGIN_SRC emacs-lisp  :results none
 ;; don't let me accidentally delete text without realizing it in org.  ie: point is buried in a subtree, but you only
 ;; see the heading and you accidentally kill a line without knowing it.
 ;; this might not be supported for evil-mode
 org-catch-invisible-edits 'show-and-error
#+END_SRC
** custom link types
*** grep link
#+BEGIN_SRC emacs-lisp :results none
(org-add-link-type
 "grep"
 (defun endless/follow-grep-link (regexp)
   "Run `rgrep' with REGEXP as argument."
   (grep-compute-defaults)
   (rgrep regexp "*" (expand-file-name "./"))))
#+END_SRC 
*** dired links
#+BEGIN_SRC emacs-lisp :results none
  (org-add-link-type "file+emacs+dired" 'org-open-file-with-emacs-dired)
  (add-hook 'org-store-link-functions 'org-dired-store-link)

  (defun org-open-file-with-emacs-dired (path)
    "Open in dired."
    (let ((d (file-name-directory path))
          (f (file-name-nondirectory path)))
      (dired d)
      (goto-char (point-min))
      (search-forward f nil t)))

  (defun org-dired-store-link ()
    "Store link to files/directories from dired."
    (require 'dired+)
    (when (eq major-mode 'dired-mode)
      (let ((f (dired-get-filename)))
        (setq link (concat "file+emacs+dired" ":" f)
              desc (concat f " (dired)"))
        (org-add-link-props :link link :description desc)
        link)))
#+end_src

*** org link open with
#+BEGIN_SRC emacs-lisp :results none
(eval-after-load "org"
  (lambda ()
    (if (assoc "\\.avi\\'" org-file-apps)
	(setcdr (assoc "\\.avi\\'" org-file-apps) "vlc %s")
      (add-to-list 'org-file-apps '("\\.avi\\'" . "vlc %s") t))
    (if (assoc "\\.mp4\\'" org-file-apps)
	(setcdr (assoc "\\.mp4\\'" org-file-apps) "vlc %s")
      (add-to-list 'org-file-apps '("\\.mp4\\'" . "vlc %s") t))))

#+END_SRC

*** insert id based links
this will make org-store-link use id when creating a link.
#+BEGIN_SRC emacs-lisp :results none
(require 'org-id)
(setq org-id-link-to-org-use-id t)
;; Use global IDs
;; Update ID file .org-id-locations on startup
(org-id-update-id-locations)
 #+END_SRC

** loading on startup
*** org moduls

#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'org-modules "org-habit")
#+END_SRC

** Agenda
*** set agenda location
#+BEGIN_SRC emacs-lisp :results none
(setq org-agenda-files '("~/org/files/agenda/"))
#+END_SRC
*** TODO agenda popup behivour
#+BEGIN_SRC emacs-lisp :results none
(setq org-agenda-window-setup "current-window")
(setq org-agenda-restore-windows-after-quit t)
#+END_SRC
*** keep refreshing org agenda
#+BEGIN_SRC emacs-lisp  :results none
(run-with-idle-timer 600 t #'org-agenda-redo) ;; to rebuild it every 600 seconds
#+END_SRC
*** agenda view
#+BEGIN_SRC emacs-lisp :results none
;change agenda colors
;(setq org-upcoming-deadline '(:foreground "blue" :weight bold))
;max days to show in agenda view
(setq org-agenda-ndays 7)
;start agenda from today-  don't show listings from earlier in the week
;(setq org-agenda-start-on-weekday nil)
;;;constant agenda start on sunday always (0)
(setq org-agenda-start-on-weekday 0)
;Items that have deadlines are displayed 10 days in advance
(setq org-deadline-warning-days 10)
;don’t display items that are done in my agenda.
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-span 14)

#+END_SRC
*** TODO hydra for better agenda v command
http://oremacs.com/2016/04/04/hydra-doc-syntax/

#+BEGIN_SRC emacs-lisp  :results none
(define-key org-agenda-mode-map
    "v" 'hydra-org-agenda-view/body)

(defun org-agenda-cts ()
  (let ((args (get-text-property
               (min (1- (point-max)) (point))
               'org-last-args)))
    (nth 2 args)))

(defhydra hydra-org-agenda-view (:hint nil)
  "
_d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
_w_: ?w? week       _[_: inactive      _A_: arch-files
_t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
_m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
_y_: ?y? year       _q_: quit          _L__l__c_: ?l?"

  ("SPC" org-agenda-reset-view)
  ("d" org-agenda-day-view
       (if (eq 'day (org-agenda-cts))
           "[x]" "[ ]"))
  ("w" org-agenda-week-view
       (if (eq 'week (org-agenda-cts))
           "[x]" "[ ]"))
  ("t" org-agenda-fortnight-view
       (if (eq 'fortnight (org-agenda-cts))
           "[x]" "[ ]"))
  ("m" org-agenda-month-view
       (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
  ("y" org-agenda-year-view
       (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
  ("l" org-agenda-log-mode
       (format "% -3S" org-agenda-show-log))
  ("L" (org-agenda-log-mode '(4)))
  ("c" (org-agenda-log-mode 'clockcheck))
  ("f" org-agenda-follow-mode
       (format "% -3S" org-agenda-follow-mode))
  ("a" org-agenda-archives-mode)
  ("A" (org-agenda-archives-mode 'files))
  ("r" org-agenda-clockreport-mode
       (format "% -3S" org-agenda-clockreport-mode))
  ("e" org-agenda-entry-text-mode
       (format "% -3S" org-agenda-entry-text-mode))
  ("g" org-agenda-toggle-time-grid
       (format "% -3S" org-agenda-use-time-grid))
  ("D" org-agenda-toggle-diary
       (format "% -3S" org-agenda-include-diary))
  ("!" org-agenda-toggle-deadlines)
  ("["
   (let ((org-agenda-include-inactive-timestamps t))
     (org-agenda-check-type t 'timeline 'agenda)
     (org-agenda-redo)))
  ("q" (message "Abort") :exit t))

#+END_SRC
*** define Israeli weekends
#+BEGIN_SRC emacs-lisp  :results none
(setq org-agenda-weekend-days '(5 6))
#+END_SRC

*** look and feel

#+BEGIN_SRC emacs-lisp :results none
;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)
;; Compact the block agenda view
(setq org-agenda-compact-blocks t)
;; Always hilight the current agenda line
(add-hook 'org-agenda-mode-hook
          '(lambda () (hl-line-mode 1))
          'append)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;;  Enable display of the time grid so we can see the marker for the current time
(setq org-agenda-time-grid (quote ((daily today remove-match)
                                  #("----------------" 0 16 (org-heading t))
                                  (0900 1100 1300 1500 1700))))

;; Display tags farther right
(setq org-agenda-tags-column -102)
#+END_SRC

*** specific sparse trees 
***** breakfeast
#+BEGIN_SRC emacs-lisp :results none
  (defun cooking-sparse-tree-breakfeast ()
    (interactive)
    (org-match-sparse-tree t "+TODO=\"COOK\"+Type=\"breakfest\""))

  (defun cooking-sparse-tree-main ()
    (interactive)
    (org-match-sparse-tree t "+TODO=\"COOK\"+Type=\"main\""))

  (defun cooking-sparse-tree-sweet ()
    (interactive)
    (org-match-sparse-tree t "+TODO=\"COOK\"+Type=\"sweet\""))

  (defun cooking-sparse-tree-meat ()
    (interactive)
    (org-match-sparse-tree t "+TODO=\"COOK\"+Type=\"meat\""))

  (defun cooking-sparse-tree-fav ()
    (interactive)
    (org-match-sparse-tree t "+Fav=\"y\""))

#+end_src

*** export agenda
#+BEGIN_SRC emacs-lisp :results none
          (setq org-agenda-exporter-settings
                '((ps-number-of-columns 2)
                  (ps-landscape-mode t)
                  (org-agenda-add-entry-text-maxlines 5)
                  (htmlize-output-type 'css)))
#+END_SRC
*** habits
#+BEGIN_SRC emacs-lisp :results none
(setq org-habit-graph-column 70)
(setq org-habit-show-habits-only-for-today nil)
#+END_SRC

*** get popups for meetings
#+BEGIN_SRC emacs-lisp
 (appt-activate 1)
 (org-agenda-to-appt)
#+END_SRC

thos  will be reminded of things in your org files, before the appointment time (I think 12 min is the default)
You could also add this, so that the appointments refresh and new get added every time that you call the agenda:

#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-finalize-hook (lambda ()  (org-agenda-to-appt t)))
#+END_SRC
*** Sorting by date and priority

#+BEGIN_SRC emacs-lisp :results none
(setq org-agenda-sorting-strategy
      '((agenda time-up priority-down tag-up effort-up category-keep)
        (todo user-defined-up todo-state-up priority-down effort-up)
        (tags user-defined-up)
        (search category-keep)))
(setq org-agenda-cmp-user-defined 'my/org-sort-agenda-items-user-defined)
(require 'cl)
(defun my/org-get-context (txt)
  "Find the context."
  (car (member-if
        (lambda (item) (string-match "@" item))
        (get-text-property 1 'tags txt))))

(defun my/org-compare-dates (a b)
  "Return 1 if A should go after B, -1 if B should go after A, or 0 if a = b."
  (cond
   ((and (= a 0) (= b 0)) nil)
   ((= a 0) 1)
   ((= b 0) -1)
   ((> a b) 1)
   ((< a b) -1)
   (t nil)))

(defun my/org-complete-cmp (a b)
  (let* ((state-a (or (get-text-property 1 'todo-state a) ""))
         (state-b (or (get-text-property 1 'todo-state b) "")))
    (or
     (if (member state-a org-done-keywords-for-agenda) 1)
     (if (member state-b org-done-keywords-for-agenda) -1))))

(defun my/org-date-cmp (a b)
  (let* ((sched-a (or (get-text-property 1 'org-scheduled a) 0))
         (sched-b (or (get-text-property 1 'org-scheduled b) 0))
         (deadline-a (or (get-text-property 1 'org-deadline a) 0))
         (deadline-b (or (get-text-property 1 'org-deadline b) 0)))
    (or
     (my/org-compare-dates
      (my/org-min-date sched-a deadline-a)
      (my/org-min-date sched-b deadline-b)))))

(defun my/org-min-date (a b)
  "Return the smaller of A or B, except for 0."
  (funcall (if (and (> a 0) (> b 0)) 'min 'max) a b))

(defun my/org-sort-agenda-items-user-defined (a b)
  ;; compare by deadline, then scheduled date; done tasks are listed at the very bottom
  (or
   (my/org-complete-cmp a b)
   (my/org-date-cmp a b)))

(defun my/org-context-cmp (a b)
  "Compare CONTEXT-A and CONTEXT-B."
  (let ((context-a (my/org-get-context a))
        (context-b (my/org-get-context b)))
    (cond
     ((null context-a) +1)
     ((null context-b) -1)
     ((string< context-a context-b) -1)
     ((string< context-b context-a) +1)
     (t nil))))

(defun my/org-sort-agenda-items-todo (a b)
  (or
   (org-cmp-time a b)
   (my/org-complete-cmp a b)
   (my/org-context-cmp a b)
   (my/org-date-cmp a b)
   (org-cmp-todo-state a b)
   (org-cmp-priority a b)
   (org-cmp-effort a b)))
#+END_SRC

*** agenda icons 
this will set icons based on the category
#+BEGIN_EXAMPLE
#+CATEGORY: work
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp  :results none
(setq org-agenda-category-icon-alist '(
                                  ("pc"      "/home/zeltak/MLT/programs/Krusader/Toolbar/refresh.png" nil nil nil nil)
                                  ("work"       "/home/zeltak/MLT/org/bgu.png" nil nil nil nil)
                                  ))
#+END_SRC


** 'my custom agenda command'
   :PROPERTIES:
   :ID:       4b396dfc-0c1c-407c-9d2d-6cca29c8879c
   :END:
look here for more info
http://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html

and here id:cf2c69b4-3d4c-4f81-a01d-bbbe1d120e62

$Note$ that to get the priorities to appear first you need to use priorities-down.

("w" tags-todo "CATEGORY=\"work\"")

(org-agenda-view-columns-initially t)

 will start the view in a column view

also the headers can be customized

(org-columns-default-format "%50ITEM %TODO %3PRIORITY %Effort{:} %TAGS")

-sorting:
(org-agenda-sorting-strategy '(priority-down  tag-up ))

@add@- deadline column , time column to agenda column view

#+BEGIN_SRC emacs-lisp :results none
  (setq org-agenda-custom-commands 
  '(

  ;;TODO sparse tree
  ("O" occur-tree "TODO")


   ("D" "Timeline for today" ((agenda "" ))
             ((org-agenda-ndays 1)
              ;;(org-agenda-show-log t)
             ;; (org-agenda-log-mode-items '(clock closed))
              (org-agenda-entry-types '())))


  ;;;;;ALL

  ;all common tasks (from research|bgu|home files)
  ("p" "all" todo "TODO|BGU|EXP" 
  (
  (org-agenda-files (list "~/org/files/agenda/Research.org"  "~/org/files/agenda/bgu.org" "~/org/files/agenda/home.org" ))
  (org-agenda-sorting-strategy '(priority-down effort-down deadline-up))
   (org-agenda-cmp-user-defined 'my/org-sort-agenda-items-todo)
  (org-columns-default-format "%50ITEM %TODO %10PRIORITY %20DEADLINE %TAGS")
  ))



  ;;;;;;;WORK;;;;;;;;;;;;;;;;;;;;;;

  ;work related only tasks (from research|bgu files)
  ("w" "work" todo "TODO|BGU|EXP" 
  (
  (org-agenda-files (list "~/org/files/agenda/Research.org"  "~/org/files/agenda/bgu.org" ))
  ;(org-agenda-sorting-strategy '(priority-down effort-down))
  (org-agenda-view-columns-initially t)
  ;;(org-agenda-sorting-strategy '(priority-down  tag-up ))

  ))
         
  ;;;;;;;;;;;Allan;;;;;;;;;;;;;;;;;;;;
  ;;custom sparse tree
  ("L" occur-tree "allan")

  ; allan todos
  ("l" "allan tasks" tags-todo "allan"
  (
  (org-agenda-files (list "~/org/files/agenda/Research.org"  "~/org/files/agenda/bgu.org"))
  (org-agenda-sorting-strategy '(priority-down effort-down))
  ))


  ;;;;;;;;;Joel;;;;;;;;;;;;;;;;
  ;; ("j" "joel tasks" tags-todo "joel"
  ;; (
  ;; (org-agenda-files (list "~/org/files/agenda/Research.org"  "~/org/files/agenda/bgu.org"))
  ;; (org-agenda-sorting-strategy '(priority-down effort-down))
  ;; ))

  ;;custom sparse tree
  ;("J" occur-tree "joel")



   ("j" "TODO dowith and TASK with"
           ((org-sec-with-view "TODO dowith")
            (org-sec-where-view "TODO doat")
            (org-sec-assigned-with-view "TASK with")
            (org-sec-stuck-with-view "STUCK with")))


  ;;;;;;;;;;;;;COOKING;;;;;;;;;;;

  ("f" . "Food commands")


  ("fb" "food" todo "COOK" 
           (
      (org-agenda-files '("~/org/files/agenda/food.org")) 
      (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
  ))


  ("fd" "cook dessert" tags-todo "dessert" 
           (
      (org-agenda-files '("~/org/files/agenda/food.org")) 
      (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
  ))


  ("fp" "protein" tags-todo "protein" 
           (
      (org-agenda-files '("~/org/files/agenda/food.org")) 
      (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
  ))

  ("fo" "soup" tags-todo "soup" 
           (
      (org-agenda-files '("~/org/files/agenda/food.org")) 
      (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
  ))


  ("fs" "side" tags-todo "side" 
           (
      (org-agenda-files '("~/org/files/agenda/food.org")) 
      (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
  ))


  ("fb" "breakfest" tags-todo "breakfest" 
           (
      (org-agenda-files '("~/org/files/agenda/food.org")) 
      (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
  ))


  ("fk" "drink" tags-todo "drink" 
           (
      (org-agenda-files '("~/org/files/agenda/food.org")) 
      (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
  ))

  ("fl" "salad" tags-todo "salad" 
           (
      (org-agenda-files '("~/org/files/agenda/food.org")) 
      (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.
  ))




  ;;;;;;;;;;;;;COOKING;;;;;;;;;;;
  ("fc" "to cook"  tags "Cuisine=\"American\""
            (
           (org-agenda-files '("~/org/files/agenda/food.org")) 
      (org-agenda-sorting-strategy '(priority-down)) ;;  Sort by prioirty where prioirty goes first.

  ))




  ;;;;;;;;;;;;;;;;;TECH;;;;;;;;;;;;;;
  ("c" "tech" todo "TODO" 
           (
           (org-agenda-files '("~/org/files/agenda/TODO.org")) 
            (org-agenda-sorting-strategy 
            '(priority-up effort-down)
  )
  )
  )

  ;;;;;;;;;;;;;;;;;HOME;;;;;;;;;;;;;;;;


  ("h" "home" todo "TODO" 
           (
           (org-agenda-files '("~/org/files/agenda/home.org")) 
            (org-agenda-sorting-strategy 
            '(priority-up effort-down)
  )
  )
  )


  ("x" "Agenda and Home-related tasks"
                 (
                 (agenda "")
                 (tags-todo "+PRIORITY=\"A\"")
                 (tags "garden")
  )
  )

 ("z" tags "download" nil)  



  ;;end brackets for setq
  )
  )

#+END_SRC

** Images
*** base
**** inline images by default at startup
#+begin_src emacs-lisp :results none
;;iimage in org (display images in org files)
(setq org-startup-with-inline-images t)
#+end_src
**** size defaults @Warning- this may screw up image config@ 

#+BEGIN_SRC emacs-lisp :results none
;;set the org image default size
;(setq org-image-actual-width nil)
(setq org-image-actual-width '(400))

#+END_SRC
** Tags
*** tag inheritance
make sure child headers don't get the header tags
http://orgmode.org/manual/Tag-inheritance.html

#+BEGIN_SRC emacs-lisp :results none
(setq org-use-tag-inheritance nil)
#+END_SRC

*** tag alist

#+BEGIN_SRC emacs-lisp  :results none
(setq org-tag-persistent-alist  '(
                      ;; where
                      (:startgroup)
                      ("@home" . ?h)
                      ("@work" . ?w)
                      ("@pc" . ?p)
                      ("@family" . ?f)
                      (:endgroup)
(:startgrouptag)
                           ("people")
                           (:grouptags)
                           ("allan" . ?a)
                           ("joel" . ?j)
                           ("david" . ?d)
                           ("meytar" . ?m)
                           ("maayan" . ?y)
                           ("alex" . ?x)
                           ("omer" . ?o)
                           ("adar" . ?a)
                           ("hila" . ?z)
                           ("adi" . ?v)
                           ("boris" . ?b)
                           ("lara" . ?l)
                           ("massimo" . ?s)
                           ("francesca")
                           (:endgrouptag)
))
#+END_SRC


*** TODO org-tag-faces

does not work at all
#+begin_src emacs-lisp results none
(setq org-tag-faces
      '(("@home" . "#f1c40f")
        ("@work" . "#3498db")
        ("allan" . (:foreground "blue" :weight bold))))


;; (setq org-tag-faces
  ;;   '(("Indian" . (:foreground "#00000"))
  ;;      ("Asian"  . (:foreground "#C00000"))
  ;;      ("israeli"  . (:foreground "#C0a000"))))
#+end_src
*** Allow setting single tags without the menu			      
#+BEGIN_SRC emacs-lisp  :results none
;; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))
#+END_SRC

*** tag searches function  
    :PROPERTIES:
    :ID:       c1e25ca7-8cbd-4bd8-b417-3ac09c61474b
    :END:
#+BEGIN_SRC emacs-lisp :results none
(org-add-link-type
 "tag"
 (defun endless/follow-tag-link (tag)
   "Display a list of TODO headlines with tag TAG.
With prefix argument, also display headlines without a TODO keyword."
   (org-tags-view (null current-prefix-arg) tag)))
#+END_SRC
** Todo
*** org todo config
#+BEGIN_SRC emacs-lisp :results none
;allow fast todo
(setq org-use-fast-todo-selection t)
;allow shift-left right to change todo state
(setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC
*** todo keywords
#+begin_src emacs-lisp :results none
(setq org-todo-keywords
      (quote ((sequence "TODO(t)"  "|" "DONE(d)")
              (sequence "TASK(f)" "|" "DONE(d)")
              (sequence "ACTION(a)" "|" "DONE(d)")
)))
(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("TASK" :foreground "magenta" :weight bold)
              ("ACTION" :foreground "Mediumpurple1" :weight bold)
              ("NEXT" :foreground "blue" :weight bold)
              ("PAUSED" :foreground "gray" :weight bold)
              ("SUBMITTED" :foreground "#FFC612" :weight bold)
              ("K_TRACK" :foreground "#45D0FF" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("PUB" :foreground "#00FF37" :weight bold)
              ("PREP" :foreground "#FF7BD0" :weight bold)
              ("SUB" :foreground "#CE008B" :weight bold)
              ("COOK" :background "#0CFB32" :foreground "#001F57" :weight bold)
              ("SHOP" :background "#9CFFBB" :foreground "#004D18" :weight bold)
              )))
#+end_src


*** auto add tags						  :CANCELLED:
#+BEGIN_SRC emacs-lisp :results none
(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
              ("WAITING" ("WAITING" . t))
              ("HOLD" ("WAITING" . t) ("HOLD" . t))
              (done ("WAITING") ("HOLD"))
              ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
              ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
              ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
#+END_SRC
*** priorities
**** TODO This can mess up the sort order in org-agenda-sorting-strategy and thus its commented out
 #+BEGIN_SRC emacs-lisp :results none
   ;; ;;set priority range from A to C with default A
   ;; (setq org-highest-priority ?A)
   ;; (setq org-lowest-priority ?C)
   ;; (setq org-default-priority ?A)

 #+END_SRC
**** colours for priorities
#+BEGIN_SRC emacs-lisp
(setq org-priority-faces '((?A . (:foreground "#F0DFAF" :weight bold))
                           (?B . (:foreground "LightSteelBlue"))
                           (?C . (:foreground "OliveDrab"))))
#+END_SRC
*** archive
#+BEGIN_SRC emacs-lisp  :results none
 ;; Mark entries as done when archiving
          org-archive-mark-done t
#+END_SRC
** Refile
*** set which refile method to us (currently helm)
this command below will use helm for completion since in the above helm config we sepcify these two commands: (require 'helm-config) and (helm-mode 1)
#+BEGIN_SRC emacs-lisp :results none
(setq org-outline-path-complete-in-steps nil)
#+END_SRC
*** settings for paths and headers shown
#+BEGIN_SRC emacs-lisp :results none
;;list everything instead of stepping through each level gradually
(setq org-outline-path-complete-in-steps nil)
;; Refile on top of file max
(setq org-refile-use-outline-path 'file )
#+END_SRC
*** set heading depth
set how many levels of headers to show while refiling 
#+begin_src emacs-lisp results none
; Targets include this file and any file contributing to the agenda - up to 9 levels deep
(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))))
#+end_src

$Note$ that you can also refile per file with specific levels 

#+BEGIN_EXAMPLE

(setq org-refile-targets (quote (("tickler.org" :maxlevel . 1)
                                 ("organizer.org" :level . 1)
                                 ("someday.org" :level . 2))))

#+END_EXAMPLE

here you can  refile to any level 1 headings in the first two files, and any level 2 headings (but not level 1 headings) in the third file.

** Capture
*** load org-protocl and org-capture
#+BEGIN_SRC emacs-lisp :results none
(require 'org-protocol)
(require 'org-capture)
#+END_SRC
*** make org take up 1 frame
    :PROPERTIES:
    :ID:       14e63bf0-0966-4074-98af-bdce51a5f2d4
    :END:
#+BEGIN_SRC emacs-lisp :results none
  ;; (defadvice org-capture (around bp/org-capture--around)
  ;;   (flet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
  ;;     ad-do-it))
  ;; (ad-activate 'org-capture)

#+END_SRC

#+BEGIN_SRC emacs-lisp :results none

  ;; (defadvice org-capture
  ;;     (after make-full-window-frame activate)
  ;;   "Advise capture to be the only window when used as a popup"
  ;;   (if (equal "emacs-capture" (frame-parameter nil 'name))
  ;;       (delete-other-windows)))

  ;; (defadvice org-capture-finalize
  ;;     (after delete-capture-frame activate)
  ;;   "Advise capture-finalize to close the frame"
  ;;   (if (equal "emacs-capture" (frame-parameter nil 'name))
  ;;       (delete-frame)))
#+END_SRC

*** make C-c x close and save frame
#+BEGIN_SRC emacs-lisp :results none
  ;; (defun my-capture-finalize ()
  ;;   (interactive)
  ;;   (org-capture-finalize)
  ;;   (delete-frame))

  ;; (add-hook 'org-capture-mode-hook
  ;;           (lambda ()
  ;;             (define-key org-capture-mode-map "\C-c\C-x" (function my-capture-finalize))))
  ;; ((lambda nil (define-key org-capture-mode-map "" (function my-capture-finalize))))
#+END_SRC
*** org capture frame
http://www.glassberg-powell.com/blog/20140709/emacs-org-mode-capture-anywhere

#+BEGIN_SRC emacs-lisp
(defadvice org-capture-finalize 
  (after delete-capture-frame activate)  
   "Advise capture-finalize to close the frame"  
   (if (equal "capture" (frame-parameter nil 'name))  
       (delete-frame)))

(defadvice org-capture-destroy 
  (after delete-capture-frame activate)  
   "Advise capture-destroy to close the frame"  
   (if (equal "capture" (frame-parameter nil 'name))  
       (delete-frame)))  

(defun make-capture-frame ()
         "Create a new frame and run org-capture."
         (interactive)
         (make-frame '((name . "capture")))
         (select-frame-by-name "capture")
         (delete-other-windows)
         (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
           (org-capture)))
#+END_SRC

#+RESULTS:
: make-capture-frame

** TODO Capture templates
    :PROPERTIES:
    :ID:       2bf19d27-a0af-4e4c-91f1-9723a2dedf18
    :END:
#+BEGIN_SRC emacs-lisp :results none
 (setq org-capture-templates
          (quote ( 

;;;;---------------------------------------------------------------------------
;;; email
;;;;;;;;; this works when in mu4e header view
("e" "Email Todo" entry (file+headline "~/org/files/agenda/bgu.org" "TD")
                            "* TODO Read Message%? (%:fromname about %:subject)\nAdded:%U\n%a\nDEADLINE: %^t")

("E" "Etodo" entry (file+headline "~/org/files/agenda/bgu.org" "TD")
         "* TODO [#A] %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%a\n"
)



;;;;---------------------------------------------------------------------------
;;;; meetings

 ("m" "meeting" entry (file+headline "~/org/files/agenda/meetings.org" "2016")
  "* %?\n%^T" )


  ("M" "recurring" entry (file+headline "~/org/files/agenda/meetings.org" "Recurring")
   "* %?\n%^T" )


;;;;---------------------------------------------------------------------------
;;;; Tech  Todos

  ("x" "nix_TD" entry (file+headline "~/org/files/agenda/TODO.org" "TODO")
   "*  %^{Description}" )

;;;;---------------------------------------------------------------------------
;;;; Home Todos

("h" "Home_TD" entry (file+headline "~/org/files/agenda/home.org" "HomeTD")
   "* TODO  %?\n%T" )

;;;;---------------------------------------------------------------------------
;;; Uni todos

  ("v" "research_TD" entry (file+headline "~/org/files/agenda/research.org" "scheduled mail/calls/meetings")
   "* TODO  %?\n%^T" )
  ;;;BGU todos 
  ("b" "BGU_TD" entry (file+headline "~/org/files/agenda/bgu.org" "TD")
  "* TODO  %?\n%^T" )


;;;;---------------------------------------------------------------------------

  ;; for mail 
  ("r" "respond" entry (file+headline  "~/org/files/agenda/Research.org" "Mails")
   "* TODO Respond to %:from on %:subject\nSCHEDULED: %t\n\n%U\n\n%a\n\n" )

;;;;---------------------------------------------------------------------------

  ;;;;; media related 
  ("d" "Media")

  ("dm" "dl_movie" entry (file+headline "~/org/files/agenda/dl.org" "Movies")
   "*  %^{Description}  " )

  ("dp" "dl_movie_prerelease" entry (file+headline "~/org/files/agenda/dl.org" "Movies")
   "*   %^{Description}   :Pre_Release: " )

  ("dt" "dl_TV" entry (file+headline "~/org/files/agenda/dl.org" "TV")
   "*  %^{Description}" )

  ("ds" "dl_music" entry (file+headline "~/org/files/agenda/dl.org" "Music")
   "*  %^{Description}" )

  ("dc" "dl_comics" entry (file+headline "~/org/files/agenda/dl.org" "comics")
   "*  %^{Description}" )


;;;;---------------------------------------------------------------------------

("c" "Contacts" entry (file "/home/zeltak/org/files/PIM/contacts.org")
               "* %(org-contacts-template-name)
:PROPERTIES:
:EMAIL: %(org-contacts-template-email)
:END:")


;;;;---------------------------------------------------------------------------

("k" "bookmarks" entry
         (file+headline "/home/zeltak/org/files/web/wbookmarks.org" "bookmarks")
         "* %(org-cliplink-capture)  %?\nEntered on %U\n")

("K" "bookmarks" entry
         (file+headline "/home/zeltak/org/files/web/wbookmarks.org" "bookmarks")
         "* %x  %?\nEntered on %U\n")


;;;;---------------------------------------------------------------------------

("s" "Elfeed" entry (file+headline "TODO.org" "Web")
   "*  %:description
    %t
 \nLink: %a\n\n"  :immediate-finish t)

;;;;---------------------------------------------------------------------------

("p" "papers")

;;;; new recipe Inbox working paper
("pp" "new working paper" entry (file+headline "/home/zeltak/org/files/Uni/papers/paper.meta.org" "Kloog working papers")
"* working %^{title}     
    :PROPERTIES:
    :ID: %(org-id-uuid)
    :lead: %^{lead?}
    :END:
"
"Capture Template for new working papers")

;;;; new abstract
("pa" "new abstract" entry (file+headline "/home/zeltak/org/files/Uni/papers/paper.meta.org" "abstracts")
"* working %^{title}     
    :PROPERTIES:
    :ID: %(org-id-uuid)
    :lead: %^{lead?}
    :END:
"
"Capture Template for new abstract")


;;;;---------------------------------------------------------------------------

;;;;; food
;; define food group

("f" "Food")

;;;; new recipe Inbox
("ff" "new recipe" entry (file+headline "/home/zeltak/org/files/agenda/food.org" "Inbox")
"* COOK %^{Recipe Name} %^g     
    :PROPERTIES:
    :ID: %(org-id-uuid)
    :Time: %^{minutes|-|10|15|30|60}
    :Rating: %^{rating?|-|1|2|3|4|5}
    :Source: %^{Source?}
    :Cuisine: %^{Cuisine?|-|Indian|Thai|Vietnamese|Asian|Chinese|Israeli|Italian|American|EastEuro|Mexican|French|Persian|Austrian}
    :Type: %^{Type?|-|ain|side|starter|sweets|drinks|sauce|breakfast}
    :Serves: %^{Type?|-|1|2|4|6|8}
    :Fav: %^{}
    :END:
%^{prompt|** Ingredients}
%?
%^{prompt|** Preparation}
"
"Capture Template for food recipe")



;; add to shopping cart
("fs" "todo_shopping" entry (file+headline "~/org/files/agenda/food.org" "shopping")
"* SHOP %^{Description} " )


;;;;---------------------------------------------------------------------------
;;;; travel  simple template
  ("u" "travel" entry (file+headline "/home/zeltak/org/files/agenda/travel.org" "Inbox")
  "* %^{Description}   
  %u
:PROPERTIES:
    :ID: %(org-id-uuid)
    :Rating: %^{rating?|-|1|2|3|4|5}
    :price: %^{price?|-|1-5|5-10|10-20|20-50|50+}
    :Source: %^{Source?}
    :Cuisine: %^{Cuisine?|-|Indian|Thai|Vietnamese|Asian|Chinese|Israeli|Italian|American|EastEuro|Mexican|French|Persian|Austrian|Jewish|Japan}
    :Fav: %^{}
    :END:

%^{prompt|** My Review}
 %?
   "
    )

;;; non food places

  ("U" "travel-nonfood" entry (file+headline "/home/zeltak/org/files/agenda/travel.org" "Inbox")
  "* %^{Description}   
  %u
:PROPERTIES:
    :ID: %(org-id-uuid)
    :Rating: %^{rating?|-|1|2|3|4|5}
    :price: %^{price?|-|1-5|5-10|10-20|20-50|50+}
    :Source: %^{Source?}
    :Fav: %^{}
    :END:

%^{prompt|** My Review}
 %?
   "
)

("G" "Generic-ask which file" entry (file+headline (expand-file-name (read-string "Name of file: ")) "Generic")
                 "|%f| %U|%A|" :prepend t)

 ("j" "journal" entry
   (file+datetree+prompt "/home/zeltak/ZH_tmp/XDsettings.org")
   "* %(format-time-string \"%H:%M\") %^{Entry} %^G\n%i%?")


     )))
 #+END_SRC


** mobile org
*** setup
#+begin_src emacs-lisp :results none
;;For agenda files locations, each location you add within " "
(require 'org-mobile)
(setq org-mobile-directory "~/Dropbox/MobileOrg/")
;; Set to the name of the file where new captures will be stored after pulling from mobile
(setq org-mobile-inbox-for-pull "~/org/files/from-mobile.org")

#+end_src

*** auto sync
**** (old, keep around since thid DOES work)
#+BEGIN_SRC emacs-lisp :results none
  ;; (defvar org-mobile-push-timer nil
  ;;   "Timer that `org-mobile-push-timer' used to reschedule itself, or nil.")

  ;; (defun org-mobile-push-with-delay (secs)
  ;;   (when org-mobile-push-timer
  ;;     (cancel-timer org-mobile-push-timer))
  ;;   (setq org-mobile-push-timer
  ;;         (run-with-idle-timer
  ;;          (* 1 secs) nil 'org-mobile-push)))

  ;; (add-hook 'after-save-hook 
  ;;  (lambda () 
  ;;    (when (eq major-mode 'org-mode)
  ;;      (dolist (file (org-mobile-files-alist))
  ;;       (if (string= (file-truename (expand-file-name (car file)))
  ;;                    (file-truename (buffer-file-name)))
  ;;            (org-mobile-push-with-delay 30)))
  ;;    )))

  ;; (run-at-time "00:05" 86400 '(lambda () (org-mobile-push-with-delay 1))) ;; refreshes agenda file each day

#+END_SRC

**** auto push
#+BEGIN_SRC emacs-lisp :results none
  ;; ;; Fork the work (async) of pushing to mobile
  ;; ;; https://gist.github.com/3111823 ASYNC org mobile push...
  ;; (require 'gnus-async) 
  ;; ;; Define a timer variable
  ;; (defvar org-mobile-push-timer nil
  ;;   "Timer that `org-mobile-push-timer' used to reschedule itself, or nil.")
  ;; ;; Push to mobile when the idle timer runs out
  ;; (defun org-mobile-push-with-delay (secs)
  ;;    (when org-mobile-push-timer
  ;;     (cancel-timer org-mobile-push-timer))
  ;;   (setq org-mobile-push-timer
  ;;         (run-with-idle-timer
  ;;          (* 1 secs) nil 'org-mobile-push)))
  ;; ;; After saving files, start an idle timer after which we are going to push 
  ;; (add-hook 'after-save-hook 
  ;;  (lambda () 
  ;;    (if (or (eq major-mode 'org-mode) (eq major-mode 'org-agenda-mode))
  ;;      (dolist (file (org-mobile-files-alist))
  ;;        (if (string= (expand-file-name (car file)) (buffer-file-name))
  ;;            (org-mobile-push-with-delay 10)))
  ;;      )))
  ;; ;; Run after midnight each day (or each morning upon wakeup?).
  ;; (run-at-time "00:01" 86400 '(lambda () (org-mobile-push-with-delay 1)))
  ;; ;; Run 1 minute after launch, and once a day after that.
  ;; (run-at-time "1 min" 86400 '(lambda () (org-mobile-push-with-delay 1)))
#+END_SRC
**** auto pull
#+BEGIN_SRC emacs-lisp :results none
  ;; ;; watch mobileorg.org for changes, and then call org-mobile-pull
  ;; ;; http://stackoverflow.com/questions/3456782/emacs-lisp-how-to-monitor-changes-of-a-file-directory
  ;; (defun install-monitor (file secs)
  ;;   (run-with-timer
  ;;    0 secs
  ;;    (lambda (f p)
  ;;      (unless (< p (second (time-since (elt (file-attributes f) 5))))
  ;;        (org-mobile-pull)))
  ;;    file secs))
  ;; (defvar monitor-timer (install-monitor (concat org-mobile-directory "/mobileorg.org") 30)
  ;;   "Check if file changed every 30 s.")
#+END_SRC

** Babel
*** languages
#+BEGIN_SRC emacs-lisp :results none
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (sh . t)
   (matlab . t)
   (sqlite . t)
   (ruby . t)
   (perl . t)
   (org . t)
   (dot . t)
   (gnuplot . t)
   (octave .t)
   (plantuml . t)
   (R . t)
   ))
#+END_SRC
    
*** disable confirm for these languages
#+BEGIN_SRC emacs-lisp :results none
  ;; (defun my-org-confirm-babel-evaluate (lang body)
  ;;     (not (string= lang "emacs-lisp")))  ; don't ask for lisp
  ;; (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+END_SRC
*** enable prompt-free code running
#+BEGIN_SRC emacs-lisp :results none
;; enable prompt-free code running
(setq org-confirm-babel-evaluate nil        ;; for running code blocks
      org-confirm-elisp-link-function nil   ;; for elisp links
      org-confirm-shell-link-function nil)  ;; for shell links 
#+END_SRC
*** done eval when exporting code
#+BEGIN_SRC emacs-lisp :results none
(setq org-export-babel-evaluate nil)
#+END_SRC
*** Fonts
#+BEGIN_SRC emacs-lisp :results none
;; fontify code in code blocks
(setq org-src-fontify-natively t)
#+END_SRC 
** font locks
 

#+BEGIN_SRC emacs-lisp :results none
;warning
(font-lock-add-keywords
 'org-mode
'(("\\(@[^@\n]+@\\)" (0 '(:foreground "#B40000" :background "#FFDDDD" :weight bold) t))))

;tip
(font-lock-add-keywords
 'org-mode
'(("\\(%[^%\n]+%\\)" (0 '(:weight ultra-bold :background "#DDFFDD" :foreground "#000000") t))))

;notice
(font-lock-add-keywords
 'org-mode
'(("\\(![^!\n]+!\\)" (0 '(:weight ultra-bold :foreground "#B40000") t))))

;high-green
(font-lock-add-keywords
 'org-mode
'(("\\('[^'\n]+'\\)" (0 '(:background "#35FF00" :weight ultra-bold) t))))

;high-yellow
(font-lock-add-keywords
 'org-mode
'(("\\(`[^`\n]+`\\)" (0 '(:foreground "#000000" :weight ultra-bold :background "#FBFF00") t))))

;
(font-lock-add-keywords
 'org-mode
'(("\\(₆[^₆\n]+₆\\)" (0 '(:foreground "#000000" :underline t :background "#FF9AEA" :weight ultra-bold) t))))

;
(font-lock-add-keywords
 'org-mode
'(("\\(₅[^₅\n]+₅\\)" (0 '(:weight ultra-bold :foreground "#1E00DE") t))))


;
(font-lock-add-keywords
 'org-mode
'(("\\(₄[^₄\n]+₄\\)" (0 '(:weight ultra-bold :foreground "#FF9800") t))))

;blusish
(font-lock-add-keywords
 'org-mode
'(("\\(•[^•\n]•+\\)" (0 '(:weight ultra-bold :foreground "#393D900") t))))


 
;;;;SPECIFIC WORDS 

;server
(font-lock-add-keywords
'org-mode
'(("\\b[Ss]erver\\b" (0 '(:weight ultra-bold :foreground "#FF9800") t))))

;client
(font-lock-add-keywords
'org-mode
'(("\\b[Cc]lient\\b" (0 '(:weight ultra-bold :foreground "#0044FF") t))))

;private
(font-lock-add-keywords
'org-mode
'(("\\b[Pp]rivate\\b" (0 '(:weight ultra-bold :foreground "#FF6767") t))))

;public
(font-lock-add-keywords
'org-mode
'(("\\b[Pp]ublic\\b" (0 '(:weight ultra-bold :foreground "#59BD7E") t))))


;In Example
(font-lock-add-keywords
'org-mode
'(("\\b[Ii]n example\\b" (0 '(:foreground "#000000" :underline t :background "#FF9AEA" :weight ultra-bold) t))))


;header
(font-lock-add-keywords
 'org-mode
'(("\\(‡[^‡\n]+‡\\)" (0 '(:foreground "#ffffff" :weight ultra-bold :slant italic :background "#59BD7F" :height 1.3) t))))

;;;FOR SPECIAL CHARACTERS

;for key shortucts
(font-lock-add-keywords
 'org-mode
'(("\\(\\?[^?\n]+\\?\\)" (0 '(:foreground "#000000" :weight ultra-bold :background "#FF9C2C") t))))

;for $Note$ 
(font-lock-add-keywords
 'org-mode
'(("\\(\\$[^$\n]+\\$\\)" (0 '(:background "#DDDDFF" :foreground "#000000" :weight ultra-bold) t))))

;for ^
(font-lock-add-keywords
 'org-mode
'(("\\(\\^[^^\n]+\\^\\)" (0 '(:weight bold  :box (:line-width 1 :color "#A5A0FF")  :foreground "#00006F" :background "#FFFFFF") t))))

;for † 
(font-lock-add-keywords
 'org-mode
'(("\\(\\†[^†\n]+\\†\\)" (0 '(:weight bold  :box (:line-width 1 :color "#A5A0FF")  :foreground "#00006F" :background "#FFFFFF") t))))

#+END_SRC

The following characters are special : . * + ? ^ $ \ [

more characters :
http://en.wikipedia.org/wiki/List_of_Unicode_characters
#+BEGIN_EXAMPLE
†•‖‣․‥ 	… ⁅⁆	⁑⁒⁓⁔⁕⁖⁗⁘⁙⁚⁛⁜⁝₀ 	₁₂₃₄	₅₆₇₈₉ ₊ ₋ ₌
#+END_EXAMPLE

** look and feel
*** allow font lock
#+BEGIN_SRC emacs-lisp  :results none
(setq org-src-fontify-natively t);; syntax highlighting the source code
#+END_SRC
you can no longer color the backgrounds and get fontification. You can choose one or the other. I decided I'd rather have the backgrounds:
(setq org-src-fontify-natively nil)
and then you can set the org-block, org-block-begin-line, org-block-end-line faces. I use a color scheme similar to the one you linked to, but I made mine a little less bold:
org-block: foreground #00007f background #f8f8eb height 0.9
org-block-begin-line, org-block-end-line: foreground #545454 background #e0dfd1

*** make code blocks look better
#+BEGIN_SRC emacs-lisp :results none
;    (defun prettier-org-code-blocks ()
;      (interactive)
;      (font-lock-add-keywords nil
;        '(("\\(\+begin_src\\)"
;           (0 (progn (compose-region (match-beginning 1) (match-end 1) ?¦)
;                     nil)))
;          ("\\(\+end_src\\)"
;           (0 (progn (compose-region (match-beginning 1) (match-end 1) ?¦)
;                     nil))))))
;    (add-hook 'org-mode-hook 'prettier-org-code-blocks)
#+END_SRC
*** TODO Changing the org-mode ellipsis
#+BEGIN_SRC emacs-lisp :results none
(setq org-ellipsis "⤵")
#+END_SRC
Other interesting characters are ↴, ⬎, ⤷, and ⋱.

** Export/publishing
*** export in background
@this casues org-reveal to spit an error@
#+BEGIN_SRC emacs-lisp :results none
;(setq org-export-in-background t)
#+END_SRC
*** extra exporters; ODT, beamer etc  exporters
**** add (require) specific models. 
#+BEGIN_SRC emacs-lisp :results none
(require 'ox-odt)
(require 'ox-beamer)
(require 'ox-latex)

#+END_SRC
**** odt defaule export format 
#+BEGIN_SRC emacs-lisp  :results none
;; org v8 bundled with Emacs 24.4
(setq org-odt-preferred-output-format "docx")
;; BTW, you can assign "pdf" in above variables if you prefer PDF format

#+END_SRC
**** koma
http://orgmode.org/worg/exporters/koma-letter-export.html
***** load koma

#+BEGIN_SRC emacs-lisp :results none
(eval-after-load 'ox '(require 'ox-koma-letter))

(eval-after-load 'ox-latex
  '(add-to-list 'org-latex-packages-alist '("AUTO" "babel" t) t))

#+END_SRC
***** define letter-class-definition
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'org-latex-classes
             '("my-letter"
               "\\documentclass\{scrlttr2\}
\\usepackage[english]{babel}
\[NO-DEFAULT-PACKAGES]
\[NO-PACKAGES]
\[EXTRA]"))
#+END_SRC
*** export locations for publishing 
#+BEGIN_SRC emacs-lisp :results none
     (setq org-publish-project-alist
           '(
              ("Help_files"
              :base-directory "~/org/files/help/"
              :publishing-directory "~/org/files/export/"
              :section-numbers nil
              :table-of-contents nil
              :publishing-function org-ascii-publish-to-ascii)

              ("econf"
              :base-directory "~/org/files/agenda/"
              :publishing-directory "~/org/files/export/"
              :section-numbers nil
              :table-of-contents nil
              :publishing-function org-html-publish-to-html)

	      ("qgis"
           ;; Directory for source files in org format
              :base-directory "/home/zeltak/org/files/Uni/Courses/BGU.Qgis/"
              :base-extension "org"
              :publishing-directory "/home/zeltak/org/files/Uni/Courses/BGU.Qgis/"
              :publishing-function org-reveal-export-to-html)


))
#+END_SRC
*** visual option 
**** remove the “Validate XHTML 1.0” message from HTML export
#+BEGIN_SRC emacs-lisp :results none
(setq org-export-html-validation-link nil)
#+END_SRC
**** disregard _ as subscript
#+BEGIN_SRC emacs-lisp :results none
org-use-sub-superscripts nil        ;; don't use `_' for subscript
#+END_SRC

** org attach
#+BEGIN_SRC emacs-lisp :results none
(setq org-attach-directory "/home/zeltak/org/attach/files_2015/")
#+END_SRC
** org functions 
*** convert to same level header
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-convert-header-samelevel  ()
                     (interactive)                                
                     (let ((current-prefix-arg '(4)))             
                       (call-interactively #'org-toggle-heading)))

#+END_SRC

*** tangle only code block at point 
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-tangle-atpoint  ()
                     (interactive)                                
                     (let ((current-prefix-arg '(4)))             
                       (call-interactively #'org-babel-tangle)))

#+END_SRC

*** agenda views
**** org agenda calendar
  
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-calendar ()
"open work agenda"
(interactive)                                
(org-agenda nil "a")
)
#+END_SRC

**** org agenda work 

#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-work ()
"open work agenda"
(interactive)                                
(org-agenda nil "w")
)
#+END_SRC

**** org agenda search
**** org agenda Allan
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-allan ()
"open work agenda"
(interactive)                                
(org-agenda nil "l")
)
#+END_SRC

**** org agenda Joel
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-joel ()
"open work agenda"
(interactive)                                
(org-agenda nil "j")
)
#+END_SRC
**** org agenda cook
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-cook ()
"open work agenda"
(interactive)                                
(org-agenda nil "f")
)
#+END_SRC

**** TODO org export to pdf
#+BEGIN_SRC emacs-lisp :results none
(fset 'expdf
      [?\C-c ?\C-e ?\l ?\o ])
#+END_SRC

**** TODO org TODO spares tree
add all todo states to sparse tree
#+begin_src emacs-lisp
  (defun z/org-sparse-todo ()
    "all todo sparse"
    (interactive)
    (org-match-sparse-tree t )
)
#+end_src


**** org agenda search
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-search()
""
(interactive)                                
(org-agenda nil "s")
)
#+END_SRC
**** org agenda search todo
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-agenda-search-todo ()
""
(interactive)                                
(org-agenda nil "S")
)
#+END_SRC
*** capture 
**** capture meeting
     :PROPERTIES:
     :ID:       55985af9-201d-4cd7-bb97-b3adc14ac2f8
     :END:
#+BEGIN_SRC emacs-lisp  :results none
(defun z/org-capture-meeting ()
"open work agenda"
(interactive)                                
(org-capture nil "m")
)
#+END_SRC
*** Links
**** link to file
 #+BEGIN_SRC emacs-lisp :results none
 (defun z/org-link-file  ()
                      (interactive)                                
                      (let ((current-prefix-arg '(4)))             
			(call-interactively #'org-insert-link)))

 #+END_SRC
**** TODO link to any header
     :PROPERTIES:
     :ID:       b9436f8a-478b-4f98-8bc8-65697ffb8c78
     :END:
 First we define the base function

 #+BEGIN_SRC emacs-lisp
 (defun insert-heading-link (dir)
   "select a headline from org-files in dir and insert a link to it."
   (interactive  (list (read-directory-name "Directory: ")))
   (let ((org-agenda-files (f-entries
                            dir
                            (lambda (f)
                              (string=
                               "org"
                               (file-name-extension f)))
                            t)))
     (helm-org-agenda-files-headings)))
 #+END_SRC

 gives helm buffer to select headlines from org-files in the directory I select and when I press f3 (for the third action), it inserts a link to the selected headline. 
 It does the file finding recursively, so big folders can be slow

 to add the org id component to the above script eval this as well

 #+BEGIN_SRC emacs-lisp
 (defun helm-org-insert-id-link-to-heading-at-marker (marker)
   (with-current-buffer (marker-buffer marker)
     (let ((file-name (buffer-file-name))
           (id (save-excursion (goto-char (marker-position marker))
                               (org-id-get-create)
                               (org-id-store-link))))

       (with-helm-current-buffer
         (org-insert-link
          file-name id)))))


 (cl-defun helm-source-org-headings-for-files (filenames
                                               &optional (min-depth 1) (max-depth 8))
   (helm-build-sync-source "Org Headings"
     :candidates (helm-org-get-candidates filenames min-depth max-depth)
     :action '(("Go to line" . helm-org-goto-marker)
               ("Refile to this heading" . helm-org-heading-refile)
               ("Insert link to this heading"
		. helm-org-insert-link-to-heading-at-marker)
               ("Insert id link to this heading" .
		helm-org-insert-id-link-to-heading-at-marker))))

 #+END_SRC
**** paste file:/ link
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-link-paste-file-path ()
   "paste file path in killring"
  (interactive)
  (insert "file:")
  (yank)
  )
#+END_SRC

*** terminal
**** org evaluate to term

 #+begin_src emacs-lisp
 (defadvice org-babel-execute:sh (around sacha activate)
   (if (assoc-default :term (ad-get-arg 1) nil)
     (let ((buffer (make-term "babel" "/bin/zsh")))
       (with-current-buffer buffer
	 (insert (org-babel-expand-body:generic
	      body params (org-babel-variable-assignments:sh params)))
	 (term-send-input))
 (pop-to-buffer buffer))
     ad-do-it))
 #+end_src

*** editing
**** Insert current time stamp

#+BEGIN_SRC emacs-lisp :results none
(defun org-timestamp-now ()
  "Inserts org timestamp at end of heading"
  (interactive)
  (save-excursion
    (org-back-to-heading)
    (org-end-of-line nil)
    (insert " ")
    (org-insert-time-stamp nil nil t nil nil nil)))
#+END_SRC

**** Insert time stamp selector 

#+BEGIN_SRC emacs-lisp :results none
(defun org-timestamp-select ()
  "Inserts org timestamp at end of heading"
  (interactive)
  (save-excursion
    (org-back-to-heading)
    (org-end-of-line nil)
    (org-time-stamp-inactive nil)))

#+END_SRC
**** import ods file into org table
#+BEGIN_SRC emacs-lisp :results none
(defun org-table-import-ods (&optional file-name)
(interactive "fFile: ")
(let ((csv-file (org-odt-convert file-name "csv"))
(pos (point)))
(save-excursion
(insert (with-temp-buffer
(insert-file-contents csv-file)
(org-table-convert-region (point-min) (point-max) '(4))
(buffer-string))))))
#+END_SRC
**** convert lines to checkboxes
 
#+BEGIN_SRC emacs-lisp :results none
(defun org-set-line-checkbox (arg)
  (interactive "P")
  (let ((n (or arg 1)))
    (when (region-active-p)
      (setq n (count-lines (region-beginning)
                           (region-end)))
      (goto-char (region-beginning)))
    (dotimes (i n)
      (beginning-of-line)
      (insert "- [ ] ")
      (forward-line))
    (beginning-of-line)))
#+END_SRC
    
**** convert lines to headline
 
#+BEGIN_SRC emacs-lisp :results none
(defun org-set-line-headline (arg)
  (interactive "P")
  (let ((n (or arg 1)))
    (when (region-active-p)
      (setq n (count-lines (region-beginning)
                           (region-end)))
      (goto-char (region-beginning)))
    (dotimes (i n)
      (beginning-of-line)
      (insert "** TODO ")
      (forward-line))
    (beginning-of-line)))
#+END_SRC
    
**** read only function
Make some org-sections read-only

$Note- you !MUST! tag the header :read_only: other wise it wont work$ 

#+BEGIN_SRC emacs-lisp :results none
(defun org-mark-readonly ()
(interactive)
(org-map-entries
(lambda ()
(let* ((element (org-element-at-point))
(begin (org-element-property :begin element))
(end (org-element-property :end element)))
(add-text-properties begin (- end 1) '(read-only t
font-lock-face '(:background "#FFE3E3")))))
"read_only")
(message "Made readonly!"))
(defun org-remove-readonly ()
(interactive)
(org-map-entries
(lambda ()
(let* ((element (org-element-at-point))
(begin (org-element-property :begin element))
(end (org-element-property :end element))
(inhibit-read-only t))
(remove-text-properties begin (- end 1) '(read-only t font-lock-face '(:background "yellow")))))
"read_only"))
(add-hook 'org-mode-hook 'org-mark-readonly)
#+END_SRC

*** TODO code blocks
**** comment inside org code block 
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-comment ()    
(interactive)
(org-edit-special)
(mark-whole-buffer)
(comment-dwim nil)
(org-edit-src-exit))

#+END_SRC
**** TODO paste code block
***** z/org-cblock-paste-lisp
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-lisp ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_SRC emacs-lisp  :results none\n")
  (yank)
  (insert "\n#+END_SRC"))
#+END_SRC
***** z/org-cblock-paste-sh
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-sh ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_SRC sh  :results none\n")
  (yank)
  (insert "\n#+END_SRC"))
#+END_SRC
***** z/org-cblock-paste-EXAMPLE
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-example ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_EXAMPLE\n")
  (yank)
  (insert "\n#+END_EXAMPLE"))
#+END_SRC
***** z/org-cblock-paste-R
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-R ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_SRC R :session Rorg  :results none\n")
  (yank)
  (insert "\n#+END_SRC"))
#+END_SRC
***** z/org-cblock-paste-SAS
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-SAS ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_SRC SAS\n")
  (yank)
  (insert "\n#+END_SRC"))
#+END_SRC
***** z/org-cblock-paste-QUOTE
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-paste-QUOTE ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_QUOTE\n")
  (yank)
  (insert "\n#+END_QUOTE"))
#+END_SRC
**** interactive wrap
***** z/org-cblock-iwrap-emacs-lisp
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-iwrap-emacs-lisp (&optional lang lines)
  "Wrap sexp-at-point or region in src-block.
Use Org-Babel LANGuage for the src-block if given, Emacs-Lisp
otherwise. A region instead of the sexp-at-point is wrapped if
either
   - optional argument LINES is an (positive or negative) integer
   - or the region is active
In the first case the region is determined by moving +/- LINES
forward/backward from point using `forward-line', in the second
case the active region is used.
When called with prefix argument 'C-u', prompt the user for the
Org-Babel language to use. When called with two prefix arguments
'C-u C-u', prompt the user for both the Org-Babel language to use
and the number of lines to be wrapped."
  (interactive
   (cond
    ((equal current-prefix-arg nil) nil)
    ((equal current-prefix-arg '(4))
     (list
      (ido-completing-read "Org-Babel language: "
                           (mapcar
                            (lambda (--lang)
                              (symbol-name (car --lang)))
                            org-babel-load-languages)
                           nil nil nil nil "emacs-lisp")))
    ((equal current-prefix-arg '(16))
     (list
      (ido-completing-read "Org-Babel language: "
                           (mapcar
                            (lambda (--lang)
                              (symbol-name (car --lang)))
                            org-babel-load-languages)
                           nil nil nil nil "emacs-lisp")
      (read-number "Number of lines to wrap: " 1)))))
  (let* ((language (or lang "emacs-lisp"))
         (beg (or (and (not lines)
		       (region-active-p)
		       (region-beginning))
                  (point)))
         (marker (save-excursion (goto-char beg) (point-marker)))
         (bol (save-excursion (goto-char beg) (bolp)))
         (end (cond
	       (lines (save-excursion
                        (forward-line lines) (point)))
	       ((region-active-p)(region-end))
	       (t (save-excursion
                    (forward-sexp) (point)))))
         (cut-strg (buffer-substring beg end)))
    (delete-region beg end)
    (goto-char (marker-position marker))
    (insert
     (format
      "%s#+begin_src %s\n%s%s#+end_src\n"
      (if (or (and lines (< lines 0)) bol) "" "\n")
      language
      cut-strg
      (if lines "" "\n")))
    (set-marker marker nil)))
#+end_src
***** z/org-cblock-iwrap-ASK 
 #+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-iwrap-ASK ()
(interactive)
(let ((current-prefix-arg '(4)))
(call-interactively
'z/org-cblock-iwrap-emacs-lisp)))
 #+END_SRC
***** z/org-cblock-iwrap-ASK-LINE 
 #+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-iwrap-ASK-LINE ()
(interactive)
(let ((current-prefix-arg '(4)))
(call-interactively
'z/org-cblock-iwrap-emacs-lisp)))
 #+END_SRC
***** z/org-cblock-iwrap-R
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-iwrap-R ()
(interactive)
(z/org-cblock-iwrap-emacs-lisp  "R" ))
#+end_src
***** z/org-cblock-iwrap-sh
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-cblock-iwrap-sh ()
(interactive)
(z/org-cblock-iwrap-emacs-lisp  "sh" ))
#+end_src

***** z/org-cblock-nowrap-EXAMPLE
#+BEGIN_SRC emacs-lisp  :results none
(defun  z/org-cblock-nowrap-example ()
   "paste in already quote block"
  (interactive)
  (insert "#+BEGIN_EXAMPLE\n")
  (insert "\n#+END_EXAMPLE"))
#+END_SRC
**** menu for wrapping 
#+BEGIN_SRC emacs-lisp :results none
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; function to wrap blocks of text in org templates                       ;;
;; e.g. latex or src etc                                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun z/org-cblock-iwrap-menu ()
  "Make a template at point."
  (interactive)
  (if (org-at-table-p)
      (call-interactively 'org-table-rotate-recalc-marks)
    (let* ((choices '(("s" . "SRC")
                      ("e" . "EXAMPLE")
                      ("q" . "QUOTE")
                      ("v" . "VERSE")
                      ("c" . "CENTER")
                      ("l" . "LaTeX")
                      ("h" . "HTML")
                      ("r" . "R")
                      ("a" . "ASCII")))
           (key
            (key-description
             (vector
              (read-key
               (concat (propertize "Template type: " 'face 'minibuffer-prompt)
                       (mapconcat (lambda (choice)
                                    (concat (propertize (car choice) 'face 'font-lock-type-face)
                                            ": "
                                            (cdr choice)))
                                  choices
                                  ", ")))))))
      (let ((result (assoc key choices)))
        (when result
          (let ((choice (cdr result)))
            (cond
             ((region-active-p)
              (let ((start (region-beginning))
                    (end (region-end)))
                (goto-char end)
                (insert "#+END_" choice "\n")
                (goto-char start)
                (insert "#+BEGIN_" choice "\n")))
             (t
              (insert "#+BEGIN_" choice "\n")
              (save-excursion (insert "#+END_" choice))))))))))

#+END_SRC
*** food 	
**** inbox Recipe Template
based on the following blog post:
http://lebensverrueckt.haktar.org/articles/org-mode-Food/#comment-1348609811

#+BEGIN_SRC emacs-lisp :results none
(defun recipe-template ()
        (interactive)
        (goto-line 0)
        (search-forward "* Inbox")
         (org-meta-return)
         (org-metaright)
         (setq recipe-name (read-string "Title: "))
         (insert recipe-name)
         (org-todo "COOK") 
         (org-set-tags)
         (org-meta-return)
         (org-metaright)
         (insert "Ingridients")
         (org-meta-return)
         (insert "Preperation")
         (search-backward recipe-name)
         (setq src1 (read-string "Time: "))
         (org-set-property "Time" src1)
         (setq src2 (read-string "Rating: "))
         (org-set-property "Rating" src2)
         (setq src3 (read-string "Sources: "))
         (org-set-property "Source" src3)
         (setq src4 (read-string "Ammount: "))
         (org-set-property "Ammount" src4)
         (setq src5 (read-string "Fav: "))
         (org-set-property "Fav" src5)
         (search-forward "Ingridients")
         (evil-open-below 1)
         (beginning-of-visual-line)
)
#+END_SRC
**** ADD Recipe Template

#+BEGIN_SRC emacs-lisp :results none
(defun blank-recipe-template ()
        (interactive)
         (org-meta-return)
         (org-metaright)
         (setq recipe-name (read-string "Title: "))
         (insert recipe-name)
         (org-set-tags)
         (org-meta-return)
         (org-metaright)
         (insert "Ingridients")
         (org-meta-return)
         (insert "Preperation")
         (search-backward recipe-name)
         (setq src1 (read-string "Time: "))
         (org-set-property "Time" src1)
         (setq src2 (read-string "Rating: "))
         (org-set-property "Rating" src2)
         (setq src3 (read-string "Sources: "))
         (org-set-property "Source" src3)
         (setq src4 (read-string "Ammount: "))
         (org-set-property "Ammount" src4)
         (setq src5 (read-string "Fav: "))
         (org-set-property "Fav" src5)
         (search-forward "Ingridients")
         (evil-open-below 1)
         (beginning-of-visual-line)
)
#+END_SRC
**** add Travel Template

#+BEGIN_SRC emacs-lisp :results none
(defun travel-template ()
        (interactive)
        (goto-line 0)
        (search-forward "* Inbox")
         (org-meta-return)
         (org-metaright)
         (setq travel-name (read-string "Title: "))
         (insert travel-name)
         (org-set-tags)
         (org-meta-return)
         (org-metaright)
         (insert "Details")
         (org-meta-return)
         (search-backward travel-name)
         (setq src1 (read-string "Rating: "))
         (org-set-property "Rating" src1)
         (setq src2 (read-string "Sources: "))
         (org-set-property "Source" src2)
         (setq src3 (read-string "Fav: "))
         (org-set-property "Fav" src3)
         (search-forward "Details")
         (evil-open-below 1)
)
#+END_SRC

*** email org headers
**** send header via Email 		 

 #+BEGIN_SRC emacs-lisp :results none
   (defun z/org-email-heading ()
     "Send the current org-mode heading as the body of an email, with headline as the subject.
   use these properties
   TO
   CC
   BCC
   OTHER-HEADERS is an alist specifying additional
   header fields.  Elements look like (HEADER . VALUE) where both
   HEADER and VALUE are strings.
   Save when it was sent as a SENT property. this is overwritten on
   subsequent sends."
     (interactive)
     ; store location.
     (setq *email-heading-point* (set-marker (make-marker) (point)))
     (save-excursion
       (org-mark-subtree)
       (let ((content (buffer-substring (point) (mark)))
             (TO (org-entry-get (point) "TO" t))
             (SUBJECT (nth 4 (org-heading-components)))
             (OTHER-HEADERS (eval (org-entry-get (point) "OTHER-HEADERS")))
             (continue nil)
             (switch-function nil)
             (yank-action nil)
             (send-actions '((email-send-action . nil)))
             (return-action '(email-heading-return)))
        
         (compose-mail TO SUBJECT OTHER-HEADERS continue switch-function yank-action send-actions return-action)
         (message-goto-body)
         (insert content)
         (when CC
           (message-goto-cc)
           (insert CC))
         (when BCC
           (message-goto-bcc)
           (insert BCC))
         (if TO
             (message-goto-body)
           (message-goto-to)))))

 #+END_SRC
**** Send email to myself
 #+BEGIN_SRC emacs-lisp
 (defun z/org-email-heading-me ()
   "Send the current org-mode heading as the body of an email, with headline as the subject."
   (interactive)
   (save-excursion
     (org-mark-subtree)
     (let ((content (buffer-substring (point) (mark)))
           (SUBJECT (nth 4 (org-heading-components))))

       (compose-mail "ikloog@gmail.com" SUBJECT)
       (message-goto-body)
       (insert content)
       (message-send)
       (message-kill-buffer))))
 #+END_SRC
*** exporting
**** export to reveal and browse
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-export-revel-browse ()
"export to org reveal"
(interactive)                                
(org-reveal-export-to-html-and-browse)
)
#+END_SRC
**** export to reveal html  file
 #+BEGIN_SRC emacs-lisp :results none
 (defun z/org-export-revel-html ()
 "export to org reveal"
 (interactive)                                
 (org-reveal-export-to-html)
 )
 #+END_SRC
**** export subtree to file
 #+BEGIN_SRC emacs-lisp :results none
 (defun z/org-export-revel-subtree ()
 "export to org reveal"
 (interactive)                                
 (org-reveal-export-current-subtree)
 )
 #+END_SRC
**** export current org buffer to html bookmark file
 http://lists.gnu.org/archive/html/emacs-orgmode/2009-09/msg00834.html
 #+BEGIN_SRC emacs-lisp
 (defun z/org-export-html-bookmarks ()
   "Extract bookmarks from the current org file and create an html file that
 can be imported into a web browser."
   (interactive)
   (unless (eq major-mode 'org-mode) 
     (error "Not in an org buffer"))
   (let ((file (file-name-nondirectory (buffer-file-name)))
         bookmarks)
   (save-excursion
     (goto-char (point-min))
     (while (re-search-forward org-bracket-link-analytic-regexp nil t)
       (when (equal (match-string 2) "http")
         (let ((url (concat (match-string 1)
                            (match-string 3)))
               (desc (match-string 5)))
           (push (concat "<DT><A HREF=\"" url "\">" desc "</A>\n") bookmarks))))
     (with-temp-buffer 
       (insert
	"<!DOCTYPE NETSCAPE-Bookmark-file-1>\n"
	"<HTML>\n"
	"<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; 
 charset=UTF-8\">\n"
	"<Title>Bookmarks</Title>\n"
	"<H1>Bookmarks</H1>\n"
	"<DT><H3 FOLDED>" file " (" (format-time-string "%Y-%m-%d") ")</H3>\n"
	"<DL><p>\n")
       (apply 'insert (nreverse bookmarks))
       (insert
	"</DL><p>\n"
	"</HTML>")
       (write-file (concat (file-name-sans-extension file) 
 "-bookmarks.html"))))))
 #+END_SRC
*** org-teleport
http://kitchingroup.cheme.cmu.edu/blog/2016/03/18/Org-teleport-headlines/

#+BEGIN_SRC emacs-lisp  :results none
(defun org-teleport (&optional arg)
  "Teleport the current heading to after a headline selected with avy.
With a prefix ARG move the headline to before the selected
headline. With a numeric prefix, set the headline level. If ARG
is positive, move after, and if negative, move before."
  (interactive "P")
  ;; Kill current headline
  (org-mark-subtree)
  (kill-region (region-beginning) (region-end))
  ;; Jump to a visible headline
  (avy-with avy-goto-line (avy--generic-jump "^\\*+" nil avy-style))
  (cond
   ;; Move before  and change headline level
   ((and (numberp arg) (> 0 arg))
    (save-excursion
      (yank))
    ;; arg is what we want, second is what we have
    ;; if n is positive, we need to demote (increase level)
    (let ((n (- (abs arg) (car (org-heading-components)))))
      (cl-loop for i from 1 to (abs n)
               do
               (if (> 0 n)
                   (org-promote-subtree)
                 (org-demote-subtree)))))
   ;; Move after and change level
   ((and (numberp arg) (< 0 arg))
    (org-mark-subtree)
    (goto-char (region-end))
    (when (eobp) (insert "\n"))
    (save-excursion
      (yank))
    ;; n is what we want and second is what we have
    ;; if n is positive, we need to demote
    (let ((n (- (abs arg) (car (org-heading-components)))))
      (cl-loop for i from 1 to (abs n)
               do
               (if (> 0 n) (org-promote-subtree)
                 (org-demote-subtree)))))

   ;; move to before selection
   ((equal arg '(4))
    (save-excursion
      (yank)))
   ;; move to after selection
   (t
    (org-mark-subtree)
    (goto-char (region-end))
    (when (eobp) (insert "\n"))
    (save-excursion
      (yank))))
  (outline-hide-leaves))

#+END_SRC
*** movements 
**** TODO move to top and collapse
     :PROPERTIES:
     :ID:       14d0aa60-975b-4fb1-9065-45650b64afc1
     :END:
#+BEGIN_SRC emacs-lisp :results none
(defun z/org-move-top-collapse  ()
     (interactive)            
     (beginning-of-buffer)                    
     (hide-sublevels 1)
)
#+END_SRC
**** go to top header

#+BEGIN_SRC emacs-lisp :results none
; Speed commands are really useful, but I often want to make use of
; them when I'm not at the beginning of a header. Ths command brings
; you back to the beginning of an item's header, so that you can do
; speed commands.
 
(defun org-go-speed ()
"Goes to the beginning of an element's header, so that you can
execute speed commands."
(interactive)
(when (equal major-mode 'org-mode)
(if (org-at-heading-p)
(org-beginning-of-line)
(org-up-element))))
 
#+END_SRC
     

** org macros
* look and feel
** Base

#+begin_src emacs-lisp results none
;; Remove splash screen
(setq inhibit-splash-screen t)

;; transient mode-importnat!
(transient-mark-mode 1)

;;winner mode by def-alut

;m use C-c <left> to restore the previous window configuration
(winner-mode 1)

; syntax highlighting everywhere
(global-font-lock-mode 1)

;;clipboard to sysclip
(setq x-select-enable-clipboard t)

;;paren mode- show visually matching parens
(show-paren-mode 1)
;show line numbers
(global-linum-mode 0) ; display line numbers in margin. Emacs 23 only

;visual line
(global-visual-line-mode 1) ; 1 for on, 0 for off.

;; don't show text in scratch buffer
(setq initial-scratch-message nil)


; Add word wrapping/wrap, may cause lines to be to short if enabled
;(global-visual-line-mode t)
(setq line-move-visual nil)


;;disable tooltips
(tooltip-mode -1)

#+end_src

#+RESULTS:

** start maximized
#+BEGIN_SRC emacs-lisp :results none
;Start maximized, please
(custom-set-variables
 '(initial-frame-alist (quote ((fullscreen . maximized))))) ;; start maximized

#+END_SRC
** scroll
#+BEGIN_SRC emacs-lisp :results none
; scroll one line at a time (less "jumpy" than defaults)
(setq scroll-margin 5
scroll-conservatively 9999
scroll-step 1)
#+END_SRC
** toolbars
turn on off toolbars with icons
1 to switch on and -1 to switch off
#+BEGIN_SRC emacs-lisp :results none
(tool-bar-mode -1)
#+END_SRC
** mouse and cursor

#+BEGIN_SRC emacs-lisp :results none
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time

(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling

(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse

;make cursor blink (use -1 to disable):
(blink-cursor-mode -1)

;;Keep the cursor steady when scrolling
(setq scroll-preserve-screen-position t)


#+END_SRC
** Menus
*** Add language switching menu
 
#+begin_src emacs-lisp results none
(define-key-after global-map [menu-bar file lang-modes] 
  (cons "Language Modes" (make-sparse-keymap "major modes")) 'kill-buffer )

(define-key global-map [menu-bar file lang-modes bash] '("Bash" . sh-mode))
(define-key global-map [menu-bar file lang-modes org] '("Org" . org-mode))
(define-key global-map [menu-bar file lang-modes tcl] '("TCL" . tcl-mode))
(define-key global-map [menu-bar file lang-modes ruby] '("Ruby" . ruby-mode))
(define-key global-map [menu-bar file lang-modes python] '("Python" . python-mode))
(define-key global-map [menu-bar file lang-modes php] '("PHP" . php-mode))
(define-key global-map [menu-bar file lang-modes perl] '("Perl" . cperl-mode))
(define-key global-map [menu-bar file lang-modes separator1] '("--"))
(define-key global-map [menu-bar file lang-modes haskell] '("Haskell" . haskell-mode))
(define-key global-map [menu-bar file lang-modes ocaml] '("OCaml" . tuareg-mode))
(define-key global-map [menu-bar file lang-modes elisp] '("Emacs Lisp" . emacs-lisp-mode))
(define-key global-map [menu-bar file lang-modes separator2] '("--"))
(define-key global-map [menu-bar file lang-modes latex] '("LaTeX" . latex-mode))
(define-key global-map [menu-bar file lang-modes js] '("Javascript" . js2-mode))
(define-key global-map [menu-bar file lang-modes xml] '("XML (xml-mode)" . xml-mode))
(define-key global-map [menu-bar file lang-modes nxml] '("XML (nxml-mode)" . nxml-mode))
(define-key global-map [menu-bar file lang-modes html] '("HTML" . html-mode))
(define-key global-map [menu-bar file lang-modes htmlhelper] '("HTML (html-helper-mode)" . html-helper-mode))
(define-key global-map [menu-bar file lang-modes css] '("CSS" . css-mode))
(define-key global-map [menu-bar file lang-modes separator3] '("--"))
(define-key global-map [menu-bar file lang-modes java] '("Java" . java-mode))
(define-key global-map [menu-bar file lang-modes c++] '("C++" . c++-mode))
(define-key global-map [menu-bar file lang-modes c] '("C" . c-mode))
#+end_src

*** Add zeltak menu
 
#+begin_src emacs-lisp results none
  ;; (easy-menu-define zmenu global-map "zglobal-menu"
  ;;   '("zglobal"
       
  ;; ("Programs" ;; submenu
  ;;        [""  (djcb-term-start-or-switch "mutt" t)]
  ;;        ["mc"    (djcb-term-start-or-switch "mc" t)]
  ;;        ["htop"  (djcb-term-start-or-switch "htop" t)]
  ;;        ["iotop" (djcb-term-start-or-switch "iotop" t)])
    
  ;;      ;; http://emacs-fu.blogspot.com/2009/03/math-formulae-in-webpages.html
  ;;      ;; this submenu is only visible when in org--mode
  ;;      ("Org"  :visible (or (string= major-mode "org-mode") (string= major-mode "org-mode"))
  ;;        ["Insert formula"   texdrive-insert-formula :help "Insert some formula"]
  ;;        ["Generate images"  texdrive-generate-images :help "(Re)generate the images for the formulae"])
       
  ;;      ;; http://emacs-fu.blogspot.com/2009/03/twitter.html
  ;;      ("Twitter" ;; submenu
  ;;        ["View friends" twitter-get-friends-timeline]
  ;;        ["What are you doing?" twitter-status-edit])
  
  ;;      ("Misc"  ;; submenu
  ;;        ;; http://emacs-fu.blogspot.com/2009/01/counting-words.html
  ;;        ["Count words" djcb-count-words]
  
  ;;        ;;http://emacs-fu.blogspot.com/2008/12/showing-line-numbers.html
  ;;        ["Show/hide line numbers" linum]
  
  ;;        ;; http://emacs-fu.blogspot.com/2008/12/running-emacs-in-full-screen-mode.html
  ;;        ["Toggle full-screen" djcb-fullscreen-toggle])))
  
  (easy-menu-define zorg org-mode-map "zorg-menu"
    '("zorg"
       ;; http://emacs-fu.blogspot.com/2008/12/running-console-programs-inside-emacs.html
       ("images" ;; submenu
         ["org toggle inline"  (org-toggle-inline-images t)]
         ["mc"    (fun1  t)]
         ["htop"  (fun2  t)]
         ["iotop" (fun3  t)])
       
       ;; http://emacs-fu.blogspot.com/2009/03/twitter.html
       ("Twitter" ;; submenu
         ["View friends" twitter-get-friends-timeline]
         ["What are you doing?" twitter-status-edit])
  
       ("Misc"  ;; submenu
         ;; http://emacs-fu.blogspot.com/2009/01/counting-words.html
         ["Count words" djcb-count-words]
  
         ;;http://emacs-fu.blogspot.com/2008/12/showing-line-numbers.html
         ["Show/hide line numbers" linum]
  
         ;; http://emacs-fu.blogspot.com/2008/12/running-emacs-in-full-screen-mode.html
         ["Toggle full-screen" djcb-fullscreen-toggle])))
  
  
#+end_src

** Theme and colors
*** disable answering yes to "unsafe" themes 
#+begin_src emacs-lisp
(setq custom-safe-themes t)    
#+end_src
*** change background based on file type
#+begin_src emacs-lisp results none

;; sample code for setting a background color depending on file name extension

; (defun my-set-theme-on-mode ()
;   "set background color depending on file suffix"
;   (interactive)
;   (let ((fileNameSuffix (file-name-extension (buffer-file-name) ) ))
;     (cond
;      ((string= fileNameSuffix "py" ) (set-background-color "honeydew"))
;      ((string= fileNameSuffix "txt" ) (set-background-color "cornsilk"))
;      (t (message "%s" "no match found"))
;      )
;     ))
;
; (add-hook 'find-file-hook 'my-set-theme-on-mode)
#+end_src

** Evil mode look and feel
*** Cursor colors by state
#+BEGIN_SRC emacs-lisp :results none
;color in emacs mode
(setq evil-emacs-state-cursor '("cyan" box))
;nomral state mode
(setq evil-normal-state-cursor '("green" box))
;visual state mode
(setq evil-visual-state-cursor '("orange" box))
;inset state mode
(setq evil-insert-state-cursor '("red" box))
(setq evil-replace-state-cursor '("red" box))
(setq evil-operator-state-cursor '("red" hollow))

#+END_SRC 
* Dired
*** main options 
**** Sort Directories First
#+BEGIN_SRC emacs-lisp :results none
;; Make sizes human-readable by default, sort version numbers
;; correctly, and put dotfiles and capital-letters first.
(setq-default dired-listing-switches "-alhv --group-directories-first ")

#+END_SRC
**** Auto guess target
Set this variable to non-nil, Dired will try to guess a default target directory. This means: if there is a dired buffer displayed in the next window, use its current subdir, instead of the current subdir of this dired buffer. The target is used in the prompt for file copy, rename etc.
#+BEGIN_SRC emacs-lisp :results none
(setq dired-dwim-target t)
#+END_SRC
**** Always Recursion
Always recursively delete directory
#+BEGIN_SRC emacs-lisp :results none
(setq dired-recursive-deletes 'always); “always” means no asking
;Always recursively copy directory
;(setq dired-recursive-copies 'top) ; “top” means ask once
(setq dired-recursive-copies 'always) ; never ask

#+END_SRC

**** dired find
#+BEGIN_SRC emacs-lisp :results none
(require 'find-dired)
(setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
#+END_SRC
**** Auto-refresh dired on file change
#+BEGIN_SRC emacs-lisp  :results none
;; Auto-refresh dired on file change
(add-hook 'dired-mode-hook 'auto-revert-mode)
;; Auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+END_SRC
**** dired sync for external commands
#+BEGIN_SRC emacs-lisp  :results none
;; Allow running multiple async commands simultaneously
(defadvice shell-command (after shell-in-new-buffer (command &optional output-buffer error-buffer))
  (when (get-buffer "*Async Shell Command*")
    (with-current-buffer "*Async Shell Command*"
      (rename-uniquely))))
(ad-activate 'shell-command)
#+END_SRC
*** dired omit 
Omitting a file means removing it from the directory listing. Omitting is useful for keeping Dired buffers free of “uninteresting” files (for instance, auto-save, auxiliary, backup, and revision control files) so that the user can concentrate on the interesting files.
To activate it, add this to your .emacs

#+BEGIN_SRC emacs-lisp :results none
(setq-default dired-omit-mode t)
#+END_SRC

To toggle the mode, bind it to a keystroke that you like

(define-key dired-mode-map (kbd "C-o") 'dired-omit-mode)

dired-omit-files contains the regex of the files to hide in Dired Mode. For example, if you want to hide the files that begin with . and #, set that variable like this

(setq-default dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\.")

The variable dired-omit-extensions holds the list of all file extensions to hide in Dired Omit Mode. You can modify the list to add more file extensions to hide or remove the ones that you would like to show.

(add-to-list 'dired-omit-extension ".example")
(delete 'dired-omit-extension ".example")

**** start and toggle
@Note: If you are using Dired Omit Mode with dired+, remember to put the config of Dired Omit Mode before loading (require) dired+ since some feature of dired+ use the config from Dired Omit Mode (for example for displaying the file names).@
#+BEGIN_SRC emacs-lisp :results none
;To activate it, add this to your .emacs
(setq-default dired-omit-mode t)
;To toggle the mode, bind it to a keystroke that you like
(define-key dired-mode-map (kbd "C-o") 'dired-omit-mode)
#+END_SRC

*** TODO wdired mode
!check why mapping tab doesn't work and kills Emacs startup!
functions to get tab etc to work 

#+BEGIN_SRC emacs-lisp :results none
(defun my-mark-file-name-for-rename ()
    "Mark file name on current line except its extension"
    (interactive)

    ;; get the file file name first
    ;; full-name: full file name
    ;; extension: extension of the file
    ;; base-name: file name without extension
    (let ((full-name (file-name-nondirectory (dired-get-filename)))
          extension base-name)
      
      ;; check if it's a dir or a file
      ;; TODO not use if, use switch case check for symlink
      (if (file-directory-p full-name)
          (progn
            ;; if file name is directory, mark file name should mark the whole
            ;; file name
            (call-interactively 'end-of-line) ;move the end of line
            (backward-char (length full-name)) ;back to the beginning
            (set-mark (point))
            (forward-char (length full-name)))
        (progn
          ;; if current file is a file, mark file name mark only the base name,
          ;; exclude the extension
          (setq extension (file-name-extension full-name))
          (setq base-name (file-name-sans-extension full-name))
          (call-interactively 'end-of-line)
          (backward-char (length full-name))
          (set-mark (point))
          (forward-char (length base-name))))))

  (defun my-mark-file-name-forward ()
    "Mark file name on the next line"
    (interactive)
    (deactivate-mark)
    (next-line)
    (my-mark-file-name-for-rename))

  (defun my-mark-file-name-backward ()
    "Mark file name on the next line"
    (interactive)
    (deactivate-mark)
    (previous-line)
    (my-mark-file-name-for-rename))

#+END_SRC

$Note-if you see starnge behivour this maybe a culprit$  
#+BEGIN_SRC emacs-lisp :results none
  ;; (eval-after-load 'wdired
  ;;   (progn
  ;;     (define-key wdired-mode-map (kbd "d") 'my-mark-file-name-forward))
#+END_SRC
*** archive files
#+BEGIN_SRC emacs-lisp :results none
;; Handle zip compression
(eval-after-load "dired-aux"
  '(add-to-list 'dired-compress-file-suffixes
                '("\\.zip\\'" ".zip" "unzip")))
#+END_SRC
*** navigate
**** TODO auto open/enter file/dir in isearch
#+BEGIN_SRC emacs-lisp :results none
  ;; (add-hook 'isearch-mode-end-hook 
  ;;   (lambda ()
  ;;     (when (and (eq major-mode 'dired-mode)
  ;;            (not isearch-mode-end-hook-quit))
  ;;       (dired-find-file))))
#+END_SRC

*** keybinds
 #+BEGIN_SRC emacs-lisp :results none
 (define-key dired-mode-map (kbd "<left>") 'diredp-up-directory-reuse-dir-buffer )
 (define-key dired-mode-map (kbd "<right>") 'diredp-find-file-reuse-dir-buffer )
 (define-key dired-mode-map (kbd "S-RET") 'dired-open-in-external-app )
;; (define-key dired-mode-map (kbd "/") 'isearch-repeat-forward )
 (define-key dired-mode-map (kbd "/") 'dired-narrow )
 (define-key dired-mode-map (kbd "S-.") 'helm-dired-recent-dirs-view )
 (define-key dired-mode-map (kbd  "\\") 'hydra-dired-chd/body )
 (define-key dired-mode-map (kbd  "`") 'hydra-dired-leader/body )
 (define-key dired-mode-map (kbd  "<f1>") 'dired-do-async-shell-command   )
 (define-key dired-mode-map (kbd  "<f2>") 'dired-efap   )
 (define-key dired-mode-map (kbd  "<f3>") 'dired-view-file   )
 (define-key dired-mode-map (kbd  "<f5>") 'dired-do-copy  )
 (define-key dired-mode-map (kbd  "<f6>") 'dired-do-rename  )
 (define-key dired-mode-map (kbd  "<f7>") 'dired-create-directory  )
 (define-key dired-mode-map (kbd  "<f9>") 'eshell  )
 (define-key dired-mode-map (kbd  "y") 'tda/rsync-multiple-mark-file )
 (define-key dired-mode-map (kbd  "p") 'tda/rsync-multiple )
 (define-key dired-mode-map (kbd  "<C-return>") 'z/dired-xdg-open )
 (define-key dired-mode-map (kbd  "<C-a>") 'dired-mark-subdir-files )
 (define-key dired-mode-map (kbd  "S-<f1>") 'hydra-toggles/body  )
 (define-key dired-mode-map (kbd  "S-<f3>") 'hydra-spell/body  )
 (define-key dired-mode-map (kbd  "S-<f4>") 'hydra-org-blocks/body  )
 (define-key dired-mode-map (kbd  "S-<f5>") 'hydra-mu4e/body  )
 (define-key dired-mode-map (kbd  "S-<f6>") 'hydra-bib/body  )
 (define-key dired-mode-map (kbd  "S-<f9>") 'hydra-org/body  )
;;; for image dired to delete photos using 'd'
 (define-key image-mode-map (kbd  "d") 'z/delete-current-file  )
 #+END_SRC

*** hydra (f2)
**** dired leader
 #+BEGIN_SRC emacs-lisp :results none
    (global-set-key
       (kbd "")
    (defhydra hydra-dired-leader  (:color blue  :columns 4 :hints nil)
    "
【s】sort 【+】 add dir 【&/!】 open with 【M-n】 cycle diredx guesses 【(】 toggle dired details 
【C/R/D/S】 copy/move(rename)/delete/symlink 【S-5-m】 mark by string // ^test(start with) txtDOLLAR (end with) 
【*s】 mark all 【t】 toggle mark (mark all) 【*t】 invert mark 【*d】 mark for deletion 【k】 hide marked 【g】unhide mark 【*.】 mark by extension 
【C-space】start visual mark
【g】 refresh
【Q】query replace marked files 【o】open file new window 【V】open file read only 【i】open dir-view below
【b】preview file 【v】 viewer for ranger-copies using 【C-u】 saves the content of the clip after the paste
【C-enter】 open via dired-open 【a】 replaces the current (dired) buffer with the selected file/directory
【C-u C-u】 prefix to work on all files 【C-x E//D】add//union arbitrary files to an existing Dired buffer
【/】 filter 【g】 clear filter 
【P】 peep-dir (image view) >> image mode:  【p/n】next/prev images 【d】del image 
    "
    ("/" dired-toggle-sudo  "dired toggle sudo" :face 'hydra-face-red ) 
    ("<f1>" diredp-toggle-find-file-reuse-dir  "toggle resue dired" ) 
    ("+" z/transpose-buffers  "transpose-buffers" ) 
    ("1" hydra-dired-operations/body "dired operations" )
    ("2" hydra-dired-searches/body "dired searches" )
    ("a" dired-mark-subdir-files "mark all" )
    ("c" z/dired-copy-setdirs "copy to dirs"  :face 'hydra-face-red )
    ("C" z/dired-copy-setdirs-recurs "copy to dirs-RECURSE"   :face 'hydra-face-red  )
    ("m" z/dired-move-setdirs  "move to dirs-RECURSE"   :face 'hydra-face-red  )            
    ("M" z/dired-move-setdirs-recurs   "move to dirs-RECURSE"   :face 'hydra-face-red  )            
    ("z" dired-filter-load-saved-filters "load filter")
    ("Z" hydra-dired-filter/body "filter menu")
    ("h"  nil )
    ("o" z/dired-open-in-desktop "open with FM" )
    ("s"  z/dired-sort-menu "sort menu" )
    ("n"  z/dired-get-size "get size" )
    ("r" wdired-change-to-wdired-mode "wdired (bath rename)" )
    ("u"  diredfd-do-unpack "unpack"   :face 'hydra-face-brown  )
    ("U"  z/dired-archive-unrar "unrar" :face 'hydra-face-brown )
    ("p"  diredfd-do-pack  "pack" :face 'hydra-face-brown )
    ("Y"  dired-ranger-copy "copy2clip" )
    ("P"  dired-ranger-paste "paste_F_clip")
    ("D" dired-ranger-move "move2clip")
    ("f" z/dired-shell-fb "fb" )
    ("x"  z/dired-shell-chmodx "+x" )
    ("r"  wdired-change-to-wdired-mode "wdired (bath rename)" )
    (";"  nil )
    ("q"  nil )

    ))
 #+END_SRC


**** dired chd
change dir only in dir mode hook?
#+BEGIN_SRC emacs-lisp :results none
(global-set-key
   (kbd "")
(defhydra hydra-dired-chd  (:color blue :hint nil :columns 4)

"
"
("\\" z/ivy-dired-recent-dirs "recent dirs" )
("a" (find-file "~/AUR/") "AUR" )
("2" (find-file "/home/zeltak/mounts/lraid/Download/transmission/completed/") "P2P" )
("3" (find-file "/home/zeltak/mounts/lraid/raid") "P2P" )
("b"  (find-file "~/bin/") "bin" )
("B"  (dired "~/bin/") "bin" )
("c"  (find-file "~/.config/") "config")
("d" (find-file "~/Downloads/")    "Downloads" )
("e"  (find-file "~/.emacs.d/") "Emacs.d")
("E"  (find-file "~/.emacs.g/") "Emacs.g")
("f"  nil )
("g"  nil )
("h"  (find-file "~/") "HOME" )
("i"  nil )
("j"  bmkp-dired-jump  "jump BK+" )
("J"  bmkp-dired-jump-current  "jump BK+ CURRENT" )
("k"  (find-file "~/BK/") "BK" )
("l"  (find-file "~/MLT/") "MLT")
("m"  (find-file "~/music/") "music" )
("n n " (find-file "/media/NAS/Uni/") "NAS home" )
("n p" (find-file "/media/NAS/Uni/Projects/") "NAS home" )
("n d " (find-file "/media/NAS/Uni/data/") "NAS home" )
("o"  (find-file "~/org/files/") "Org" )
("p"  (find-file "/home/zeltak/Sync/Uni/pdf_lib") "pdf lib" )
("r"  (find-file "~/mreview/") "mreview" )
("s"  (find-file "~/Sync/") "Sync" )
("S"  (find-file "~/scripts/" "scripts") )
("t"  (find-file "~/mounts/" "mounts") )
("u"  (find-file "~/Uni/") "Uni" )
("v"  (find-file "/home/zeltak/.password-store") "password-store" )
("w"  (find-file "~/dotfiles/") "dotfiles" )
("x"  z/buffer-close-andmove-other  "close window" :face 'hydra-face-red  )
("y"  (find-file "/home/zeltak/org/files/Uni/Projects/code") "code" )
("z"  (find-file "~/ZH_tmp//") "ZH_tmp" )
;;("z"  (bmkp-dired-jump "d.ZH_tmp") "ZH_tmp" )
("/"  (find-file "/") "Root")
("q" nil  )

))

#+END_SRC


**** dired filter and find 
 #+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-dired-filter  (:color blue :hint nil :columns 5)
      "
Filter by:
      "
     ("e" dired-filter-by-extension  "extension"  :face 'hydra-face-brown ) 
     ("r" dired-filter-by-regexp  "regex" :face 'hydra-face-brown ) 
     ("f" dired-filter-by-file  "file"  :face 'hydra-face-brown ) 
     ("n" dired-filter-by-name  "name"  :face 'hydra-face-brown ) 
     ("S" dired-filter-save-filters  "save filter" ) 
     ("l" dired-filter-load-saved-filters  "load filter"  :face 'hydra-face-brown ) 
     ("L" dired-filter-add-saved-filters "add ontop filter"  :face 'hydra-face-brown ) 
     ("z" dired-filter-mode "toggle (clear) filter"  :face 'hydra-face-brown ) 
     ("d" find-name-dired  "find file dired" ) 
     ("g" find-grep-dired  "find grep dired" ) 
      ("q" nil "cancel" nil)
 )
 #+END_SRC

**** dired-omit-mode

 #+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-dired-configs (:color blue )
      "
      "
     ("o" dired-omit-mode  "dired omit" ) 
     ("t" dired-details-toggle  "dired details" ) 
     ("w" wdired-change-to-wdired-mode  "wdired" ) 
      ("q" nil "cancel" nil)
 )
 #+END_SRC

dired-omit-mode


**** dired operations
 #+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-dired-operations  (:color blue :hint nil :columns 5)
      "
Filter by:
      "
     ("b" (execute-kbd-macro (symbol-function 'z/dired-macro-beetimp))  "beet import" ) 
     ("d"  z/dired-shell-ncdu  "ncdu" ) 
     ("nm" z/dired-shell-nmap-hlan  "nmap" ) 
     ("ns" z/dired-shell-netstat  "netstat") 
     ("o" z/del-nonorg-files  "delete non org" ) 
     ("m" z/dired-media-info  "media-info" ) 
     ("cd" z/dired-shell-doc2docx  "doc2docx" ) 
     ("cp" z/dired-shell-pdf2text  "pdf2text" ) 
     ("is" xah-dired-scale-image  "scale" ) 
     ("ic" xah-dired-image-autocrop  "autocrop" ) 
     ("ij" xah-dired-2jpg  "to-jpg" ) 
     ("ip" xah-dired-2png "to-png" ) 
     ("v"  dired-do-version  "version (copy) file" ) 
      ("q" nil "cancel" nil)
 )
 #+END_SRC


**** dired searches
 #+BEGIN_SRC emacs-lisp :results none
 (defhydra hydra-dired-searches  (:color blue :hint nil :columns 5)
      "
Filter by:
      "
     ("i" z/dired-search-imdb "imdb" ) 
     ("g" z/dired-search-google "google" ) 
     ("m" z/dired-search-allmusic "allmusic" ) 
      ("q" nil "cancel" nil)
 )
 #+END_SRC


*** functions
**** marks
***** mark and delete non org
 #+BEGIN_SRC emacs-lisp :results none
 (defun z/del-nonorg-files ()
 (interactive)
 (dired-mark-files-regexp "\\.org$") 
 (dired-toggle-marks)
 (dired-do-delete)
 )
 #+END_SRC
**** recent dirs
#+BEGIN_SRC emacs-lisp  :results none
;; open recent directory, requires ivy (part of swiper)
;; borrows from http://stackoverflow.com/questions/23328037/in-emacs-how-to-maintain-a-list-of-recent-directories
(defun z/ivy-dired-recent-dirs ()
  "Present a list of recently used directories and open the selected one in dired"
  (interactive)
  (let ((recent-dirs
         (delete-dups
          (mapcar (lambda (file)
                    (if (file-directory-p file) file (file-name-directory file)))
                  recentf-list))))

    (let ((dir (ivy-read "Directory: "
                         recent-dirs
                         :re-builder #'ivy--regex
                         :sort nil
                         :initial-input nil)))
      (dired dir))))

(global-set-key (kbd "C-x C-d") 'z/ivy-dired-recent-dirs)
#+END_SRC
**** open in external (default) app
 http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html

 #+BEGIN_SRC emacs-lisp :results none
 (defun z/dired-open-in-external-app ()
   "Open the current file or dired marked files in external app.
 The app is chosen from your OS's preference."
   (interactive)
   (let* (
          (ξfile-list
           (if (string-equal major-mode "dired-mode")
               (dired-get-marked-files)
             (list (buffer-file-name))))
          (ξdo-it-p (if (<= (length ξfile-list) 5)
			t
                      (y-or-n-p "Open more than 5 files? "))))

     (when ξdo-it-p
       (cond
	((string-equal system-type "windows-nt")
         (mapc
          (lambda (fPath)
            (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t))) ξfile-list))
	((string-equal system-type "darwin")
         (mapc
          (lambda (fPath) (shell-command (format "open \"%s\"" fPath)))  ξfile-list))
	((string-equal system-type "gnu/linux")
         (mapc
          (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath))) ξfile-list))))))
 #+END_SRC
**** open in WM/DE file manager
 #+BEGIN_SRC emacs-lisp :results none
 (defun z/dired-open-in-desktop ()
   "Show current file in desktop (OS's file manager)."
   (interactive)
   (cond
    ((string-equal system-type "windows-nt")
     (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
    ((string-equal system-type "darwin") (shell-command "open ."))
    ((string-equal system-type "gnu/linux")
     (let ((process-connection-type nil)) (start-process "" nil "xdg-open" "."))
     ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. ⁖ with nautilus
     ) ))
 #+END_SRC

**** get marked files size
 #+BEGIN_SRC emacs-lisp :results none
  (defun z/dired-get-size ()
   (interactive)
   (let ((files (dired-get-marked-files)))
     (with-temp-buffer
       (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
       (message "Size of all marked files: %s"
		(progn 
                  (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
                   (match-string 1))))))
 #+END_SRC

**** TODO beet import

 #+BEGIN_SRC emacs-lisp :results none
   ;; (defun  z/dired-beet-importx ()
   ;;     "Uses beets to import folder"
   ;;    (interactive)
   ;;   (dired-do-async-shell-command (concat "beet import -s" (dired-file-name-at-point))))
 #+END_SRC
**** media
***** mediainfo
#+BEGIN_SRC emacs-lisp :results none
  (defun  z/dired-media-info ()
      "media info "
      (interactive)
      (shell-command (concat "mediainfo "  (dired-file-name-at-point)
 )))
#+END_SRC
**** networking
***** netstat
#+BEGIN_SRC emacs-lisp :results none
(defun  z/dired-shell-netstat ()
 "netstat"
(interactive)
(z/visit-ansi-term)
(term-send-input)
(insert "netstat -tlnp" )
(term-send-input)
)
 #+END_SRC
***** nmap home lan
#+BEGIN_SRC emacs-lisp :results none
(defun  z/dired-shell-nmap-hlan ()
 "nmap-hlan"
(interactive)
(z/visit-ansi-term)
(term-send-input)
(insert "nmap -sP 192.168.0.1/24" )
(term-send-input)
)
 #+END_SRC
**** fb
 #+BEGIN_SRC emacs-lisp
 (defun  z/dired-shell-fb ()
     "Uses fb to upload file at point."
     (interactive)
     (shell-command (concat "fb " (dired-file-name-at-point)))
     (message (propertize "Uploaded to FB" 'face 'font-lock-warning-face))
)
 #+END_SRC
 
**** chmodx

 #+BEGIN_SRC emacs-lisp
 (defun z/dired-shell-chmodx ()
     "chmod"
     (interactive)
     (shell-command (concat "chmod +x " (dired-file-name-at-point)))
;;; to refresh view use revert buffer  
    (revert-buffer)
    (message (propertize "changed mode to executable" 'face 'font-lock-warning-face))
 )

 #+END_SRC

***** sshfs qnap
  #+BEGIN_SRC emacs-lisp
  (defun z/dired-ssh-qnap ()
      "chmod"
      (interactive)
      (shell-command (concat "sshfs -p 12121 admin@10.0.0.2:/share/MD0_DATA/ /home/zeltak/mounts/lraid " (dired-file-name-at-point)))
      (message (propertize "connected to ssh" 'face 'font-lock-warning-face))
  )
  #+END_SRC
**** nmap network
 #+BEGIN_SRC emacs-lisp :results none
 (defun z/dired-nmap-network ()
 "map all available IP on my netwrok"
 (interactive)
 (sr-term )
 (insert " nmap -sP 10.0.0.1/24" )
 (eshell-send-input)
 )
 #+END_SRC
**** dired sort
 #+BEGIN_SRC emacs-lisp :results none
 (defun z/dired-sort-menu ()
   "Sort dired dir listing in different ways.
 Prompt for a choice.
 URL `http://ergoemacs.org/emacs/dired_sort.html'
 Version 2015-07-30"
   (interactive)
   (let (ξsort-by ξarg)
     (setq ξsort-by (ido-completing-read "Sort by:" '( "date" "size" "name" "dir")))
     (cond
      ((equal ξsort-by "name") (setq ξarg "-Al --si --time-style long-iso "))
      ((equal ξsort-by "date") (setq ξarg "-Al --si --time-style long-iso -t"))
      ((equal ξsort-by "size") (setq ξarg "-Al --si --time-style long-iso -S"))
      ((equal ξsort-by "dir") (setq ξarg "-Al --si --time-style long-iso --group-directories-first"))
      (t (error "logic error 09535" )))
     (dired-sort-other ξarg )))
 #+END_SRC
**** copy to specific folders
http://stackoverflow.com/questions/29809698/emacs-dired-using-predefined-variable

#+BEGIN_SRC emacs-lisp  :results none
;; Use ido
(require 'ido)

;; Make a hash table to hold the paths
(setq my-target-dirs (make-hash-table :test 'equal))

;; A function to return all the keys from a hash.
(defun get-keys-from-hash (hash)
  (let ((keys ()))
    (maphash (lambda (k v) (push k keys)) hash)
    keys))

;; And the function to prompt for a directory by keyword that is looked
;; up in the hash-table and used to build the target path from the
;; value of the lookup.
(defun z/dired-copy-setdirs ()
  (interactive)
  (let* ((my-hash my-target-dirs)
         (files (dired-get-marked-files))
         (keys (get-keys-from-hash my-hash)))
    (mapc (lambda (file)
            (copy-file file
                       (concat
                        (gethash
                         (ido-completing-read
                          (concat "copy " file " to: ") keys) my-hash)
                        (file-name-nondirectory file))))
          files)))


(defun z/dired-move-setdirs ()
  (interactive)
  (let* ((my-hash my-target-dirs)
         (files (dired-get-marked-files))
         (keys (get-keys-from-hash my-hash)))
    (mapc (lambda (file)
            (rename-file file
                       (concat
                        (gethash
                         (ido-completing-read
                          (concat "move" file " to: ") keys) my-hash)
                        (file-name-nondirectory file))))
          files)))
#+END_SRC


#+BEGIN_SRC emacs-lisp  :results none
;; Put some paths in the hash (sorry for Unix pathnames)
(puthash "home" "/home/zeltak/" my-target-dirs)
(puthash "AUR" "/home/zeltak/AUR/" my-target-dirs)
(puthash "downloads" "/home/zeltak/Downloads/ " my-target-dirs)
(puthash "ZH_tmp" "/home/zeltak/ZH_tmp/" my-target-dirs)
(puthash "music" "/home/zeltak/music/" my-target-dirs)
(puthash "bin" "/home/zeltak/bin/" my-target-dirs)
(puthash "BK" "/home/zeltak/BK/" my-target-dirs)
(puthash "org" "/home/zeltak/org/" my-target-dirs)
(puthash "mreview" "/home/zeltak/mreview/" my-target-dirs)
(puthash "Sync" "/home/zeltak/Sync/" my-target-dirs)
(puthash "Uni" "/home/zeltak/Uni/" my-target-dirs)
(puthash "scripts" "/home/zeltak/scripts" my-target-dirs)
(puthash "dotfiles" "/home/zeltak/dotfiles/" my-target-dirs)
(puthash "config" "/home/zeltak/.config/" my-target-dirs)
(puthash "conv" "/home/zeltak/ZH_tmp/$CONV" my-target-dirs)
(puthash "mvid" "/home/zeltak/mounts/lraid/raid/Videos/1_Video/michal/" my-target-dirs)
#+END_SRC


 #+BEGIN_SRC emacs-lisp
   (defun z/dired-copy-setdirs-recurs ()
     (interactive)
     (let* ((my-hash my-target-dirs)
            (files (dired-get-marked-files))
            (keys (get-keys-from-hash my-hash)))
       (mapc (lambda (file)
               (let ((target (gethash
                              (ido-completing-read
                               (concat "copy " file " to: ") keys) my-hash)))
                 (if (y-or-n-p "Descend?")
                     ;; Descend into subdirectories relative to target dir
                     (let ((new-target (ido-read-directory-name "new dir: " target))) 
                       (copy-file file (concat new-target
                                               (file-name-nondirectory file)))
                       (message (concat "File: " file " was copied to " new-target)))
                   ;; Else copy to root of originally selected directory
                   (copy-file file (concat target (file-name-nondirectory file)))
                   (message (concat "File: " file " was copied to " target)))))
             files)))

   (defun z/dired-move-setdirs-recurs ()
     (interactive)
     (let* ((my-hash my-target-dirs)
            (files (dired-get-marked-files))
            (keys (get-keys-from-hash my-hash)))
       (mapc (lambda (file)
               (let ((target (gethash
                              (ido-completing-read
                               (concat "move " file " to: ") keys) my-hash)))
                 (if (y-or-n-p "Descend?")
                     ;; Descend into subdirectories relative to target dir
                     (let ((new-target (ido-read-directory-name "new dir: " target))) 
                       (rename-file file (concat new-target
                                               (file-name-nondirectory file)))
                       (message (concat "File: " file " was moved to " new-target)))
                   ;; Else copy to root of originally selected directory
                   (rename-file file (concat target (file-name-nondirectory file)))
                   (message (concat "File: " file " was moved to " target)))))
             files)))
 #+END_SRC
**** dired-image
***** TODO extra binds
#+BEGIN_SRC emacs-lisp  :results none
(defun z/dired--next-image ()
  (interactive)
  (save-excursion 
    (with-current-buffer "*image-dired*"
      (image-dired-forward-image)
      (image-dired-display-thumbnail-original-image))))

(defun z/dired-prev-image ()
  (interactive)
  (save-excursion 
    (with-current-buffer "*image-dired*"
      (image-dired-backward-image)
      (image-dired-display-thumbnail-original-image))))

(defun x/dired-insert-current-image-path ()
  (interactive)
  (insert
   (concat
    "[["
    (save-excursion
      (with-current-buffer "*image-dired*"
        (image-dired-original-file-name)))
    "]]")))

#+END_SRC
***** xah image manipulations
#+BEGIN_SRC emacs-lisp  :results none
(defun xah-process-image (φfile-list φargs-str φnew-name-suffix φnew-name-file-suffix )
  "Wrapper to ImageMagick's “convert” shell command.
φfile-list is a list of image file paths.
φargs-str is argument string passed to ImageMagick's “convert” command.
φnew-name-suffix is the string appended to file. e.g. “_new” gets you “…_new.jpg”
φnew-name-file-suffix is the new file's file extension. e.g. “.png”

URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2015-10-19"
  (require 'dired)
  (mapc
   (lambda (ξf)
     (let ( newName cmdStr )
       (setq newName
             (concat
              (file-name-sans-extension ξf)
              φnew-name-suffix
              φnew-name-file-suffix))
       (while (file-exists-p newName)
         (setq newName
               (concat
                (file-name-sans-extension newName)
                φnew-name-suffix
                (file-name-extension newName t))))
       ;; relative paths used to get around Windows/Cygwin path remapping problem
       (setq cmdStr
             (format
              "convert %s '%s' '%s'" 
              φargs-str 
              (file-relative-name ξf) 
              (file-relative-name newName)))
       (shell-command cmdStr)))
   φfile-list )
  (revert-buffer))

(defun xah-dired-scale-image (φfile-list φscale-percentage φsharpen?)
  "Create a scaled version of images of marked files in dired.
The new names have “-s” appended before the file name extension.

If `universal-argument' is given, output is PNG format. Else, JPG.

When called in lisp code,
 φfile-list is a list.
 φscale-percentage is a integer.
 φsharpen? is true or false.

Requires ImageMagick unix shell command.
URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2015-03-10"
  (interactive
   (let (
         (myFileList
          (cond
           ((string-equal major-mode "dired-mode") (dired-get-marked-files))
           ((string-equal major-mode "image-mode") (list (buffer-file-name)))
           (t (list (read-from-minibuffer "file name:"))))))
     (list myFileList
           (read-from-minibuffer "Scale %:")
           (y-or-n-p "Sharpen"))))
  (let ((sharpenOrNo (if φsharpen? "-sharpen 1" "" ))
        (outputSuffix (if current-prefix-arg ".png" ".jpg" )))
    (xah-process-image φfile-list
                       (format "-scale %s%% -quality 85%% %s " φscale-percentage sharpenOrNo)
                       "-s" outputSuffix )))

(defun xah-dired-image-autocrop (φfile-list φoutput-image-type-suffix)
  "Create a new auto-cropped version of images of marked files in dired.
Requires ImageMagick shell command.

If `universal-argument' is given, output is PNG format. Else, JPG.
URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2015-03-10"
  (interactive
   (let (
         (myFileList
          (cond
           ((string-equal major-mode "dired-mode") (dired-get-marked-files))
           ((string-equal major-mode "image-mode") (list (buffer-file-name)))
           (t (list (read-from-minibuffer "file name:")))))
         (φoutput-image-type-suffix (if current-prefix-arg ".png" ".jpg" )))
     (list myFileList φoutput-image-type-suffix)))
  (xah-process-image φfile-list "-trim" "-cropped" φoutput-image-type-suffix ))

(defun xah-dired-2png (φfile-list)
  "Create a png version of images of marked files in dired.
Requires ImageMagick shell command.
URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2015-03-10"
  (interactive
   (let (
         (myFileList
          (cond
           ((string-equal major-mode "dired-mode") (dired-get-marked-files))
           ((string-equal major-mode "image-mode") (list (buffer-file-name)))
           (t (list (read-from-minibuffer "file name:"))))))
     (list myFileList)))
  (xah-process-image φfile-list "" "-2" ".png" ))

(defun xah-dired-2jpg (φfile-list)
  "Create a JPG version of images of marked files in dired.
Requires ImageMagick shell command.
URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2015-03-10"
  (interactive
   (let (
         (myFileList
          (cond
           ((string-equal major-mode "dired-mode") (dired-get-marked-files))
           ((string-equal major-mode "image-mode") (list (buffer-file-name)))
           (t (list (read-from-minibuffer "file name:") )) ) ) )
     (list myFileList) )
   )
  (xah-process-image φfile-list "" "-2" ".jpg" ))
#+END_SRC
**** Shell function
***** convert doc to docx
 #+BEGIN_SRC emacs-lisp
 (defun  z/dired-shell-doc2docx ()
     "Uses fb to upload file at point."
     (interactive)
     (shell-command (concat "libreoffice --headless --convert-to docx " (dired-file-name-at-point))))

  ;; (add-hook 'dired-mode-hook '(lambda () 
  ;;                               (local-set-key (kbd "O") 'cygstart-in-dired)))
 #+END_SRC
***** convert doc to docx
 #+BEGIN_SRC emacs-lisp
 (defun  z/dired-shell-pdf2text ()
     "Uses fb to upload file at point."
     (interactive)
     (shell-command (concat "pdftotext " (dired-file-name-at-point))))

  ;; (add-hook 'dired-mode-hook '(lambda () 
  ;;                               (local-set-key (kbd "O") 'cygstart-in-dired)))
 #+END_SRC
***** TODO ncdu
how to launch it in eshell
 #+BEGIN_SRC emacs-lisp
(defun  z/dired-shell-ncdu ()
 "ncdu"
(interactive)
(z/visit-ansi-term)
(term-send-input)
(insert "ncdu" )
(term-send-input)
)
 #+END_SRC

***** TODO sshfs qnap
how to launch it in eshell
#+BEGIN_SRC emacs-lisp :results none
 (defun  z/dired-shell-sshfs-qnap ()
     "ssh qnap"
     (interactive)
   (z/visit-ansi-term)
(term-send-input)
    (insert "sshfs -p 12121 admin@10.0.0.2:/share/MD0_DATA/ /home/zeltak/mounts/lraid  " )
(term-send-input)
)
 #+END_SRC
**** unrar 
 #+BEGIN_SRC emacs-lisp :results none
 (defun  z/dired-archive-unrar ()
     "Uses beets to import folder"
     (interactive)
     (shell-command (concat "unrar x" (dired-file-name-at-point))))
 #+END_SRC
**** copy file (version it)
#+BEGIN_SRC emacs-lisp  :results none
(defcustom dired-keep-marker-version ?V
  "Controls marking of versioned files.
If t, versioned files are marked if and as the corresponding original files were.
If a character, copied files are unconditionally marked with that character."
  :type '(choice (const :tag "Keep" t)
         (character :tag "Mark"))
  :group 'dired-mark)

(defun dired-version-file (from to ok-flag)
  (dired-handle-overwrite to)
  (dired-copy-file-recursive from to ok-flag dired-copy-preserve-time t
                 dired-recursive-copies))

(defun dired-do-version (&optional arg)
  "Search for numeric pattern in file name and create a version of that file
with that number incremented by one, or, in case such file already exists,
will search for a file with the similar name, incrementing the counter each
time by one.
Additionally, if called with prefix argument, will prompt for number format.
The formatting is the same as is used with `format' function."
  (interactive "P")
  (let ((fn-list (dired-get-marked-files nil nil)))
    (dired-create-files
     (function dired-version-file) "Version" fn-list
     (function
      (lambda (from)
        (let (new-name (i 0) (fmt (if arg (read-string "Version format: " "%d") "%d")))
          (while (or (null new-name) (file-exists-p new-name))
            (setq new-name
                  (if (string-match  "^\\([^0-9]*\\)\\([0-9]+\\)\\(.*\\)$" from)
                      (concat (match-string 1 from)
                              (format fmt
                                      (+ (string-to-number (match-string 2 from)) (1+ i)))
                              (match-string 3 from))
                    (concat from (format (concat "." fmt) i)))
                  i (1+ i))) new-name)))
     dired-keep-marker-version)))

;;(define-key dired-mode-map (kbd "c") 'dired-do-version)
#+END_SRC
**** searching
***** imdb search
  #+BEGIN_SRC emacs-lisp :results none
  (defun  z/dired-search-imdb ()
      "imdb point "
      (interactive)
      (shell-command (concat "surfraw imdb " (directory-file-name (file-relative-name (dired-file-name-at-point))) 
 )))
  #+END_SRC
***** google search
  #+BEGIN_SRC emacs-lisp :results none
  (defun  z/dired-search-google ()
      "google point "
      (interactive)
      (shell-command (concat "surfraw google " (directory-file-name (file-relative-name (dired-file-name-at-point))) 
 )))
  #+END_SRC

***** allmusic search
  #+BEGIN_SRC emacs-lisp :results none
  (defun  z/dired-search-allmusic ()
      "allmusic point "
      (interactive)
      (shell-command (concat "surfraw yubnub allmusic  " (directory-file-name (file-relative-name (dired-file-name-at-point))) 
 )))
  #+END_SRC
**** Rsync copy 
#+BEGIN_SRC emacs-lisp  :results none
;;;###autoload
(defun ora-dired-rsync (dest)
  (interactive
   (list
    (expand-file-name
     (read-file-name
      "Rsync to:"
      (dired-dwim-target-directory)))))
  ;; store all selected files into "files" list
  (let ((files (dired-get-marked-files
                nil current-prefix-arg))
        ;; the rsync command
        (tmtxt/rsync-command
         "rsync -arvz --progress "))
    ;; add all selected file names as arguments
    ;; to the rsync command
    (dolist (file files)
      (setq tmtxt/rsync-command
            (concat tmtxt/rsync-command
                    (shell-quote-argument file)
                    " ")))
    ;; append the destination
    (setq tmtxt/rsync-command
          (concat tmtxt/rsync-command
                  (shell-quote-argument dest)))
    ;; run the async shell command
    (async-shell-command tmtxt/rsync-command "*rsync*")
    ;; finally, switch to that window
    (other-window 1)))

(define-key dired-mode-map "Y" 'ora-dired-rsync)

#+END_SRC
**** dired XDG open
#+BEGIN_SRC emacs-lisp  :results none
(defun z/dired-xdg-open ()
  "Open the current file or dired marked files in external app.
The app is chosen from your OS's preference.

URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
Version 2015-01-26"
  (interactive)
  (let* (
         (ξfile-list
          (if (string-equal major-mode "dired-mode")
              (dired-get-marked-files)
            (list (buffer-file-name))))
         (ξdo-it-p (if (<= (length ξfile-list) 5)
                       t
                     (y-or-n-p "Open more than 5 files? "))))

    (when ξdo-it-p
      (cond
       ((string-equal system-type "windows-nt")
        (mapc
         (lambda (fPath)
           (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t))) ξfile-list))
       ((string-equal system-type "darwin")
        (mapc
         (lambda (fPath) (shell-command (format "open \"%s\"" fPath)))  ξfile-list))
       ((string-equal system-type "gnu/linux")
        (mapc
         (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath))) ξfile-list))))))
#+END_SRC
**** copy current open buffer path to killring
#+BEGIN_SRC emacs-lisp  :results none
(defun z/dired-copy-buffer-file-path (&optional φdir-path-only-p)
  "Copy the current buffer's file path or dired path to `kill-ring'.
Result is full path.
If `universal-argument' is called first, copy only the dir path.
URL `http://ergoemacs.org/emacs/emacs_copy_file_path.html'
Version 2015-12-02"
  (interactive "P")
  (let ((ξfpath
         (if (equal major-mode 'dired-mode)
             (expand-file-name default-directory)
           (if (null (buffer-file-name))
               (user-error "Current buffer is not associated with a file.")
             (buffer-file-name)))))
    (kill-new
     (if (null φdir-path-only-p)
         (progn
           (message "File path copied: 「%s」" ξfpath)
           ξfpath
           )
       (progn
         (message "Directory path copied: 「%s」" (file-name-directory ξfpath))
         (file-name-directory ξfpath))))))
#+END_SRC\N
**** get-other-dired-directory
http://emacs.stackexchange.com/questions/20935/synchronize-current-dired-path-to-next-dired-dir-shown-in-a-split-window

#+BEGIN_SRC emacs-lisp  :results none
(defun z/dired-get-other-dired-directory ()
  "find name and directory of another dired buffer"
  (let ((bs (buffer-list))
        (here (current-buffer))
        this)
    (mapc (lambda (b) (unless (equal b here)
            (with-current-buffer b
              (if dired-directory
                  (setq this (cons (buffer-name) dired-directory)))))) bs)
    this))

(defun my/set-dired-dir-to-other ()
  "Change the dired directory to the one of another existing dired buffer"
  (interactive)
  (let ((d (my/get-other-dired-directory)))
    (if d
        (progn
          (setq dired-directory (cdr d)
                default-directory (cdr d))
          (revert-buffer)
          (rename-buffer (generate-new-buffer-name (car d))))
      (message "No other dired buffer"))))
#+END_SRC
*** dired macro
**** beet import 
 #+BEGIN_SRC emacs-lisp  :results none
 (fset 'z/dired-macro-beetimp
    [?& ?b ?e ?e ?t ?  ?i ?m ?p ?o ?r ?t ])
 #+END_SRC
**** beet import single
 #+BEGIN_SRC emacs-lisp  :results none
 (fset 'z/dired-macro-beetimp-single
    [?& ?b ?e ?e ?t ?  ?i ?m ?p ?o ?r ?t ?- ?s ])
 #+END_SRC

*** look and feel
**** breadcrumbs topbar
this will add it permanently for each dired buffer. I currently disable it

#+BEGIN_SRC emacs-lisp  :results none
;(add-hook 'dired-before-readin-hook 'diredp-breadcrumbs-in-header-line-mode)
#+END_SRC 
**** add highlight line
#+BEGIN_SRC emacs-lisp  :results none
;; Always hilight the current agenda line
(add-hook 'dired-mode-hook
          '(lambda () (hl-line-mode 1))
          'append)

#+END_SRC
*** TASK compress files
**** TASK compress to tar in dired
this will only work on Emacs 25..keep track!
http://oremacs.com/2015/10/23/dired-compress/

This new command dired-do-compress-to, bound to c, will prompt me for a file name of the output archive. So now it's easier to type in that file name, if you use ido-mode / ivy-mode / helm-mode. What's more, the command will be automatically determined from the archive extension and executed. Here's the corresponding customization variable:

#+BEGIN_SRC emacs-lisp :results none
  ;; (define-key dired-mode-map "c" 'dired-do-compress-to)

  ;; (defvar dired-compress-files-alist
  ;;   '(("\\.tar\\.gz\\'" . "tar -c %i | gzip -c9 > %o")
  ;;     ("\\.zip\\'" . "zip %o -r --filesync %i"))
  ;;   "Control the compression shell command for `dired-do-compress-to'.

  ;; Each element is (REGEXP . CMD), where REGEXP is the name of the
  ;; archive to which you want to compress, and CMD the the
  ;; corresponding command.

  ;; Within CMD, %i denotes the input file(s), and %o denotes the
  ;; output file. %i path(s) are relative, while %o is absolute.")

#+END_SRC
**** zip
http://stackoverflow.com/questions/1431351/how-do-i-uncompress-unzip-within-emacs
#+BEGIN_SRC emacs-lisp :results none
(eval-after-load "dired-aux"
   '(add-to-list 'dired-compress-file-suffixes 
                 '("\\.zip\\'" ".zip" "unzip")))

(eval-after-load "dired"
  '(define-key dired-mode-map "z" 'dired-zip-files))
(defun dired-zip-files (zip-file)
  "Create an archive containing the marked files."
  (interactive "sEnter name of zip file: ")

  ;; create the zip file
  (let ((zip-file (if (string-match ".zip$" zip-file) zip-file (concat zip-file ".zip"))))
    (shell-command 
     (concat "zip " 
             zip-file
             " "
             (concat-string-list 
              (mapcar
               '(lambda (filename)
                  (file-name-nondirectory filename))
               (dired-get-marked-files))))))

  (revert-buffer)

  ;; remove the mark on all the files  "*" to " "
  ;; (dired-change-marks 42 ?\040)
  ;; mark zip file
  ;; (dired-mark-files-regexp (filename-to-regexp zip-file))
  )

(defun concat-string-list (list) 
   "Return a string which is a concatenation of all elements of the list separated by spaces" 
    (mapconcat '(lambda (obj) (format "%s" obj)) list " "))
#+END_SRC 

* Aliases
** settings
#+BEGIN_SRC emacs-lisp :results none
(defalias 'yes-or-no-p 'y-or-n-p) ; y or n is enough
(defalias 'list-buffers 'ibuffer) ; always use ibuffer
(defalias '~ 'make-backup)
(defalias 'lp 'list-packages)
(defalias 'lm 'lini)
(defalias 'rr 'regex-replace)
(defalias 'em 'evil-mode)
(defalias 'iss 'ispell) ;check spelling on buffer or region if marked
(defalias 'bks 'bmkp-save-menu-list-state) ;check spelling on buffer or region if marked

#+END_SRC

** Editing
#+BEGIN_SRC emacs-lisp :results none

(defalias 'sl 'sort-lines)
(defalias 'rr 'reverse-region)
(defalias 'rs 'replace-string)
(defalias 'g 'grep)
(defalias 'gf 'grep-find)
(defalias 'fd 'find-dired)
(defalias 'rb 'revert-buffer)
(defalias 'sh 'shell)
(defalias 'ps 'powershell)
(defalias 'fb 'flyspell-buffer)
(defalias 'sbc 'set-background-color)
(defalias 'rof 'recentf-open-files)
(defalias 'lcd 'list-colors-display)

#+END_SRC

** major/minor modes
#+BEGIN_SRC emacs-lisp :results none
; major modes
(defalias 'hm 'html-mode)
(defalias 'tm 'text-mode)
(defalias 'elm 'emacs-lisp-mode)
(defalias 'om 'org-mode)
(defalias 'ssm 'shell-script-mode)
(defalias 'html6-mode 'xah-html6-mode)

; minor modes
(defalias 'wsm 'whitespace-mode)
(defalias 'gwsm 'global-whitespace-mode)
(defalias 'dsm 'desktop-save-mode)
(defalias 'acm 'auto-complete-mode)
(defalias 'vlm 'visual-line-mode)
(defalias 'glm 'global-linum-mode)
#+END_SRC
** Code
#+BEGIN_SRC emacs-lisp :results none
; elisp
(defalias 'eb 'eval-buffer)
(defalias 'er 'eval-region)
(defalias 'ed 'eval-defun)
(defalias 'eis 'elisp-index-search)
(defalias 'lf 'load-file)


;escapes
(defalias '\\ 'escape-quotes-region)
(defalias '\[ 'remove-square-brackets)
(defalias '\" 'replace-straight-quotes)
#+END_SRC
+
* Abbreviations
** global 
#+BEGIN_SRC emacs-lisp :results none
;; stop asking whether to save newly added abbrev when quitting emacs
;(setq save-abbrevs t)
(setq save-abbrevs 'silently)

;; turn on abbrev mode globally
(setq-default abbrev-mode t)


#+END_SRC

** personal abbriviations
*** new collected abbrv
to quickly peak at the personal file look here:

file:/home/zeltak/.emacs.d/abbrv/personal_abbrv.txt

to set 
#+BEGIN_SRC emacs-lisp :results none
(setq abbrev-file-name "/home/zeltak/.emacs.d/abbrv/personal_abbrv.txt")
#+END_SRC
to autoload it 
#+BEGIN_SRC emacs-lisp :results none
(load "/home/zeltak/.emacs.d/abbrv/personal_abbrv.txt")
#+END_SRC

*** loads a huge common abbreviations file

file:/home/zeltak/.emacs.d/avvrv/common_abbrv.txt

#+BEGIN_SRC emacs-lisp :results none
(load "/home/zeltak/.emacs.d/abbrv/common_abbrv.txt")
#+END_SRC

*** misc abbrv file (general stuff to quick add)

file:/home/zeltak/.emacs.d/abbrv/misc_abbrv.txt

#+BEGIN_SRC emacs-lisp :results none
(load "/home/zeltak/.emacs.d/abbrv/misc_abbrv.txt")
#+END_SRC
* minor modes
** vimrc mode
#+BEGIN_SRC emacs-lisp :results none
(define-generic-mode 'vimrc-generic-mode
    '()
    '()
    '(("^[\t ]*:?\\(!\\|ab\\|map\\|unmap\\)[^\r\n\"]*\"[^\r\n\"]*\\(\"[^\r\n\"]*\"[^\r\n\"]*\\)*$"
       (0 font-lock-warning-face))
      ("\\(^\\|[\t ]\\)\\(\".*\\)$"
      (2 font-lock-comment-face))
      ("\"\\([^\n\r\"\\]\\|\\.\\)*\""
       (0 font-lock-string-face)))
    '("/vimrc\\'" "\\.vim\\(rc\\)?\\'")
    '((lambda ()
        (modify-syntax-entry ?\" ".")))
    "Generic mode for Vim configuration files.")
#+END_SRC
* Extensions
** Xha menu dirs
#+BEGIN_SRC emacs-lisp :results none
(if (string= system-name "zuni") 
(progn

(defvar xah-filelist nil "alist for files i need to open frequently. Key is a short abbrev, Value is file path.")
(setq xah-filelist
      '(
        ("z" . "~/ZH_tmp/" )
        ("k " . "~/BK/" )
        ("l" . "~/org/files/Tech/linux.org" )
        ("f" . "~/org/files/agenda/food.org" )
        ("v" . "~/org/files/Home/travel.org" )
        ("h" . "~/org/files/Home/home.org" )
        ("m" . "~/org/files/from-mobile.org" )
        ("v" . "~/org/files/files/agenda/travel.org" )
        ("h" . "~/org/files/files/Home/home.org" )
        ("p" . "~/org/files/files/uni/papers/papers.org" )
        ("E" . "~/.emacs.d/init.el" )
        ("B" . "/home/zeltak/.config/beets/config.yaml" )
        ("S" . "~/.config/sxhkd/sxhkdrc" )
        ("I" . "~/.i3/config" )
        ("X" . "~/.xinitrc" )
        ("B" . "~/.interrobangrc" )
        ("Z" . "~/.zshrc" )
        ("o" . "~/org/attach/" )
        ) )
)

(progn

(defvar xah-filelist nil "alist for files i need to open frequently. Key is a short abbrev, Value is file path.")
(setq xah-filelist
      '(
       ("z" . "~/ZH_tmp/" )
        ("k " . "~/BK/" )
        ("l" . "~/org/files/Tech/linux.org" )
        ("f" . "~/org/files/agenda/food.org" )
        ("v" . "~/org/files/Home/travel.org" )
        ("h" . "~/org/files/Home/home.org" )
        ("m" . "~/org/files/from-mobile.org" )
        ("v" . "~/org/files/files/agenda/travel.org" )
        ("h" . "~/org/files/files/Home/home.org" )
        ("p" . "~/org/files/files/uni/papers/papers.org" )
        ("E" . "~/.emacs.d/init.el" )
        ("B" . "/home/zeltak/.config/beets/config.yaml" )
        ("S" . "~/.config/sxhkd/sxhkdrc" )
        ("I" . "~/.i3/config" )
        ("X" . "~/.xinitrc" )
        ("B" . "~/.interrobangrc" )
        ("Z" . "~/.zshrc" )
        ("o" . "~/org/attach/" )
        ) )
)
)

#+END_SRC

** z/dired-jump-folders
#+BEGIN_SRC emacs-lisp :results none
(defun z/dired-jump-folders  (openCode)
  "Prompt to open a file from a pre-defined set."
  (interactive
   (list (ido-completing-read "Open:" (mapcar (lambda (x) (car x)) xah-filelist)))
   )
  (find-file (cdr (assoc openCode xah-filelist)) ) )
#+END_SRC

** menu per machine
(if (string= system-name "voices") 
(progn
COMMAND1
COMMAND2
)

(progn
COMMAND1
COMMAND2
)
)


#+END_EXAMPLE
** edit webpages with emacs
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'load-path "/home/zeltak/.emacs.g/extra/edit-server/")
(require 'edit-server)
(edit-server-start)
#+END_SRC
* R/ESS
** output
*** make scrolling always hit bottom
#+BEGIN_SRC emacs-lisp :results none
  (setq comint-scroll-to-bottom-on-input t)
  (setq comint-scroll-to-bottom-on-output t)
  (setq comint-move-point-for-output t)
#+END_SRC
** default dirs
*** transfile file
#+BEGIN_SRC emacs-lisp :results none
;don't ask to save file
;(setq ess-ask-about-transfile nil)
(setq ess-ask-about-transfile nil)
#+END_SRC

*** default directory 
#+BEGIN_SRC emacs-lisp :results none
(setq ess-ask-for-ess-directory nil)
;define deault ess dir
(setq ess-directory "/home/zeltak/ZH_tmp/")
#+END_SRC
*** local process name 
#+BEGIN_SRC emacs-lisp :results none
(setq ess-local-process-name "Runi")
#+END_SRC

*** history file
global command history file and have:
#+BEGIN_SRC emacs-lisp :results none
 (setq ess-history-directory "~/.essrhist/")
#+END_SRC
** functions
*** clear shell function
#+BEGIN_SRC emacs-lisp :results none
(defun clear-shell ()
   (interactive)
   (let ((old-max comint-buffer-maximum-size))
     (setq comint-buffer-maximum-size 0)
     (comint-truncate-buffer)
     (setq comint-buffer-maximum-size old-max))) 
#+END_SRC 
*** This recalls the R statement from your R statement history, but it tries to match it with the one which is already on your line.

#+BEGIN_SRC emacs-lisp :results none
(add-hook 'inferior-ess-mode-hook
    '(lambda nil
          (define-key inferior-ess-mode-map [\C-up]
              'comint-previous-matching-input-from-input)
          (define-key inferior-ess-mode-map [\C-down]
              'comint-next-matching-input-from-input)
          (define-key inferior-ess-mode-map [\C-x \t]
              'comint-dynamic-complete-filename)
     )
 )
#+END_SRC
This recalls the R statement from your R statement history, but it tries to match it with the one which is already on your line. So, for example, typing pl in R process and pressing \C-up (that’s control and the up arrow) will cycle through all the statements which start with pl, so it will recall for example all the plot(... commands.

*** allow ess to run procceses in background

#+BEGIN_SRC emacs-lisp :results none
(setq ess-eval-visibly 'nowait)
#+END_SRC

* Ediff

#+BEGIN_SRC emacs-lisp :results none
(defmacro csetq (variable value)
  `(funcall (or (get ',variable 'custom-set)
                'set-default)
            ',variable ,value))

(csetq ediff-window-setup-function 'ediff-setup-windows-plain)

(csetq ediff-split-window-function 'split-window-horizontally)

(csetq ediff-diff-options "-w")

(defun ora-ediff-hook ()
  (ediff-setup-keymap)
  (define-key ediff-mode-map "j" 'ediff-next-difference)
  (define-key ediff-mode-map "k" 'ediff-previous-difference))

(add-hook 'ediff-mode-hook 'ora-ediff-hook)

(winner-mode)
(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC
* Mu4e
  :PROPERTIES:
  :END:
*** base setup 
for ubuntu work machine 
#+BEGIN_SRC emacs-lisp :results none
(when (string= system-name "zuni")
(add-to-list 'load-path "~/mu/mu4e/")
)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
(require 'mu4e)
(require 'mu4e-contrib) 
;;;;$Note-this may screw up header updates$ 
;(mu4e-maildirs-extension)
;; list of my email addresses.
(setq mu4e-user-mail-address-list '("ikloog@gmail.com"
                                    "ikloog@bgu.ac.il"
                                    "ekloog@hsph.harvard.edu"))


#+END_SRC
*** fetching and indexing
#+BEGIN_SRC emacs-lisp :results none
; get mail automatically
;;
(setq mu4e-get-mail-command "/usr/bin/mbsync -a")
;;how often to launch it 
(setq mu4e-update-interval 60)


(setq mu4e-headers-auto-update t)
(setq mu4e-index-update-error-warning  t)
(setq mu4e-index-update-error-continue   t)
#+END_SRC
OLD:
#+BEGIN_EXAMPLE
;;(setq mu4e-get-mail-command "offlineimap")
#+END_EXAMPLE
*** personal info
#+BEGIN_SRC emacs-lisp :results none
;; something about ourselves
(setq
   user-mail-address "ikloog@gmail.com"
   user-full-name  "itai kloog "
   mu4e-compose-signature
    (concat
      "itai kloog\n"
      "http://www.bgu.ac.il\n"))

(setq mu4e-compose-signature-auto-include 't)
#+END_SRC

*** mail folders 
#+BEGIN_SRC emacs-lisp :results none
(require 'mu4e)

;; default
;; (setq mu4e-maildir "~/Maildir")

;;location of my maildir
(setq mu4e-maildir (expand-file-name "~/Maildir"))
(setq mu4e-sent-folder   "/[Gmail].Sent Mail")
(setq mu4e-trash-folder  "/[Gmail].Bin")
(setq mu4e-drafts-folder  "/[Gmail].Drafts")

;; don't save message to Sent Messages, Gmail/IMAP takes care of this
(setq mu4e-sent-messages-behavior 'delete)

;; (See the documentation for `mu4e-sent-messages-behavior' if you have
;; additional non-Gmail addresses and want assign them different
;; behavior.)

;; allow for updating mail using 'U' in the main view:
;(setq mu4e-get-mail-command "offlineimap")

;; sending mail -- replace USERNAME with your gmail username
;; also, make sure the gnutls command line utils are installed
;; package 'gnutls-bin' in Debian/Ubuntu

;; don't keep message buffers around
(setq message-kill-buffer-on-exit t)
#+END_SRC
*** mbsync (isync) specific
#+BEGIN_SRC emacs-lisp  :results none
;;rename files when moving
;;NEEDED FOR MBSYNC
(setq mu4e-change-filenames-when-moving t)

;;set up queue for offline email
;;use mu mkdir  ~/Maildir/queue to set up first
(setq smtpmail-queue-mail nil  ;; start in normal mode
      smtpmail-queue-dir   "~/Maildir/queue/cur")
#+END_SRC
*** Sending mail
#+BEGIN_SRC emacs-lisp :results none
(require 'smtpmail)
(setq message-send-mail-function 'smtpmail-send-it
   starttls-use-gnutls t
   smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
   smtpmail-auth-credentials
     '(("smtp.gmail.com" 587 "ikloog@gmail.com" nil))
   smtpmail-default-smtp-server "smtp.gmail.com"
   smtpmail-smtp-server "smtp.gmail.com"
   smtpmail-smtp-service 587)

;; don't save messages to Sent Messages, Gmail/IMAP takes care of this
(setq mu4e-sent-messages-behavior 'delete)
#+END_SRC
*** keybinds
**** shortcuts 
#+BEGIN_SRC emacs-lisp :results none
;; setup some handy shortcuts
;; you can quickly switch to your Inbox -- press ``ji''
;; then, when you want archive some messages, move them to
;; the 'All Mail' folder by pressing ``ma''.
 (setq mu4e-maildir-shortcuts
     '( ("/INBOX"               . ?i)
        ("/[Gmail].Sent Mail"   . ?s)
        ("/[Gmail].Bin"       . ?t)
        ("/[Gmail].Starred"       . ?1)
        ("/[Gmail].All Mail"    . ?a)))
#+END_SRC
**** extra keybinds
 #+BEGIN_SRC emacs-lisp :results none
 (define-key mu4e-headers-mode-map (kbd "w") 'z/mu4e-del-exe-func )
 (define-key mu4e-headers-mode-map (kbd "f") 'z/mu4e-flag-exe-func )
 (define-key mu4e-headers-mode-map (kbd "F") 'z/mu4e-unflag-exe-func )
 #+END_SRC
**** mu4e hydras (F5)

 #+BEGIN_SRC emacs-lisp :results none
 (global-set-key
    (kbd "<f5>")
 (defhydra hydra-mu4e (:color blue  :columns 2 :hints nil)
   "
 【M-Enter】 open link 【R】 Reply to sender 
 【+】flag (star)
 "
   ("<f5>"     z/mu4e-inbox            "mu4e inbox")
   ("7"     z/mu4e-flagged            "mu4e flagged")
 ;;  ("<f5>"     mu4e            "start mu4e")
   ("<f6>"     helm-mu            "helm mu4e")
   ("<f4>"    elfeed            "elfeed")
   ("ez" z/org-email-heading-me "email myslef the tree")
   ("ex" z/org-email-heading "email other the tree")
   ("d"    (execute-kbd-macro (symbol-function 'z/del_exe_mu4e))            "delete")
   ("f"    (execute-kbd-macro (symbol-function 'mu4e-flag-exe))         "flag")
   ("F"    (execute-kbd-macro (symbol-function 'mu4e-unflag-exe))          "unflag")
   ("o"     mu4e-headers-change-sorting            "sort")
     ("q"     nil                          "cancel" )
 ))
 #+END_SRC

 link-hint-open-link-at-point - Open the link at point.
 link-hint-copy-link-at-point - Copy link at point to kill ring (and optionally to the clipboard/primary).
 link-hint-open-link - Use avy to select and open a single visible link. If only one link is currently visible, it will be automatically opened without the need for selection.
 link-hint-open-multiple-links - Use avy to select multiple visible links and open them as soon as a key that does not correspond to a link (a key not in the avy overlay) is pressed (like pentadactyl’s g;).
 link-hint-open-all-links - Opens all links visible in the buffer.
 link-hint-copy-link - Use avy to select and copy a single visible link to the kill ring. select-enable-clipboard and select-enable-clipboard can each be set to a non-nil value to also use the clipboard and/or primary.



*** composing
#+BEGIN_SRC emacs-lisp :results none
mu4e-compose-dont-reply-to-self t                  ; don't reply to myself
#+END_SRC
*** orgmode integration
http://www.djcbsoftware.nl/code/mu/mu4e/Creating-org_002dmode-links.html
#+BEGIN_SRC emacs-lisp :results none
;;store org-mode links to messages
(require 'org-mu4e)
;;store link to message if in header view, not to header query
(setq org-mu4e-link-query-in-headers-mode nil)
#+END_SRC
*** view settings
#+BEGIN_SRC emacs-lisp :results none
(setq mu4e-date-format-long "%d/%m/%Y (%H:%M:%S)")
(setq mu4e-headers-date-format "%d/%m/%Y (%H:%M:%S)")

;can define a horizontal or vertical split 
(setq mu4e-split-view 'horizontal)

;; use 'fancy' non-ascii characters in various places in mu4e
(setq mu4e-use-fancy-chars t)
;; attempt to show images when viewing messages
(setq mu4e-view-show-images t)

(when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))
;preffer html  
(setq mu4e-view-prefer-html t)

;; Silly mu4e only shows names in From: by default. Of course we also  want the addresses.
(setq mu4e-view-show-addresses t)

;; mu4e-action-view-in-browser is built into mu4e
;; by adding it to these lists of custom actions
;; it can be invoked by first pressing a, then selecting
(add-to-list 'mu4e-headers-actions
             '("in browser" . mu4e-action-view-in-browser) t)
(add-to-list 'mu4e-view-actions
             '("in browser" . mu4e-action-view-in-browser) t)

;; the headers to show in the headers list -- a pair of a field
;; and its width, with `nil' meaning 'unlimited'
;; (better only use that for the last field.
;; These are the defaults:
(setq mu4e-headers-fields
    '( (:date          .  25)
       (:flags         .   6)
       (:from          .  22)
       (:subject       .  nil)))


;; don't keep message buffers around
(setq message-kill-buffer-on-exit t)

#+END_SRC
*** TODO html
TODO- CHECK W3M
#+BEGIN_SRC emacs-lisp :results none
(require 'mu4e-contrib) 
(setq mu4e-html2text-command 'mu4e-shr2text) 
;(setq mu4e-html2text-command "w3m -I utf8 -O utf8 -T text/html")
#+END_SRC

*** misc
#+BEGIN_SRC emacs-lisp :results none
;; don't keep message buffers around
(setq message-kill-buffer-on-exit t)

;; don't save message to Sent Messages, Gmail/IMAP takes care of this
(setq mu4e-sent-messages-behavior 'delete)
;; (See the documentation for `mu4e-sent-messages-behavior' if you have
;; additional non-Gmail addresses and want assign them different
;; behavior.)

#+END_SRC
*** attachments
**** define attachment dirs
 #+BEGIN_SRC emacs-lisp :results none
 (setq mu4e-attachment-dir
   (lambda (fname mtype)
     (cond
       ;; docfiles go to ~/Desktop
       ((and fname (string-match "\\.pdf$" fname))  "~/Downloads/")
       ((and fname (string-match "\\.doc$" fname))  "~/Uni/")
       ;; ... other cases  ...
       (t "~/Downloads")))) ;; everything else
 #+END_SRC
**** TODO attach files during send at end of email
http://mbork.pl/2015-11-28_Fixing_mml-attach-file_using_advice

$Note-if you see starnge behivour this maybe a culprit$  
#+BEGIN_SRC emacs-lisp  :results none
(defun mml-attach-file--go-to-eob (orig-fun &rest args)
  "Go to the end of buffer before attaching files."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-max))
      (apply orig-fun args))))

(advice-add 'mml-attach-file :around #'mml-attach-file--go-to-eob)
#+END_SRC
**** remind about attachments 
#+BEGIN_SRC emacs-lisp  :results none
(defun mbork/message-attachment-present-p ()
  "Return t if an attachment is found in the current message."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      (when (search-forward "<#part" nil t) t))))

(defcustom mbork/message-attachment-intent-re
  (regexp-opt '("I attach"
		"I have attached"
		"I've attached"
		"I have included"
		"I've included"
		"see the attached"
		"see the attachment"
		"attached file"))
  "A regex which - if found in the message, and if there is no
attachment - should launch the no-attachment warning.")

(defcustom mbork/message-attachment-reminder
  "Are you sure you want to send this message without any attachment? "
  "The default question asked when trying to send a message
containing `mbork/message-attachment-intent-re' without an
actual attachment.")

(defun mbork/message-warn-if-no-attachments ()
  "Ask the user if s?he wants to send the message even though
there are no attachments."
  (when (and (save-excursion
	       (save-restriction
		 (widen)
		 (goto-char (point-min))
		 (re-search-forward mbork/message-attachment-intent-re nil t)))
	     (not (mbork/message-attachment-present-p)))
    (unless (y-or-n-p mbork/message-attachment-reminder)
      (keyboard-quit))))

(add-hook 'message-send-hook #'mbork/message-warn-if-no-attachments)
#+END_SRC
*** Bookmarks
#+BEGIN_SRC emacs-lisp :results none
(add-to-list 'mu4e-bookmarks
  '("flag:flagged"       "flagged"     ?b))
#+END_SRC
*** Faces
#+BEGIN_SRC emacs-lisp :results none
(defgroup mu4e-faces nil 
  "Type faces (fonts) used in mu4e." 
  :group 'mu4e 
  :group 'faces) 

(defface mu4e-basic-face 
  '((t :inherit font-lock-keyword-face)) 
  "Basic Face." 
  :group 'mu4e-faces) 

(defface mu4e-list-default 
  '((t :inherit mu4e-basic-face)) 
  "Basic list Face." 
  :group 'mu4e-faces) 

(defface mu4e-rw-default 
  '((t :inherit mu4e-basic-face)) 
  "Basic rw Face." 
  :group 'mu4e-faces) 
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
;; basic face from where the rest inherits 
 '(mu4e-basic-face ((t :inherit font-lock-keyword-face :weight normal :foreground "Gray10"))) 

;; read-write group 
 '(mu4e-rw-default ((t :inherit mu4e-basic-face))) ;; face from where all the read/write faces inherits 
 '(mu4e-header-face ((t :inherit mu4e-rw-default))) 
 '(mu4e-header-marks-face ((t :inherit mu4e-rw-default))) 
 '(mu4e-header-title-face ((t :inherit mu4e-rw-default))) 
 '(mu4e-header-highlight-face ((t :inherit mu4e-rw-default :foreground "Black" :background "LightGray"))) 
 '(mu4e-compose-header-face ((t :inherit mu4e-rw-default))) 
 '(mu4e-compose-separator-face ((t :inherit mu4e-rw-default :foreground "Gray30" :weight bold))) 
 '(mu4e-footer-face ((t :inherit mu4e-rw-default))) 
 '(mu4e-contact-face ((t :inherit mu4e-rw-default :foreground "Black"))) 
 '(mu4e-cited-1-face ((t :inherit mu4e-rw-default :foreground "Gray10"))) 
 '(mu4e-cited-2-face  ((t :inherit mu4e-cited-1-face :foreground "Gray20"))) 
 '(mu4e-cited-3-face   ((t :inherit mu4e-cited-2-face :foreground "Gray30"))) 
 '(mu4e-cited-4-face    ((t :inherit mu4e-cited-3-face :foreground "Gray40"))) 
 '(mu4e-cited-5-face     ((t :inherit mu4e-cited-4-face :foreground "Gray50"))) 
 '(mu4e-cited-6-face      ((t :inherit mu4e-cited-5-face :foreground "Gray60"))) 
 '(mu4e-cited-7-face       ((t :inherit mu4e-cited-6-face :foreground "Gray70"))) 
 '(mu4e-link-face ((t :inherit mu4e-rw-default :foreground "Blue" :weight bold))) 
 '(mu4e-system-face ((t :inherit mu4e-rw-defaul :foreground "DarkOrchid"))) 
 '(mu4e-url-number-face ((t :inherit mu4e-rw-default :weight bold))) 
 '(mu4e-attach-number-face ((t :inherit mu4e-rw-default :weight bold :foreground "Blue"))) 

;; lists (headers) group 
 '(mu4e-list-default ((t :inherit mu4e-basic-face))) ;; basic list face from where lists inherits 
 '(mu4e-draft-face ((t :inherit mu4e-list-default))) 
 '(mu4e-flagged-face ((t :inherit mu4e-list-default :weight bold :foreground "Black"))) 
 '(mu4e-forwarded-face ((t :inherit mu4e-list-default))) 
 '(mu4e-list-default-face ((t :inherit mu4e-list-default))) 
 '(mu4e-title-face ((t :inherit mu4e-list-default))) 
 '(mu4e-trashed-face ((t :inherit mu4e-list-default))) 
 '(mu4e-warning-face ((t :inherit mu4e-list-default :foreground "OrangeRed1"))) 
 '(mu4e-modeline-face ((t :inherit mu4e-list-default))) 
 '(mu4e-moved-face ((t :inherit mu4e-list-default))) 
 '(mu4e-ok-face ((t :inherit mu4e-list-default :foreground "ForestGreen"))) 
 '(mu4e-read-face ((t :inherit mu4e-list-default :foreground "Gray80"))) 
 '(mu4e-region-code-face ((t :inherit mu4e-list-default :background "Gray25"))) 
 '(mu4e-replied-face ((t :inherit mu4e-list-default :foreground "Black"))) 
 '(mu4e-unread-face ((t :inherit mu4e-list-default :foreground "Blue"))) 
 '(mu4e-highlight-face ((t :inherit mu4e-unread-face))) 

 '(mu4e-special-header-value-face ((t :inherit mu4e-contact-face))) 
 '(mu4e-header-key-face ((t :inherit mu4e-contact-face :foreground "Gray50"))) 
 '(mu4e-header-value-face ((t :inherit mu4e-contact-face))) 
 '(message-cited-text ((t :inherit mu4e-rw-default :foreground "Gray10"))) 

#+END_SRC
*** Functions
**** get contacts names from field
#+BEGIN_SRC emacs-lisp  :results none
;; Function to return first name of email recipient
;; Used by yasnippet
;; Based closely on
;; http://blog.binchen.org/posts/how-to-use-yasnippets-to-produce-email-templates-in-emacs.html
(defun my-yas-get-first-name-from-to-field ()
  (let ((rlt "NAME") str rlt2)
    (save-excursion
      (goto-char (point-min))
      ;; first line in email could be some hidden line containing NO to field
      (setq str (buffer-substring-no-properties (point-min) (point-max))))
    ;; take name from TO field
    (when (string-match "^To: \"?\\([^ ,]+\\)" str)
      (setq rlt (match-string 1 str)))
    ;;get name in FROM field if available
    (when (string-match "^\\([^ ,\n]+\\).+writes:$" str)
      (progn (setq rlt2 (match-string 1 str))
             ;;prefer name in FROM field if TO field has "@"
             (when (string-match "@" rlt)
               (setq rlt rlt2))
             ))
    (message "rlt=%s" rlt)
    rlt))
#+END_SRC
**** extract all attachment to dierd
#+BEGIN_SRC emacs-lisp  :results none
(defvar bulk-saved-attachments-dir (expand-file-name "~/Documents/mu4e"))

(defun cleanse-subject (sub)
  (replace-regexp-in-string
   "[^A-Z0-9]+"
   "-"
   (downcase sub)))

(defun z/mu4e-view-attachments-dired (&optional msg)
  "Saves all of the attachments in `msg' to a directory under
`bulk-saved-attachments-dir' which is derived from the subject
beloning to `msg'. Existing filenames will be overwritten without
prompt. The directories are not cleaned up in any way."
  (interactive)
  (let* ((msg (or msg (mu4e-message-at-point)))
         (id (cleanse-subject (mu4e-message-field msg :subject)))
         (attachdir (concat bulk-saved-attachments-dir "/" id))
         (count (hash-table-count mu4e~view-attach-map)))
    (if (> count 0)
        (progn
          (mkdir attachdir t)
          (dolist (num (number-sequence 1 count))
            (let* ((att (mu4e~view-get-attach msg num))
                   (fname (plist-get att :name))
                   (index (plist-get att :index))
                   fpath)
              (setq fpath (concat attachdir "/" fname))
              (mu4e~proc-extract
               'save (mu4e-message-field msg :docid)
               index mu4e-decryption-policy fpath)))
          (dired attachdir)
          (revert-buffer))
      (message "Nothing to extract."))))
#+END_SRC
*** mu4e macros
**** delete and exe
   #+BEGIN_SRC emacs-lisp :results none
   (fset 'z/mu4e-del-exe
      [?d ?x ?y ])

  ;;for the function
  (defun z/mu4e-del-exe-func ()
    (interactive)
  (execute-kbd-macro (symbol-function 'z/mu4e-del-exe)) 
      )

   #+END_SRC
**** flag and exe
   #+BEGIN_SRC emacs-lisp :results none
   (fset 'z/mu4e-flag-exe
      [?+ ?x ?y ])

  ;;for the function
  (defun z/mu4e-flag-exe-func ()
    (interactive)
  (execute-kbd-macro (symbol-function 'z/mu4e-flag-exe)) 
      )

   #+END_SRC
**** unflag and exe
   #+BEGIN_SRC emacs-lisp :results none
   (fset 'z/mu4e-unflag-exe
      [?- ?x ?y ])

  ;;for the function
  (defun z/mu4e-unflag-exe-func ()
    (interactive)
  (execute-kbd-macro (symbol-function 'z/mu4e-unflag-exe)) 
      )

   #+END_SRC\N
* gnus for mailing lists
** config 
#+BEGIN_SRC emacs-lisp  :results none
(setq gnus-select-method '(nntp "news.gmane.org"))
#+END_SRC
** Set the prefix when using jump to select a newsgroup.

#+BEGIN_SRC emacs-lisp  :results none
  ;; ;; needs a newer gnus
  ;; (setq gnus-group-jump-to-group-prompt '((0 . "nnml:mail.") (1 .  "gmane.")
  ;;                                          (2 . "nnshimbun+")
  ;;                                          (3 .  "nnfolder+archive:")))
  ;; ;(setq gnus-group-jump-to-group-prompt "nnml:mail.")

#+END_SRC
** scoring
#+BEGIN_SRC emacs-lisp  :results none
;;The scoring system sorts articles and authors you read often to the beginning of the available mails.
;;Less interesting stuff is located at the end.

(setq gnus-use-adaptive-scoring t)
(setq gnus-score-expiry-days 14)
(setq gnus-default-adaptive-score-alist
  '((gnus-unread-mark)
    (gnus-ticked-mark (from 4))
    (gnus-dormant-mark (from 5))
    (gnus-saved-mark (from 20) (subject 5))
    (gnus-del-mark (from -2) (subject -5))
    (gnus-read-mark (from 2) (subject 1))
    (gnus-killed-mark (from 0) (subject -3))))
    ;(gnus-killed-mark (from -1) (subject -3))))
    ;(gnus-kill-file-mark (from -9999)))
    ;(gnus-expirable-mark (from -1) (subject -1))
    ;(gnus-ancient-mark (subject -1))
    ;(gnus-low-score-mark (subject -1))
    ;(gnus-catchup-mark (subject -1))))

(setq gnus-score-decay-constant 1) ;default = 3
(setq gnus-score-decay-scale 0.03) ;default = 0.05

(setq gnus-decay-scores t) ;(gnus-decay-score 1000)

#+END_SRC
** look and feel
#+BEGIN_SRC emacs-lisp  :results none
;;Summary line format strings

(setq gnus-summary-line-format "%O%U%R%z%d %B%(%[%4L: %-22,22f%]%) %s\n")
(setq gnus-summary-mode-line-format "Gnus: %p [%A / Sc:%4z] %Z")


;;Threading visual appearance

(setq gnus-summary-same-subject "")
(setq gnus-sum-thread-tree-root "")
(setq gnus-sum-thread-tree-single-indent "")
(setq gnus-sum-thread-tree-leaf-with-other "+-> ")
(setq gnus-sum-thread-tree-vertical "|")
(setq gnus-sum-thread-tree-single-leaf "`-> ")
#+END_SRC
* Emacs 25 ready stuff
You can save the cursor position for every file you opened. So, next time you open the file, the cursor will be at the position you last opened it.

Put this code in your emacs init file:

#+BEGIN_SRC emacs-lisp  :results none
;; remember cursor position, for emacs 25.1 or later
;;(save-place-mode 1)
#+END_SRC


